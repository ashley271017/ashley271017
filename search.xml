<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>算法填坑</title>
      <link href="/ashley271017.github.io/2020/01/06/%E7%AE%97%E6%B3%95%E5%A1%AB%E5%9D%91/"/>
      <url>/ashley271017.github.io/2020/01/06/%E7%AE%97%E6%B3%95%E5%A1%AB%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<h3 id="贪心法"><a href="#贪心法" class="headerlink" title="贪心法"></a>贪心法</h3><p>方法是从某一起点开始，在每一个解决问题步骤中使用贪心原则，即采取在当前状态下最有利或者是最优化的选择，贪心法常用于找出图的最小生成树，最短路径，哈夫曼编码等等<br>应用：在一定的时间之内上完尽量多的课程<br>策略：每次选择最早结束的课程</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先将已选课程的列表初始化为空，然后执行贪心算法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">executeSchedule</span><span class="params">(courses,selectionRule)</span>:</span></span><br><span class="line">    selectedCourses = []</span><br><span class="line">    <span class="keyword">while</span> len(courses) &gt; <span class="number">0</span>:</span><br><span class="line">        selCourse = earliestFinishTime(courses)</span><br><span class="line">        selectedCourses.append(selCourse)</span><br><span class="line">        courses = removeConflictingCourses(selCourse,courses)</span><br><span class="line">    <span class="keyword">return</span> selectedCourses</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">earliestFinishTime</span><span class="params">(courses)</span>:</span></span><br><span class="line">    earliestFinishTime = courses[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> courses:</span><br><span class="line">        <span class="keyword">if</span> i[<span class="number">1</span>] &lt; earliestFinishTime[<span class="number">1</span>]:</span><br><span class="line">            earliestFinishTime = i</span><br><span class="line">    <span class="keyword">return</span> earliestFinishTime</span><br><span class="line"><span class="comment"># 排除已选课程中与当前选中的课程冲突的课程</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeConflictingCourses</span><span class="params">(selCourse,courses)</span>:</span></span><br><span class="line">    noConflictingCourses = []</span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> courses:</span><br><span class="line">        <span class="keyword">if</span> s[<span class="number">1</span>] &lt;= selCourse[<span class="number">0</span>] <span class="keyword">or</span> s[<span class="number">0</span>] &gt;= selCourse[<span class="number">1</span>]:</span><br><span class="line">        noConflictingCourses.append(s)</span><br><span class="line">    <span class="keyword">return</span> noConflictingCourses</span><br></pre></td></tr></table></figure><h3 id="动态规划法"><a href="#动态规划法" class="headerlink" title="动态规划法"></a>动态规划法</h3><p>也是将一个问题拆解成若干个子问题，但是跟分治法不一样的是它会将每一个子问题的答案存储起来，以供下次求解的时候使用，这样能够减少计算的时间</p><h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><p>一种可以找出所有解或者是一部分解的算法，一旦发现不正常的数据就不再继续，而是会回到上一层</p><h3 id="递归分治"><a href="#递归分治" class="headerlink" title="递归分治"></a>递归分治</h3><p>应用：一堆真币中有一个是假的，假币的重于真的，找出假币</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">coinslist=[<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coinComparison</span><span class="params">(coinslist)</span>:</span></span><br><span class="line">    counter=<span class="number">0</span></span><br><span class="line">    currlist=coinslist</span><br><span class="line">    <span class="keyword">while</span> len(currlist) &gt; <span class="number">1</span>:</span><br><span class="line">        group1,group2,group3 = splitCoins(currlist)</span><br><span class="line">        currlist = findFakeGroup(group1,group2,group3)</span><br><span class="line">        counter+=<span class="number">1</span></span><br><span class="line">    fake=currlist[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findFakeGroup</span><span class="params">(group1,group2,group3)</span>:</span></span><br><span class="line">    resultland2 = compare(group1,group2)</span><br><span class="line">    <span class="keyword">if</span> resultland2 == <span class="string">'left'</span>:</span><br><span class="line">       fakeGroup = group1</span><br><span class="line">    <span class="keyword">elif</span> resultland2 == <span class="string">'right'</span></span><br><span class="line">       fakeGroup = group2</span><br><span class="line">    <span class="keyword">elif</span> resultland2 == <span class="string">'equal'</span></span><br><span class="line">       fakeGroup = group3</span><br><span class="line">    <span class="keyword">return</span> fakeGroup</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compare</span><span class="params">(groupA,groupB)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> sum(groupA)&gt;sum(groupB):</span><br><span class="line">       result = <span class="string">'left'</span></span><br><span class="line">    <span class="keyword">elif</span> sum(groupB)&gt;sum(groupA):</span><br><span class="line">       result = <span class="string">'right'</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">       result = <span class="string">'equal'</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">splitCoins</span><span class="params">(coinslist)</span>:</span></span><br><span class="line">    length = len(coinslist)</span><br><span class="line">    group1=coinslist[<span class="number">0</span>:length//<span class="number">3</span>]</span><br><span class="line">    group2=coinslist[length//<span class="number">3</span>:length//<span class="number">3</span>*<span class="number">2</span>]</span><br><span class="line">    group3=coinslist[length//<span class="number">3</span>*<span class="number">2</span>:length]</span><br><span class="line">    <span class="keyword">return</span> group1,group2,group3</span><br></pre></td></tr></table></figure><h3 id="记忆递归"><a href="#记忆递归" class="headerlink" title="记忆递归"></a>记忆递归</h3><p>应用：有以下的硬币，需要选择部分硬币使得他们的和最大化，并且不能选择相邻的硬币<br>1 3 2 44 5</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coins</span><span class="params">(row,memo)</span>:</span></span><br><span class="line">   <span class="keyword">if</span> len(row) == <span class="number">0</span>:</span><br><span class="line">      memo[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>,memo</span><br><span class="line">   <span class="keyword">elif</span> len(row) == <span class="number">1</span>:</span><br><span class="line">      memo[<span class="number">1</span>] = row[<span class="number">0</span>]</span><br><span class="line">      <span class="keyword">return</span> row[<span class="number">0</span>],memo</span><br><span class="line">   <span class="keyword">try</span>:</span><br><span class="line">      retukrn (memo[len(row)],memo)</span><br><span class="line">   <span class="keyword">except</span> KeyError:</span><br><span class="line">      <span class="comment"># 对应选中第一枚硬币</span></span><br><span class="line">      pick = coins(row[<span class="number">2</span>:],memo)[<span class="number">0</span>]+row[<span class="number">0</span>])</span><br><span class="line">      <span class="comment"># 对应跳过第一枚硬币</span></span><br><span class="line">      skip = coins(row[<span class="number">1</span>:],memo)[<span class="number">0</span>]</span><br><span class="line">      result = max(pick,skip)</span><br><span class="line">      memo[len(row)] = result</span><br><span class="line">      <span class="keyword">return</span> (result,memo)</span><br></pre></td></tr></table></figure><h3 id="图的广度优先搜索"><a href="#图的广度优先搜索" class="headerlink" title="图的广度优先搜索"></a>图的广度优先搜索</h3><p>应用：六度分隔，每个人与其他任何人都只需要经过六步以内的介绍，分隔度指的是每一个人之间的最大分隔度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">small = &#123;</span><br><span class="line">  &apos;A&apos;:[&apos;B&apos;,&apos;C&apos;],</span><br><span class="line">  &apos;B&apos;:[&apos;A&apos;,&apos;C&apos;]</span><br><span class="line">&#125;</span><br><span class="line">def degreesOfSeparation(graph,start):</span><br><span class="line">    if start not in graph:</span><br><span class="line">     return -1</span><br><span class="line">     visited = set()</span><br><span class="line">     frontier = set()</span><br><span class="line">     degrees=0</span><br><span class="line">     visited.add(start)</span><br><span class="line">     frontier.add(start)</span><br><span class="line">     while len(frontier) &gt; 0:</span><br><span class="line">       print(frontier,&apos;:&apos;,degrees)</span><br><span class="line">       degrees += 1</span><br><span class="line">       newfront = set()</span><br><span class="line">       for g in frontier:</span><br><span class="line">           for next in graph[g]:</span><br><span class="line">           if next not in visited:</span><br><span class="line">              visited.add(next)</span><br><span class="line">              newfront.add(next)</span><br><span class="line">              # 将当前先锋设置为新的先锋</span><br><span class="line">              frontier = newfront</span><br><span class="line">      return degrees -=1</span><br><span class="line">degreesOfSeparation(small,&apos;A&apos;)</span><br><span class="line"># &#123;&apos;A&apos;&#125;:0</span><br><span class="line"># &#123;&apos;C&apos;,&apos;B&apos;&#125;:1</span><br><span class="line"># ...</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日常记录</title>
      <link href="/ashley271017.github.io/2020/01/06/%E8%AE%B0%E5%BD%95/"/>
      <url>/ashley271017.github.io/2020/01/06/%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p> 年前的空档期去了某厂搬砖，感慨生活的不易的同时深感靠知识赚钱是一件多么幸福的事情，突然极度渴望迅速提升自己的技术水平，渴望依靠技术而不是机械性的劳动赚钱。<br> 过完年就 23 岁了，能享受年轻的日子已经不多了，三年之后开始衰老，不再是小鲜肉，可能不再有少年的激情，可能会安于现状，一心只想求稳，可能回首今天，会觉得这根本没什么大不了，因为我现在已经稳定下来了呀。。。想到这些，既觉得得到了安慰又觉得索然无味。<br> 我到底想要过怎样的人生？想要走什么样的职业道路？其实现在的我也不明确，未来的日子，道阻且长，唯一的愿望是希望自己可以少留遗憾，能一路向前不要回头吧。。。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试中的编程题</title>
      <link href="/ashley271017.github.io/2019/12/24/%E9%9D%A2%E8%AF%95%E4%B8%AD%E7%9A%84%E7%BC%96%E7%A8%8B%E9%A2%98%EF%BD%9E%E4%B8%8D%E5%AE%9A%E6%9C%9F%E6%9B%B4%E6%96%B0/"/>
      <url>/ashley271017.github.io/2019/12/24/%E9%9D%A2%E8%AF%95%E4%B8%AD%E7%9A%84%E7%BC%96%E7%A8%8B%E9%A2%98%EF%BD%9E%E4%B8%8D%E5%AE%9A%E6%9C%9F%E6%9B%B4%E6%96%B0/</url>
      
        <content type="html"><![CDATA[<ul><li><p>求多个数组的交集</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jiaojiArr</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Set</span>([...a].filter(<span class="function"><span class="params">item</span>=&gt;</span>b.includes(item)))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getJiaoji</span>(<span class="params">...arrs</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> arrs.reduce(<span class="function">(<span class="params">jiaoji,arr</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Array</span>.from(jiaojiArr(jiaoji,arr))</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现indexof</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.indexOf=<span class="function"><span class="keyword">function</span> (<span class="params">target,start=<span class="number">0</span></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> str=<span class="keyword">this</span>.slice(start).join(<span class="string">','</span>)</span><br><span class="line">  <span class="keyword">let</span> strArr=str.split(<span class="string">`<span class="subst">$&#123;target&#125;</span>,`</span>)</span><br><span class="line">  <span class="keyword">if</span>(strArr.length===<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> strArr[<span class="number">0</span>].split(<span class="string">','</span>).length - <span class="number">1</span>+start</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">String</span>.prototype.indexOf=<span class="function"><span class="keyword">function</span>(<span class="params">target,start=<span class="number">0</span></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> str=<span class="keyword">this</span>.slice(start)</span><br><span class="line">  <span class="keyword">let</span> result=str.replace(<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">`<span class="subst">$&#123;target&#125;</span>\\w+`</span>,<span class="string">'g'</span>),<span class="string">''</span>).length+start</span><br><span class="line">  <span class="keyword">return</span> result===<span class="keyword">this</span>.length? <span class="number">-1</span> : result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>判断链表中是否存在环</p></li></ul><p>思路：设置一个 slow 指针 slow = slow-&gt;next，一个 fast 指针 fast = fast-&gt;next-&gt;next。因为 fast 指针移动的比 slow 快，要是有环的话一定会相遇</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">linknode</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.val=x</span><br><span class="line"><span class="keyword">this</span>.next=<span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">linklist</span>()</span>&#123;</span><br><span class="line"><span class="keyword">constructor</span>(x)&#123;</span><br><span class="line">  <span class="keyword">this</span>.head=<span class="keyword">new</span> linknode(x)</span><br><span class="line">&#125;</span><br><span class="line">append(x)&#123;</span><br><span class="line">  <span class="keyword">const</span> newnode=<span class="keyword">new</span> linknode(x)</span><br><span class="line">  <span class="keyword">let</span> current=<span class="keyword">this</span>.head</span><br><span class="line">  <span class="keyword">while</span>(current.next)&#123;</span><br><span class="line">current=current.next</span><br><span class="line">  &#125;</span><br><span class="line">  current.next=newnode</span><br><span class="line">&#125;</span><br><span class="line">judge()&#123;</span><br><span class="line">  <span class="keyword">if</span>(!<span class="keyword">this</span>.head.next)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">let</span> fast=<span class="keyword">this</span>.head.next.next</span><br><span class="line"><span class="keyword">let</span> low=<span class="keyword">this</span>.head.next</span><br><span class="line"><span class="keyword">while</span>(fast.next)&#123;</span><br><span class="line">  <span class="keyword">if</span>(fast.next===low.next)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  fast=fast.next.next</span><br><span class="line">  low=low.next</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>从数组中取得随机数不能有重复的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRandomNumFromArr</span>(<span class="params">arr, count</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (count &gt;= arr.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> result = []</span><br><span class="line">  <span class="keyword">while</span> (result.length &lt; count) &#123;</span><br><span class="line">    <span class="keyword">let</span> random = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (arr.length<span class="number">-1</span>))</span><br><span class="line">    <span class="keyword">if</span> (!result.includes(arr[random])) &#123;</span><br><span class="line">      result.push(arr[random])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现add函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params">m</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> add(n + m)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// valueOf 在 算术运算时生效如 +add(2)(3)</span></span><br><span class="line">  fn.valueOf = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// toString 在 转换为字符串时调用 add(2)(3)</span></span><br><span class="line">  fn.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span> + n</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fn</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">1</span>); <span class="comment">// 1</span></span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>);  <span class="comment">// 3</span></span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)；  <span class="comment">// 6</span></span><br></pre></td></tr></table></figure></li><li><p>获得所有父级的ID</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = [</span><br><span class="line">  &#123;</span><br><span class="line">    id: <span class="string">'1'</span>,</span><br><span class="line">    name: <span class="string">'test1'</span>,</span><br><span class="line">    children: [</span><br><span class="line">      &#123;</span><br><span class="line">        id: <span class="string">'11'</span>,</span><br><span class="line">        name: <span class="string">'test11'</span>,</span><br><span class="line">        children: [</span><br><span class="line">          &#123;</span><br><span class="line">            id: <span class="string">'111'</span>,</span><br><span class="line">            name: <span class="string">'test111'</span></span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        id: <span class="string">'12'</span>,</span><br><span class="line">        name: <span class="string">'test12'</span>,</span><br><span class="line">        children: [</span><br><span class="line">          &#123;</span><br><span class="line">            id: <span class="string">'121'</span>,</span><br><span class="line">            name: <span class="string">'test121'</span></span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"><span class="comment">// 正则表达式版</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getParentId</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> str = <span class="built_in">JSON</span>.stringify(data)</span><br><span class="line">  <span class="keyword">const</span> childReg = <span class="regexp">/\&#123;[^&#123;&#125;]+\&#125;/g</span></span><br><span class="line">  <span class="keyword">const</span> childCollects = str.match(chilReg)</span><br><span class="line">  <span class="keyword">const</span> idReg = <span class="regexp">/(?&lt;=id\":\")\d+/g</span></span><br><span class="line">  <span class="keyword">const</span> childIdCollects = childCollects.map(<span class="function">(<span class="params">child</span>) =&gt;</span> child.match(idReg)[<span class="number">0</span>])</span><br><span class="line">  <span class="keyword">const</span> totalIdCollects = str.match(idReg)</span><br><span class="line">  <span class="keyword">return</span> totalIdCollects.filter(<span class="function">(<span class="params">item</span>) =&gt;</span> !childIdCollects.includes(item))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// DFS</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getParentId</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = &#123;&#125;</span><br><span class="line">  ;(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> parents = data.filter(<span class="function">(<span class="params">item</span>) =&gt;</span> <span class="string">'children'</span> <span class="keyword">in</span> item)</span><br><span class="line">    parents.reduce(<span class="function">(<span class="params">obj, item</span>) =&gt;</span> &#123;</span><br><span class="line">      obj[item.id] = <span class="built_in">Symbol</span>()</span><br><span class="line">      <span class="keyword">return</span> obj</span><br><span class="line">    &#125;, result)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">of</span> parents) &#123;</span><br><span class="line">      <span class="built_in">arguments</span>.callee(k.children)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)(data)</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>深度合并两个对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeDeep</span>(<span class="params">target, obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = &#123; ...target&#125;</span><br><span class="line">  ;(<span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">origin, obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> obj) &#123;</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        <span class="keyword">typeof</span> origin[k] !== <span class="string">'object'</span> ||</span><br><span class="line">        <span class="keyword">typeof</span> obj[k] !== <span class="string">'object'</span> ||</span><br><span class="line">        <span class="built_in">Array</span>.isArray(origin[k]) !== <span class="built_in">Array</span>.isArray(obj[k])</span><br><span class="line">      ) &#123;</span><br><span class="line">        origin[k] = obj[k]</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        merge(origin[k], obj[k])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)(result, obj)</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面经css篇</title>
      <link href="/ashley271017.github.io/2019/12/18/%E9%9D%A2%E7%BB%8Fcss%E7%AF%87/"/>
      <url>/ashley271017.github.io/2019/12/18/%E9%9D%A2%E7%BB%8Fcss%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h3 id="水平垂直居中的各种姿势，补充"><a href="#水平垂直居中的各种姿势，补充" class="headerlink" title="水平垂直居中的各种姿势，补充"></a>水平垂直居中的各种姿势，补充</h3><ul><li><p><a href="https://www.html.cn/archives/8510" target="_blank" rel="noopener">gird布局</a></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">justify-self</span>: center;</span><br><span class="line">    <span class="attribute">align-self</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>flex</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-class">.parent</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>:flex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.child</span>&#123;</span><br><span class="line">  <span class="attribute">margin</span>:auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="link-vs-import"><a href="#link-vs-import" class="headerlink" title="link vs @import"></a>link vs @import</h3><p>当一个页面被加载的时候（就是被浏览者浏览的时候），link引用的CSS会同时被加载，而@import引用的CSS 会等到页面全部被下载完再被加载。</p><h3 id="line-height-2-与200"><a href="#line-height-2-与200" class="headerlink" title="line-height 2 与200%"></a>line-height 2 与200%</h3><ul><li><p>父元素设置line-height: 200%;属性时 父元素设置这个属性后，其所有子元素的行高都是一个具体的值，即他们父元素字体大小的200%。下例可看出子元素的行高都一致，即父元素字体大小的2倍，32px。</p></li><li><p>父元素设置line-height: 2;属性时 父元素设置这个属性后，其所有子元素的行高都是自身字体大小的2倍。下例可看出子元素的行高都是不一致的</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面经浏览器篇</title>
      <link href="/ashley271017.github.io/2019/12/12/%E9%9D%A2%E7%BB%8F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AF%87/"/>
      <url>/ashley271017.github.io/2019/12/12/%E9%9D%A2%E7%BB%8F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h3 id="Http请求中的keep-alive"><a href="#Http请求中的keep-alive" class="headerlink" title="Http请求中的keep-alive"></a>Http请求中的keep-alive</h3><p>在http早期，每个http请求都要求打开一个tpc socket连接，并且使用一次之后就断开这个tcp连接。<br>使用keep-alive可以改善这种状态，即在一次TCP连接中可以持续发送多份数据而不会断开连接。通过使用keep-alive机制，可以减少tcp连接建立次数，也意味着可以减少TIME_WAIT状态连接，以此提高性能和提高httpd服务器的吞吐率(更少的tcp连接意味着更少的系统内核调用,socket的accept()和close()调用)。<br>但是，keep-alive并不是免费的午餐,长时间的tcp连接容易导致系统资源无效占用。配置不当的keep-alive，有时比重复利用连接带来的损失还更大。所以，正确地设置keep-alive timeout时间非常重要。</p><h3 id="浏览器为什么要限制get请求的参数的长度"><a href="#浏览器为什么要限制get请求的参数的长度" class="headerlink" title="浏览器为什么要限制get请求的参数的长度"></a>浏览器为什么要限制<code>get</code>请求的参数的长度</h3><p>是因为<code>url</code>的长度会被限制</p><h3 id="HTTPS-握手过程中，客户端如何验证证书的合法性"><a href="#HTTPS-握手过程中，客户端如何验证证书的合法性" class="headerlink" title="HTTPS 握手过程中，客户端如何验证证书的合法性"></a>HTTPS 握手过程中，客户端如何验证证书的合法性</h3><p>（1）首先浏览器读取证书中的证书所有者、有效期等信息进行校验，校验证书的网站域名是否与证书颁发的域名一致，校验证书是否在有效期内<br>（2）浏览器开始查找操作系统中已内置的受信任的证书发布机构CA，与服务器发来的证书中的颁发者CA比对，用于校验证书是否为合法机构颁发<br>（3）如果找不到，浏览器就会报错，说明服务器发来的证书是不可信任的。<br>（4）如果找到，那么浏览器就会从操作系统中取出颁发者CA 的公钥(多数浏览器开发商发布<br>版本时，会事先在内部植入常用认证机关的公开密钥)，然后对服务器发来的证书里面的签名进行解密<br>（5）浏览器使用相同的hash算法计算出服务器发来的证书的hash值，将这个计算的hash值与证书中签名做对比<br>（6）对比结果一致，则证明服务器发来的证书合法，没有被冒充</p><h3 id="get与post在缓存方面的区别"><a href="#get与post在缓存方面的区别" class="headerlink" title="get与post在缓存方面的区别"></a>get与post在缓存方面的区别</h3><p>get请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存。<br>post不同，post做的一般是修改和删除的工作，所以必须与数据库交互，所以不能使用缓存。因此get请求适合于请求缓存。</p><h3 id="四种存储"><a href="#四种存储" class="headerlink" title="四种存储"></a>四种存储</h3><ul><li>cookie的生存时间<br>如果不设置过期时间<code>expires</code>，则表示这个 cookie 生命周期为浏览器会话期间，只要关闭浏览器窗口，cookie 就消失了。这种生命期为浏览会话期的 cookie 被称为会话 cookie。会话 cookie 一般不保存在硬盘上而是保存在内存里。<br>　　如果设置了过期时间，浏览器就会把 cookie 保存到硬盘上，关闭后再次打开浏览器，这些 cookie 依然有效直到超过设定的过期时间。</li></ul><h4 id="session"><a href="#session" class="headerlink" title="session"></a>session</h4><ul><li>session的本质：就是存储在服务器上的一个哈希表。</li></ul><p>将sessionID（随机数） 通过 Cookie 发给客户端<br>客户端访问服务器时，服务器读取 sessionID<br>服务器有一块内存（哈希表）保存了所有 session<br>通过sessionID 后台可以得到对应用户的隐私信息，如 id，email<br>这块内存（哈希表）就是服务器上的所有 session</p><ul><li>为什么会有 session? cookie能被用户截取 不安全<br>之前的写法：直接将数据放到cookie里面：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.setHeader(<span class="string">'Set-Cookie'</span>, <span class="string">`login_email=<span class="subst">$&#123;email&#125;</span>`</span>)</span><br></pre></td></tr></table></figure></li></ul><p>这样写一来会暴露用户的个人信息，二来用户可以直接通过浏览器修改cookie，极有可能获取到别人的用户信息，极不安全。因此出现了下面的使用session的操作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sessions = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> sessionId = <span class="built_in">Math</span>.random() * <span class="number">10000</span> <span class="comment">// 设置sessionId 为一个随机数</span></span><br><span class="line">sessions[sessionId] = &#123;<span class="attr">login_email</span>:email&#125; <span class="comment">// 将email 存储在sessions这个对象中</span></span><br><span class="line">response.setHeader(<span class="string">'Set-Cookie'</span>, <span class="string">`sessionId = <span class="subst">$&#123;sessionId&#125;</span>`</span>) </span><br><span class="line"><span class="comment">// cookie中存储的是 sessionId 这个随机数</span></span><br></pre></td></tr></table></figure><p>首先来解释一下上面的代码：即设置cookie的中存储的值为一个随机数，当后台获取到cookie时，就可以获取到该随机数并在sessions这个对象中查找key为这个随机数的value，即可知道用户的邮箱是什么 。</p><ul><li>不基于cookie能否实现session<br>后端待用户登陆后设置他的sessionID，但不把它放在 cookie 里，而是将信息通过响应体传JSON给前端。<br>前端拿到响应体中的JSON后将其转换成对象（JSON.parse）<br>将从JSON中获取到的数据（如 sessionID）放在 localStorage 里面（localStorage里的数据目前暂时用不到）<br>以后跳转到其他页面（如首页）时，将 sessionID 放在 URL 的查询参数里（如：window.location.href = ‘/?sessionId=object.sessionId’）<br>那么进入首页后，该页面的 URL 的查询参数就带上了你的sessionID<br>后端通过在用户访问首页时，传到服务器的 URL ，来获取到查询参数，从而获取到用户的 sessionID，然后在数据库中查到sessionID对应的信息就可以知道用户是谁。</li></ul><h3 id="为什么通常在发送数据埋点请求的时候使用的是-1x1-像素的透明-gif-图片"><a href="#为什么通常在发送数据埋点请求的时候使用的是-1x1-像素的透明-gif-图片" class="headerlink" title="为什么通常在发送数据埋点请求的时候使用的是 1x1 像素的透明 gif 图片"></a>为什么通常在发送数据埋点请求的时候使用的是 1x1 像素的透明 gif 图片</h3><p>作用：工作中，用于前端监控，比如曝光等等，谷歌和百度的都是用的1x1 像素的透明 gif 图片；<br>why?</p><p>没有跨域问题，一般这种上报数据，代码要写通用的；（排除ajax）<br>不会阻塞页面加载，影响用户的体验，只要new Image对象就好了；（排除JS/CSS文件资源方式上报）<br>在所有图片中，体积最小；（比较PNG/JPG）</p><h3 id="cookie-和-localStorage-的区别是什么"><a href="#cookie-和-localStorage-的区别是什么" class="headerlink" title="cookie 和 localStorage 的区别是什么"></a>cookie 和 localStorage 的区别是什么</h3><p>答：cookie 每次请求会被带给服务器，而 localStorage不会；cookie的最大储存量一般只有4k，而localStorage 一般有5Mb</p><h3 id="sessionstorage跟localstorage的区别"><a href="#sessionstorage跟localstorage的区别" class="headerlink" title="sessionstorage跟localstorage的区别"></a>sessionstorage跟localstorage的区别</h3><p>localStorage: 在同一个浏览器内，同源文档之间共享 localStorage 数据，可以互相读取、覆盖。<br>sessionStorage: 与 localStorage 一样需要同一浏览器同源文档这一条件。不仅如此，sessionStorage 的作用域还被限定在了窗口中，也就是说，只有同一浏览器、同一窗口的同源文档才能共享数据。</p><h3 id="tcp的流量控制与拥塞控制"><a href="#tcp的流量控制与拥塞控制" class="headerlink" title="tcp的流量控制与拥塞控制"></a>tcp的流量控制与拥塞控制</h3><ul><li><p>流量控制 （实现：主要的方式就是接收方返回的 ACK 中会包含自己的接收窗口的大小，并且利用大小来控制发送方的数据发送。）<br>如果发送者发送数据过快，接收者来不及接收，那么就会有分组丢失。为了避免分组丢失，控制发送者的发送速度，使得接收者来得及接收，这就是流量控制。流量控制根本目的是防止分组丢失，它是构成TCP可靠性的一方面。</p></li><li><p>流量控制与拥塞控制的区别<br>拥塞控制：拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况；常用的方法就是：（ 1 ）慢开始、拥塞避免（ 2 ）快重传、快恢复。</p></li></ul><p>流量控制：流量控制是作用于接收者的，它是控制发送者的发送速度从而使接收者来得及接收，防止分组丢失的</p><h3 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h3><p>1、浏览器中输入想要访问的网站的域名，操作系统会先检查本地的hosts文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。<br>2、如果hosts里没有这个域名的映射，客户端会向本地DNS服务器发起查询。本地DNS服务器收到查询时，如果要查询的域名包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析。<br>3、如果本地DNS服务器本地区域文件与缓存解析都失效，则根据本地DNS服务器的设置，<code>采用递归或者迭代查询</code>，直至解析完成。</p><ul><li><p>递归查询<br><img src="https://user-gold-cdn.xitu.io/2018/5/27/1639fd992859d5f1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p></li><li><p>迭代查询<br><img src="https://user-gold-cdn.xitu.io/2018/5/27/1639fdb27f876e0d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p></li></ul><h3 id="浏览器安全"><a href="#浏览器安全" class="headerlink" title="浏览器安全"></a>浏览器安全</h3><ul><li>CSRF 的防御</li></ul><blockquote><p>1、尽量使用 POST，限制 GET<br>GET 接口太容易被拿来做 CSRF 攻击，看上面示例就知道，只要构造一个 img 标签，而 img 标签又是不能过滤的数据。接口最好限制为 POST 使用，GET 则无效，降低攻击风险。<br>当然 POST 并不是万无一失，攻击者只要构造一个 form 就可以，但需要在第三方页面做，这样就增加暴露的可能性。<br>2、将 cookie 设置为 HttpOnly<br>CRSF 攻击很大程度上是利用了浏览器的 cookie，为了防止站内的 XSS 漏洞盗取 cookie,需要在 cookie 中设置“HttpOnly”属性，这样通过程序（如 JavaScript 脚本、Applet 等）就无法读取到 cookie 信息，避免了攻击者伪造 cookie 的情况出现。<br>在 Java 的 Servlet 的 API 中设置 cookie 为 HttpOnly 的代码如下：<br>response.setHeader( “Set-Cookie”, “cookiename=cookievalue;HttpOnly”);<br>3、增加 token<br>CSRF 攻击之所以能够成功，是因为攻击者可以伪造用户的请求，该请求中所有的用户验证信息都存在于 cookie 中，因此攻击者可以在不知道用户验证信息的情况下直接利用用户的 cookie 来通过安全验证。由此可知，<br>抵御 CSRF 攻击的关键在于：在请求中放入攻击者所不能伪造的信息，并且该信总不存在于 cookie 之中。鉴于此，系统开发人员可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务端进行 token 校验，如果请求中没有 token 或者 token 内容不正确，则认为是 CSRF 攻击而拒绝该请求。<br>假设请求通过 POST 方式提交，则可以在相应的表单中增加一个隐藏域：<br><input type="hidden" name="_toicen" value="tokenvalue"><br>token 的值通过服务端生成，表单提交后 token 的值通过 POST 请求与参数一同带到服务端，每次会话可以使用相同的 token，会话过期，则 token 失效，攻击者因无法获取到 token，也就无法伪造请求。<br>   note:<br>　　1、要确保同一页面中每个表单都含有自己唯一的令牌<br>　　2、验证后需要删除相应的随机数<br>   3、Token 保存在 Session 中。假如 Token 保存在 Cookie 中，用户浏览器开了很多页面。在一些页面 Token 被使用消耗掉后新的Token 会被重新种入，但那些老的 Tab 页面对应的 HTML 里还是老 Token。这会让用户觉得为啥几分钟前打开的页面不能正常提交？<br>在 session 中添加 token 的实现代码：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HttpSession session = request.getSession();</span><br><span class="line"><span class="built_in">Object</span> token = session.getAttribute(<span class="string">"_token"</span>);</span><br><span class="line"><span class="keyword">if</span>(token == <span class="literal">null</span> I I <span class="string">""</span>.equals(token)) &#123;</span><br><span class="line">    session.setAttribute(<span class="string">"_token"</span>, UUID.randomUUIDO .toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>4、通过 Referer 识别<br>根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。在通常情况下，访问一个安全受限的页面的请求都来自于同一个网站。比如某银行的转账是通过用户访问<a href="http://www.xxx.com/transfer.do页面完成的，用户必须先登录www.xxx.com，然后通过单击页面上的提交按钮来触发转账事件。当用户提交请求时，该转账请求的Referer值就会是" target="_blank" rel="noopener">http://www.xxx.com/transfer.do页面完成的，用户必须先登录www.xxx.com，然后通过单击页面上的提交按钮来触发转账事件。当用户提交请求时，该转账请求的Referer值就会是</a><br>提交按钮所在页面的 URL（本例为 <a href="http://www.xxx" target="_blank" rel="noopener">www.xxx</a>. com/transfer.do）。如果攻击者要对银行网站实施 CSRF 攻击，他只能在其他网站构造请求，当用户通过其他网站发送请求到银行时，该请求的 Referer 的值是其他网站的地址，而不是银行转账页面的地址。因此，要防御 CSRF 攻击，银行网站只需要对于每一个转账请求验证其 Referer 值即可，如果是以 <a href="http://www.xx.om" target="_blank" rel="noopener">www.xx.om</a> 域名开头的地址，则说明该请求是来自银行网站自己的请求，是合法的；如果 Referer 是其他网站，就有可能是 CSRF 攻击，则拒绝该请求。<br>取得 HTTP 请求 Referer：<br>String referer = request.getHeader(“Referer”);<br>5.使用验证码</p><ul><li><a href="https://tech.meituan.com/2018/09/27/fe-security.html" target="_blank" rel="noopener">xss攻击方式以及防御</a></li></ul></blockquote><ul><li>中间人攻击<br>中间人攻击过程如下：</li></ul><p>服务器向客户端发送公钥。<br>攻击者截获公钥，保留在自己手上。<br>然后攻击者自己生成一个【伪造的】公钥，发给客户端。<br>客户端收到伪造的公钥后，生成加密hash值发给服务器。<br>攻击者获得加密hash值，用自己的私钥解密获得真秘钥。<br>同时生成假的加密hash值，发给服务器。<br>服务器用私钥解密获得假秘钥。<br>服务器用加秘钥加密传输信息<br>防范方法：</p><p>服务端在发送浏览器的公钥中加入CA证书，浏览器可以验证CA证书的有效性<br>强制页面使用https 防御中间人攻击</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">requestHandler</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">    res.setHeader(<span class="string">'Strict-Transport-Security'</span>,<span class="string">'max-age=31536000; includeSubDomains; preload'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="深入了解浏览器缓存机制"><a href="#深入了解浏览器缓存机制" class="headerlink" title="深入了解浏览器缓存机制"></a>深入了解浏览器缓存机制</h3><p><a href="https://www.jianshu.com/p/54cc04190252" target="_blank" rel="noopener">https://www.jianshu.com/p/54cc04190252</a><br>补充：关于强缓存取资源的位置<br>如果开启了Service Worker首先会从Service Worker中拿<br>如果新开一个以前打开过的页面缓存会从Disk Cache中拿（前提是命中强缓存）<br>刷新当前页面时浏览器会根据当前运行环境内存来决定是从 Memory Cache 还是 从Disk Cache中拿(可以看到下图最后几个文件有时候是从 Memory Cache中拿有时候是从Disk Cache中拿)</p><h3 id="303与302的区别"><a href="#303与302的区别" class="headerlink" title="303与302的区别"></a>303与302的区别</h3><p>303 常用于将 POST 请求重定向到 GET 请求，比如你上传了一份个人信息，服务器发回一个 303 响应，将你导向一个“上传成功”页面。</p><h3 id="websoket-http之间的联系"><a href="#websoket-http之间的联系" class="headerlink" title="websoket http之间的联系"></a>websoket http之间的联系</h3><ol><li>都是一样基于TCP的，都是可靠性传输协议。</li><li>都是应用层协议。</li></ol><p>WebSocket在建立握手时，数据是通过HTTP传输的。但是建立之后，在真正传输时候是不需要HTTP协议的。</p><p>WebSocket连接的过程是：</p><p>首先，客户端发起http请求，经过3次握手后，建立起TCP连接；http请求里存放WebSocket支持的版本号等信息，如：Upgrade、Connection、WebSocket-Version等；<br>然后，服务器收到客户端的握手请求后，同样采用HTTP协议回馈数据；<br>最后，客户端收到连接成功的消息后，开始借助于TCP传输信道进行全双工通信。</p><h3 id="http-keepalive"><a href="#http-keepalive" class="headerlink" title="http keepalive"></a>http keepalive</h3><p>Http keep-alive<br>在 HTTP 1.0 时期，每个 TCP 连接只会被一个 HTTP Transaction（请求加响应）使用，请求时建立，请求完成释放连接。当网页内容越来越复杂，包含大量图片、CSS 等资源之后，这种模式效率就显得太低了。所以，在 HTTP 1.1 中，引入了 HTTP persistent connection 的概念，也称为 HTTP keep-alive，目的是复用TCP连接，在一个TCP连接上进行多次的HTTP请求从而提高性能。</p><h3 id="tcp-keepalive"><a href="#tcp-keepalive" class="headerlink" title="tcp keepalive"></a>tcp keepalive</h3><p>在使用TCP长连接（复用已建立TCP连接）的场景下，需要对TCP连接进行保活，避免被网关干掉连接。<br>在应用层，可以通过定时发送心跳包的方式实现。</p><h3 id="数字签名工作原理"><a href="#数字签名工作原理" class="headerlink" title="数字签名工作原理"></a>数字签名工作原理</h3><p><a href="https://blog.51cto.com/winda/1968298" target="_blank" rel="noopener">https://blog.51cto.com/winda/1968298</a></p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul><li><a href="https://www.jianshu.com/p/9ed3e8759ce3" target="_blank" rel="noopener">浏览器缓存控制详解（cookie、session、localStorage、Cache-Control等</a></li><li><a href="https://www.jianshu.com/p/67408d73c66d" target="_blank" rel="noopener">安全|常见的Web攻击手段之CSRF攻击</a></li></ul><ul><li><a href="https://github.com/yygmind/blog/issues/43" target="_blank" rel="noopener">前端 100 问：能搞懂80%的请把简历给我</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>秋季前端面经记录</title>
      <link href="/ashley271017.github.io/2019/12/11/%E7%A7%8B%E5%AD%A3%E5%89%8D%E7%AB%AF%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/"/>
      <url>/ashley271017.github.io/2019/12/11/%E7%A7%8B%E5%AD%A3%E5%89%8D%E7%AB%AF%E9%9D%A2%E7%BB%8F%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h3 id="问到sessionstorage跟localstorage的区别-答前者只在当前窗口有效是对的-再问一遍又不确定了-说明基础不牢固容易被套路"><a href="#问到sessionstorage跟localstorage的区别-答前者只在当前窗口有效是对的-再问一遍又不确定了-说明基础不牢固容易被套路" class="headerlink" title="问到sessionstorage跟localstorage的区别 答前者只在当前窗口有效是对的 再问一遍又不确定了 说明基础不牢固容易被套路"></a>问到<code>sessionstorage</code>跟<code>localstorage</code>的区别 答前者只在当前窗口有效是对的 再问一遍又不确定了 说明基础不牢固容易被套路</h3><ol><li>存储大小： 都为 5MB</li><li>存储位置： 都在客户端，不予服务器进行交互通信</li><li>存储内容类型： 字符串，复杂的对象可以使用 ECMAScript 提供的 JSON stringify 和 parse 来处理</li><li>获取方式：window.localStorage, window.sessionStorage</li><li>应用场景： localStorage 用于长期登录 and 判断用户是否已登录<br>sessionStorage 敏感账号一次性登录</li></ol><h3 id="页面卡顿-怎么监测到是哪一部分的代码出现了问题"><a href="#页面卡顿-怎么监测到是哪一部分的代码出现了问题" class="headerlink" title="页面卡顿 怎么监测到是哪一部分的代码出现了问题"></a>页面卡顿 怎么监测到是哪一部分的代码出现了问题</h3><p><a href="http://www.ruanyifeng.com/blog/2017/09/flame-graph.html" target="_blank" rel="noopener">火焰图</a>(可以看到每个函数占据的宽度，越宽表示执行的时间越长)</p><h3 id="要是不用框架的话-怎么优化代码的结构？"><a href="#要是不用框架的话-怎么优化代码的结构？" class="headerlink" title="要是不用框架的话 怎么优化代码的结构？"></a>要是不用框架的话 怎么优化代码的结构？</h3><h4 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h4><p>又称状态机制，View 和 ViewModel 是进行绑定的，改变 ViewModel 就会直接作用到 View 视图上，而 View 会把事件传递给 ViewModel,ViewModel 去对 Model 进行操作并接受更新。</p><ul><li>View：UI 界面</li><li>ViewModel：它是 View 的抽象，负责 View 与 Model 之间信息转换，将 View 的 Command 传送到 Model；<br>比起 MVP 中 View 需要自己提供 API，MVVM 在 VM 中构建一组状态数据（state data），作为 View 状态的抽象。然后通过双向数据绑定（data binding）使 VM 中的状态数据（state data）与 View 中的显示状态（screen state）保持一致。这样，VM 中的展示逻辑只需要修改对应的状态数据，就可以控制 View 的状态，从而避免在 View 上开发大量的接口</li><li>Model：数据访问层</li></ul><p><img src="https://images2015.cnblogs.com/blog/1131758/201703/1131758-20170323093701283-975203660.png" alt="imgs"></p><p>？不适合 SEO？</p><p>例如，我们定义好一个 JavaScript 对象作为 Model，并且把这个 Model 的两个属性绑定到 DOM 节点上：</p><h4 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h4><p>View 持有了 Controller，把事件传递给 Controller，Controller 由此去触发 Model 层的事件，Model 更新完数据（网络或者本地数据）之后触发 View 的更新事件</p><ul><li>View 负责渲染用户界面，应该避免在 View 中涉及业务逻辑</li><li>Controller 负责接收用户输入，根据用户输入调用 Model 逻辑，将产生的结果交给 View 部分，让 View 渲染出必要的输出</li><li>Model 负责管理数据，大部分业务逻辑也应该放在 Model</li></ul><p><strong>缺点：</strong> 由于在实现的过程中，往往出现 View 与 Model 不经过 Controller 通信的现象，造成数据流混乱，难以维护和增加功能</p><p><img src="https://www.peterchen.club/imgs/MVCDisadvantage.png" alt="imgs"></p><h4 id="mvc-与-mvvm-的区别"><a href="#mvc-与-mvvm-的区别" class="headerlink" title="mvc 与 mvvm 的区别"></a>mvc 与 mvvm 的区别</h4><p>MVVM 与 MVC 最大的区别就是：它实现了 View 和 Model 的自动同步，也就是当 Model 的属性改变时，我们不用再自己手动操作 Dom 元素，来改变 View 的显示，而是改变属性后该属性对应 View 层显示会自动改变</p><p>拿典型的 MVVM 模式的代表，Vue，来举例<br>html 部分相当于 View 层，可以看到这里的 View 通过通过模板语法来声明式的将数据渲染进 DOM 元素，当 ViewModel 对 Model 进行更新时，通过数据绑定更新到 View。</p><p>Vue 实例中的 data 相当于 Model 层，而 ViewModel 层的核心是 Vue 中的双向数据绑定，即 Model 变化时 VIew 可以实时更新，View 变化也能让 Model 发生变化。</p><h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><p>补充：</p><ul><li>cra 生成的项目支持在<code>package.json</code>字段设置<code>proxy</code><br>如：will proxy your request to <a href="http://localhost:4000/api/todos" target="_blank" rel="noopener">http://localhost:4000/api/todos</a> as a fallback</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"proxy"</span>: <span class="string">"http://localhost:4000"</span>,</span><br></pre></td></tr></table></figure><ul><li><p>本地测试用 配置 hosts 文件 如：’127.0.0.1 xx.com’或者是配置 switchyomega 比如输入 test.xxx.com 代理到 localhost 这样发请求的时候的 origin 是 test 就不会出现跨域错误 （midc 有些接口是能跨域的，所以 origin 是 localhost 的时候也不会报错）</p></li><li><p><a href="https://segmentfault.com/a/1190000014882611" target="_blank" rel="noopener">postmessage+iframe</a></p></li></ul><h3 id="性能优化-（不要一直说-react）"><a href="#性能优化-（不要一直说-react）" class="headerlink" title="性能优化 （不要一直说 react）"></a>性能优化 （不要一直说 react）</h3><h3 id="虚拟-dom"><a href="#虚拟-dom" class="headerlink" title="虚拟 dom"></a>虚拟 dom</h3><p>就是一个普通的 JavaScript 对象，包含了 tag、props、children 三个属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  tag: <span class="string">'div'</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    id: <span class="string">'app'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  chidren: [</span><br><span class="line">    &#123;</span><br><span class="line">      tag: <span class="string">'p'</span>,</span><br><span class="line">      props: &#123;</span><br><span class="line">        className: <span class="string">'text'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      chidren: [</span><br><span class="line">        <span class="string">'hello world!!!'</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主流的虚拟 DOM 库（snabbdom、virtual-dom），通常都有一个 h 函数，也就是 React 中的 React.createElement，以及 Vue 中的 render 方法中的 createElement，另外 React 是通过 babel 将 jsx 转换为 h 函数渲染的形式，而 Vue 是使用 vue-loader 将模版转为 h 函数渲染的形式（也可以通过 babel-plugin-transform-vue-jsx 插件在 vue 中使用 jsx，本质还是转换为 h 函数渲染形式）。</p><h4 id="虚拟-dom-的优势"><a href="#虚拟-dom-的优势" class="headerlink" title="虚拟 dom 的优势"></a>虚拟 dom 的优势</h4><p>减少 JavaScript 操作真实 DOM 的带来的性能消耗。虽然这一个虚拟 DOM 带来的一个优势，但并不是全部。虚拟 DOM 最大的优势在于抽象了原本的渲染过程，实现了跨平台的能力，而不仅仅局限于浏览器的 DOM，可以是安卓和 IOS 的原生组件，可以是近期很火热的小程序，也可以是各种 GUI</p><h4 id="深浅拷贝的区别-怎么深拷贝一个函数"><a href="#深浅拷贝的区别-怎么深拷贝一个函数" class="headerlink" title="深浅拷贝的区别 怎么深拷贝一个函数"></a>深浅拷贝的区别 怎么深拷贝一个函数</h4><ul><li>浅拷贝—浅拷贝是指复制对象的时候，只对第一层键值对进行独立的复制，如果对象内还有对象，则只能复制嵌套对象的地址</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浅拷贝数组</span></span><br><span class="line">a.slice() || a.concat()</span><br></pre></td></tr></table></figure><ul><li>深拷贝—深拷贝是指复制对象的时候完全的拷贝一份对象，即使嵌套了对象，两者也相互分离，修改一个对象的属性，也不会影响另一个。其实只要递归下去，把那些属性的值仍然是对象的再次进入对象内部一 一进行复制即可。</li></ul><blockquote><p>note! JSON.parse(JSON.stringify(obj))的缺陷是不能够拷贝函数 因为 JSON 不允许包含函数，JSON.stringify() 会删除 JavaScript 对象的函数，包括 key 和 value。</p></blockquote><p>解决<code>JSON.stringify</code>不能拷贝函数的问题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">source, hash = new WeakMap(</span>)) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> obj</span><br><span class="line">  <span class="keyword">const</span> Constructor = source.constructor</span><br><span class="line">  <span class="keyword">switch</span> (Constructor) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="built_in">Date</span>:</span><br><span class="line">      obj = <span class="keyword">new</span> Constructor(source.getTime())</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="built_in">RegExp</span>:</span><br><span class="line">      obj = <span class="keyword">new</span> Constructor(source)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">if</span> (hash.has(source)) &#123;</span><br><span class="line">        <span class="keyword">return</span> hash.get(source)</span><br><span class="line">      &#125;</span><br><span class="line">      obj = <span class="keyword">new</span> Constructor()</span><br><span class="line">      hash.set(source, obj)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> source) &#123;</span><br><span class="line">    obj[key] = isObject(source[key])</span><br><span class="line">      ? deepClone(source[key], hash)</span><br><span class="line">      : source[key]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="doctype-的作用"><a href="#doctype-的作用" class="headerlink" title="doctype 的作用"></a>doctype 的作用</h4><p>声明了的话浏览器就会使用标准模式解析页面 这样所有浏览器显示的样式就是一样的</p><h4 id="使用symbol会遇到哪些问题"><a href="#使用symbol会遇到哪些问题" class="headerlink" title="使用symbol会遇到哪些问题"></a>使用<code>symbol</code>会遇到哪些问题</h4><ul><li><p><code>symbol</code>的特点<br>1.Symbol(‘key’) !== Symbol(‘key’) //true,返回不同<br>2.Symbol(“know”).name = 1; // TypeError,只读<br>3.for…in 、 Object.keys(obj) 、Object.getOwnPropertyNames(obj)会忽略 Symbol,即自身不可枚举 4.不能用 obj.prop 的形式访问</p></li><li><p><a href="https://zhuanlan.zhihu.com/p/22652486" target="_blank" rel="noopener"><code>symbol</code>的使用场景</a><br>第一个作用是作为属性名避免属性名冲突，<br>第二个作用是替代代码中多次使用的字符串（例如：abc），多次使用的字符串在代码中不易维护，而这时候定义一个对象的属性（属性名用 Symbol 格式），值为 abc，就可以作为全局变量来使用了。<br>第三个，由于以 Symbol 值作为名称的属性，不会被常规方法遍历得到。我们可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法。<br>第四个，这个有时，我们希望重新使用同一个 Symbol 值，Symbol.for 方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建并返回一个以该字符串为名称的 Symbol 值。</p></li></ul><p>生成一个唯一值 因为我们在使用它的时候属性值是多少都无所谓</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> race = &#123;</span><br><span class="line">  protoss: <span class="built_in">Symbol</span>(),</span><br><span class="line">  terran: <span class="built_in">Symbol</span>(),</span><br><span class="line">  zerg: <span class="built_in">Symbol</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">race.protoss !== race.terran <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="基本数据类型的判断"><a href="#基本数据类型的判断" class="headerlink" title="基本数据类型的判断"></a>基本数据类型的判断</h4><ul><li>typeof Symbol() === ‘symbol’</li></ul><h4 id="redux的原理（要深入-中间件）关于使用hooks实现redux"><a href="#redux的原理（要深入-中间件）关于使用hooks实现redux" class="headerlink" title="redux的原理（要深入 中间件）关于使用hooks实现redux"></a><code>redux</code>的原理（要深入 中间件）关于使用<code>hooks</code>实现<code>redux</code></h4><p>dispatch 一个 action 的时候将 action 传入所有的 reducers,然后返回更新的 state 同时触发使用<code>subscribe</code>方法注册的所有 listener 函数<br>(为什么在 hasChanged 为 true 的时候还要接着调用后面的 reducers 呢？)</p><h4 id="为什么reducer要是一个纯函数"><a href="#为什么reducer要是一个纯函数" class="headerlink" title="为什么reducer要是一个纯函数"></a>为什么<code>reducer</code>要是一个纯函数</h4><ul><li>react 有一个 shouldcomponentupdate 事件作为优化，当我们重渲染时也希望订阅事件能差异化更新以优化性能，怎么实现？比对一次更新里的新老 state<br>当 reducer 是纯函数时，生成一个新 state，新老对象地址引用不一，能实现<br>若 reducer 是副作用，那么虽然对象内变化，新老对象地址一致，不能实现<br>此外<br>在<code>combinereducers</code>中判断<code>haschanged</code>也是通过<code>nextStateForKey !== previousStateForKey</code> 直接判断引用而不是深度遍历比较两个对象的值 更简洁</li><li>如果不是纯函数 返回的 state 就具有不确定性 那么 UI 拿到的数据也具有不确定性</li></ul><h4 id="redux-中的观察者模式"><a href="#redux-中的观察者模式" class="headerlink" title="redux 中的观察者模式"></a>redux 中的观察者模式</h4><ol><li>store 提供数据的 get 钩子（store.getState）,不直接提供数据的 set，所以必须通过 dispatch（action）来 set 数据。</li><li>利用观察者模式（sub/ pub）连接 model 和 view 的中间对象。view 层通过调用 store.dispatch 方法触发 reducer 改变 model。对应 pub。 model 层通过调用 store.subscribe 注册视图更新事件（setstate），该事件会在数据改变之后被调用。对应 sub。</li></ol><blockquote><p><a href="https://www.jianshu.com/p/594f018b68e7" target="_blank" rel="noopener">观察者模式和发布订阅模式的区别</a></p></blockquote><h4 id="关于最近做的项目，自我介绍，错误监控，学了哪些新技术。。。"><a href="#关于最近做的项目，自我介绍，错误监控，学了哪些新技术。。。" class="headerlink" title="关于最近做的项目，自我介绍，错误监控，学了哪些新技术。。。"></a>关于最近做的项目，自我介绍，错误监控，学了哪些新技术。。。</h4><h4 id="关于函数组件跟类式组件的区别"><a href="#关于函数组件跟类式组件的区别" class="headerlink" title="关于函数组件跟类式组件的区别"></a>关于函数组件跟类式组件的区别</h4><p><code>props</code>是不可变数据，永远不会改变。但是，<code>this</code>却始终是可变的 。所以通过<code>this</code>拿到的永远都是最新的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProfilePage</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  showMessage = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    alert(<span class="string">'Followed '</span> + <span class="keyword">this</span>.props.user)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="keyword">this</span>.showMessage, <span class="number">3000</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span>Follow<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ProfilePage</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> showMessage = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    alert(<span class="string">'Followed '</span> + props.user)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(showMessage, <span class="number">3000</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span>Follow<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当点击 follow 之后再切换用户的名字，三秒之后函数组件弹出来的依旧是点击 follow 的时候的用户的名字<br>而类组件弹出来的却是切换之后的名字，是因为函数组件能捕获某一时刻的 props 与 state（hooks 也是一样的）</p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p>本质是一种二叉查找树，也就是左边的子节点的值比根节点小，右边的比根节点大，在极端情况下，比如连续插入依次递增或递减的节点，查找树将退化成链表<br>红黑树通过如下的性质定义实现自平衡：</p><p>节点是红色或黑色。<br>根是黑色。<br>所有叶子都是黑色（叶子是 NIL 节点）。<br>每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）<br>从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点（简称黑高）</p><h3 id="实现模糊搜索结果的关键词高亮显示"><a href="#实现模糊搜索结果的关键词高亮显示" class="headerlink" title="实现模糊搜索结果的关键词高亮显示"></a>实现模糊搜索结果的关键词高亮显示</h3><p>考虑节流、缓存。其实还可以上列表diff+定时清理缓存</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, timeout = <span class="number">300</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> t;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (t) &#123;</span><br><span class="line">        clearTimeout(t);</span><br><span class="line">      &#125;</span><br><span class="line">      t = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        fn.apply(fn, args);</span><br><span class="line">      &#125;, timeout);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// data应该是一个很大的数组 为了减小cache占的内存 缓存用户输入过的关键词 </span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">memorize</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> cache = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!name) &#123;</span><br><span class="line">        container.innerHTML = <span class="string">''</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (cache.get(name)) &#123;</span><br><span class="line">        container.innerHTML = cache.get(name);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> res = fn.call(fn, name).join(<span class="string">''</span>);</span><br><span class="line">      cache.set(name, res);</span><br><span class="line">      container.innerHTML = res;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleInput</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">`\(<span class="subst">$&#123;value&#125;</span>\)`</span>);</span><br><span class="line">    <span class="keyword">const</span> search = data.reduce(<span class="function">(<span class="params">res, cur</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (reg.test(cur)) &#123;</span><br><span class="line">        <span class="keyword">const</span> match = <span class="built_in">RegExp</span>.$<span class="number">1</span>;</span><br><span class="line">        res.push(<span class="string">`&lt;li&gt;<span class="subst">$&#123;cur.replace(match, <span class="string">'&lt;bdi&gt;$&amp;&lt;/bdi&gt;'</span>)&#125;</span>&lt;/li&gt;`</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;, []);</span><br><span class="line">    <span class="keyword">return</span> search;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> data = [<span class="string">"上海野生动物园"</span>, <span class="string">"上饶野生动物园"</span>, <span class="string">"北京巷子"</span>, <span class="string">"上海中心"</span>, <span class="string">"上海黄埔江"</span>, <span class="string">"迪士尼上海"</span>, <span class="string">"陆家嘴上海中心"</span>]</span><br><span class="line">  <span class="keyword">const</span> container = <span class="built_in">document</span>.querySelector(<span class="string">'.container'</span>);</span><br><span class="line">  <span class="keyword">const</span> memorizeInput = memorize(handleInput);</span><br><span class="line">  <span class="built_in">document</span>.querySelector(<span class="string">'.inp'</span>).addEventListener(<span class="string">'input'</span>, debounce(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    memorizeInput(e.target.value);</span><br><span class="line">  &#125;))</span><br></pre></td></tr></table></figure><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/75533792" target="_blank" rel="noopener">虚拟 DOM 到底是什么</a></li><li><a href="https://www.kancloud.cn/lixianshengdezhanghao/interview/904696" target="_blank" rel="noopener">MVC 和 MVVM 的区别</a></li><li><a href="https://juejin.im/post/5cb707626fb9a0689d6f9797" target="_blank" rel="noopener">React 函数组件和类组件的差异</a></li><li><a href="https://juejin.im/post/5cc1a0a3e51d456e403772ed" target="_blank" rel="noopener">“深拷贝” 与 “浅拷贝” 的区别，JS 实现深浅拷贝的几种方法</a></li><li><a href="https://zhuanlan.zhihu.com/p/22652486" target="_blank" rel="noopener">「每日一题」JS 中的 Symbol 是什么？</a></li><li><a href="https://github.com/yygmind/blog/issues/43" target="_blank" rel="noopener">前端 100 问：能搞懂 80%的请把简历给我</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>面经项目构建篇</title>
      <link href="/ashley271017.github.io/2019/12/11/%E9%9D%A2%E7%BB%8F%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E7%AF%87/"/>
      <url>/ashley271017.github.io/2019/12/11/%E9%9D%A2%E7%BB%8F%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h3 id="怎么约束代码规范？"><a href="#怎么约束代码规范？" class="headerlink" title="怎么约束代码规范？"></a>怎么约束代码规范？</h3><p>结合<code>lint-staged</code>与<code>husky</code> 实现在每次提交之前 自动修复本次修改的代码</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"precommit"</span>: <span class="string">"lint-staged"</span> //这个钩子是在安装husky之后才有的 package.json中原有的钩子:https://segmentfault.com/a/<span class="number">1190000008832423</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"lint-staged"</span>: &#123;</span><br><span class="line">    <span class="attr">"src/**/*.js"</span>: [<span class="string">"eslint --fix"</span>, <span class="string">"git add"</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 或者使用下面的配置，自动格式化代码（谨慎使用）：</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"precommit"</span>: <span class="string">"lint-staged"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"lint-staged"</span>: &#123;</span><br><span class="line">    <span class="attr">"src/**/*.js"</span>: [<span class="string">"prettier --write"</span>, <span class="string">"git add"</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="webpack打包优化"><a href="#webpack打包优化" class="headerlink" title="webpack打包优化"></a>webpack打包优化</h3><ul><li><p>定位体积大的模块 - webpack-bundle-analyzer</p></li><li><p>移除不必要的文件<br>使用webpack自带的两个库</p></li><li><p>IgnorePlugin</p></li><li><p>ContextReplacementPlugin</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插件配置</span></span><br><span class="line">plugins: [</span><br><span class="line">  <span class="comment">// 忽略moment.js中所有的locale文件</span></span><br><span class="line">  <span class="keyword">new</span> webpack.IgnorePlugin(<span class="regexp">/^\.\/locale$/</span>, /moment$/),</span><br><span class="line">],</span><br><span class="line"><span class="comment">// 使用方式</span></span><br><span class="line"><span class="keyword">const</span> moment = <span class="built_in">require</span>(<span class="string">'moment'</span>);</span><br><span class="line"><span class="comment">// 引入zh-cn locale文件</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'moment/locale/zh-cn'</span>);</span><br><span class="line">moment.locale(<span class="string">'zh-cn'</span>);</span><br></pre></td></tr></table></figure></li><li><p>模块化引用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;chain, cloneDeep&#125; <span class="keyword">from</span> <span class="string">'lodash'</span>;</span><br><span class="line"><span class="comment">// 可以改写为</span></span><br><span class="line"><span class="keyword">import</span> chain <span class="keyword">from</span> <span class="string">'lodash/chain'</span>;</span><br><span class="line"><span class="keyword">import</span> cloneDeep <span class="keyword">from</span> <span class="string">'lodash/cloneDeep'</span>;</span><br></pre></td></tr></table></figure></li><li><p>通过CDN引用</p></li><li><p>服务端开启Gzip压缩<br>开启gzip压缩可以减少HTTP传输的数据量和时间，从而减少客户端请求的响应时间</p></li><li><p><code>splitChunks</code>配置代码分割<br>此特性能够把代码分离到不同的 bundle 中，然后可以按需加载或并行加载这些文件。代码分离可以用于获取更小的 bundle，以及控制资源加载优先级，如果使用合理，会极大影响加载时间。</p></li></ul><h3 id="webpack-热更新原理"><a href="#webpack-热更新原理" class="headerlink" title="webpack 热更新原理"></a>webpack 热更新原理</h3><p>在 webpack 中，都是模块且有唯一标识。在 webpack 编译完成后，将修改的模块 hash 对应的模块重新执行。就达到了局部刷新的效果。</p><p>过程<br>webpack-dev-middleware 是用来处理文件打包到哪里，到内存读取速度更快。<br>devServer 在监听 compiler done 后，利用 socket 告诉 devServer/client 修改模块的 hash<br>HMR.runtime 利用 HTTP 请求 hash.hot-update.json 获取更新模块列表 hotDownloadManifest<br>{“h”:”11ba55af05df7c2d3d13”,”c”:{“index-wrap”:true}}<br>再通过 HTTP (jsonp) 获取更新模块的 js<br>index-wrap.7466b9e256c084c8463f.hot-update.js<br>返回执行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">webpackHotUpdate(<span class="string">"index-wrap"</span>, &#123;</span><br><span class="line">  <span class="comment">// ....</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>webpackHotUpdate</code> 做了三件事<br>找到过期的模块和依赖并从缓存中删除</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> installedModules[moduleId];</span><br><span class="line"><span class="keyword">delete</span> outdatedDependencies[moduleId];</span><br></pre></td></tr></table></figure><p>遍历所有的 module.children，重新 <code>installedModules</code> 所有的子模块<br>最后将自身模块的内容做替换修改</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modules[moduleId] = appliedUpdate[moduleId]</span><br></pre></td></tr></table></figure><p>最后代码替换之后并没有重新执行，需要手动注册需要重新执行的模块方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">module</span>.hot) &#123;</span><br><span class="line">   <span class="built_in">module</span>.hot.accept(<span class="string">'./print.js'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'Accepting the updated printMe module!'</span>);</span><br><span class="line">     printMe();</span><br><span class="line">   &#125;)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="国际化方案"><a href="#国际化方案" class="headerlink" title="国际化方案"></a>国际化方案</h3><p>后端在<code>cookie</code>中设置<code>applocal</code>字段 前端再去拿。。。</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul><li>[用 husky 和 lint-staged 构建超溜的代码检查工作流](用 husky 和 lint-staged 构建超溜的代码检查工作流)</li><li><a href="https://juejin.im/post/5b1e303b6fb9a01e605fd0b3" target="_blank" rel="noopener">Webpack打包优化</a></li><li><a href="https://juejin.im/post/5de0cfe46fb9a071665d3df0" target="_blank" rel="noopener">轻松理解webpack热更新原理</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面经js篇</title>
      <link href="/ashley271017.github.io/2019/12/10/%E9%9D%A2%E7%BB%8Fjs%E7%AF%87/"/>
      <url>/ashley271017.github.io/2019/12/10/%E9%9D%A2%E7%BB%8Fjs%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h2 id="原生-js"><a href="#原生-js" class="headerlink" title="原生 js"></a>原生 js</h2><h3 id="typeof的原理"><a href="#typeof的原理" class="headerlink" title="typeof的原理"></a><code>typeof</code>的原理</h3><p>js 在底层存储变量的时候，会在变量的机器码的低位 1-3 位存储其类型信息 👉</p><blockquote><p>000：对象<br>010：浮点数<br>100：字符串<br>110：布尔<br>1：整数</p></blockquote><p>but, 对于 undefined 和 null 来说，这两个值的信息存储是有点特殊的。<br>null：所有机器码均为 0<br>undefined：用 −2^30 整数来表示<br>所以，typeof 在判断 null 的时候就出现问题了，由于 null 的所有机器码均为 0，因此直接被当做了对象来看待。</p><h3 id="instanceof的原理"><a href="#instanceof的原理" class="headerlink" title="instanceof的原理"></a><code>instanceof</code>的原理</h3><p>通过判断右边的变量的<code>prototype</code>是否在左边的变量的原型链上</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myInstanceOf</span>(<span class="params">leftVal, rightVal</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> rightProto = rightVal.prototype</span><br><span class="line">  <span class="keyword">let</span> leftCopy = leftVal.__proto__</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (leftCopy === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (leftCopy === rightProto) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    leftCopy = leftCopy.__proto__</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="生成指定范围内的随机数"><a href="#生成指定范围内的随机数" class="headerlink" title="生成指定范围内的随机数"></a>生成指定范围内的随机数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">RandomNum</span> (<span class="params">min, max</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> range = max - min</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.round(<span class="built_in">Math</span>.random()*range) + min</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="null-undefined-的区别"><a href="#null-undefined-的区别" class="headerlink" title="null undefined 的区别"></a>null undefined 的区别</h3><p>前者是一个特殊的对象 不会被垃圾回收机制回收 前者转换成数字是 0 后者是 NaN</p><h3 id="函数参数是按值传递-为什么传一个对象进去-函数内部的修改会影响该对象"><a href="#函数参数是按值传递-为什么传一个对象进去-函数内部的修改会影响该对象" class="headerlink" title="函数参数是按值传递 为什么传一个对象进去 函数内部的修改会影响该对象"></a>函数参数是按值传递 为什么传一个对象进去 函数内部的修改会影响该对象</h3><p>传的是是栈内数据的拷贝<br>简单数据类型传的是 值本身 （因为直接把值存在栈内）<br>复杂数据类型传的是 对象在内存里面的地址 （因为复杂对象存在堆内，所以在栈里存对象所在的堆地址）</p><h3 id="你觉得jQuery或zepto源码有哪些写的好的地方"><a href="#你觉得jQuery或zepto源码有哪些写的好的地方" class="headerlink" title="你觉得jQuery或zepto源码有哪些写的好的地方"></a>你觉得jQuery或zepto源码有哪些写的好的地方</h3><p>jquery源码封装在一个匿名函数的自执行环境中，有助于防止变量的全局污染，然后通过传入window对象参数，可以使window对象作为局部变量使用，好处是当jquery中访问window对象的时候，就不用将作用域链退回到顶层作用域了，从而可以更快的访问window对象。同样，传入undefined参数，可以缩短查找undefined时的作用域链。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"> window, undefined </span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//用一个函数域包起来，就是所谓的沙箱</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">//在这里边var定义的变量，属于这个函数域内的局部变量，避免污染全局</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">//把当前沙箱需要的外部变量通过函数参数引入进来</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">//只要保证参数对内提供的接口的一致性，你还可以随意替换传进来的这个参数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">window</span>.jQuery = <span class="built_in">window</span>.$ = jQuery;</span><br><span class="line"></span><br><span class="line">&#125;)( <span class="built_in">window</span> );</span><br></pre></td></tr></table></figure><h3 id="虚拟dom"><a href="#虚拟dom" class="headerlink" title="虚拟dom"></a>虚拟dom</h3><ul><li><p>为什么直接操作dom耗时<br>v8 binding会将原生的dom对象（比如document.a)映射成包装的js对象，所以执行<code>document.a=。。。</code>很快<br>但是<code>document.title=。。。</code>很慢是因为修改title的时候同时也修改了 DOM 对象的 attributes<br>此外很多时候操作dom都会引起重绘与回流 并且很多dom api的读写都会设计页面布局的重新计算以确保返回值的准确</p></li><li><p>虚拟dom不快 为什么react快</p><blockquote><p>React is fast because it only manipulates the DOM as much as it needs to,Updating changes is much faster than re-building the entire DOM tree from scratch. It’s able to do this because it keeps the virtual DOM representation from the last time we updated or rendered our component in memory. It then compares the two versions and updates the changes.</p></blockquote></li></ul><blockquote><p>React Virtual DOM is an object,<br>when we create an webpage browser create dom in a tree manner. to find the changes in two different trees &gt;time complexity is O(n^3) but REACT DIFF algorithm can able to do it in O(n) time by using keys of each node.that is why react is faster</p></blockquote><ul><li>为什么虚拟dom性能更好<blockquote><p>传统MVC框架,如backbone,它是将某个模板编译成模板函数,需要更新时,是自己手动将数据整体传入模板函数, 得到一个字符串,使用innerHTML刷新某个容器!注意,这里其实可以优化,但由于是手动,是体力活,都是使用很粗放型的innerhTML了事 (使用jQuery的html方法性能会更差,不过好处是它处理了IE下的innerHTML BUG及全平台的无法执行内部的script标签的BUG) 由于整体替换,一下子销毁这么多元素(有时还绑着事件,可能导致GC出问题),又要插入这么多元素,再重新绑定事件(这个可以使用事件代理缓解) 因此性能非常差</p></blockquote></li></ul><blockquote><p>knockout那样, 使用时让用户痛苦一些,使用可同步视图的东西用函数(wrapper)包裹起来, 刷新视图,就只需要重新调用这个wrapper.现在所有新的MVVM都是从ko那里学到依赖收集. 这个wraper会通知其依赖的wrapper,通过极其痛苦晦涩的方式进入事件总线, 执行视图刷新函数. knockout是使用闭包用到极致的库,显然这样做性能也很差.</p></blockquote><blockquote><p>最后react, 首先使用编译手段(jsx的虚拟DOM转换), 将这部分消耗能提前释放出去, 不过将字符串(jsx模板)转换为一个个JS对象,也占不了多少内存. 然后是数据发生变动时, 由于数据变动都是需要用setState方法,因此兼容性很好, 少了Object.defineProperty或wrapper的消耗,然后对应数据通过render转换成字符串,字符串再转换虚拟DOM树 先后虚拟DOM进行比较, 更新视图.</p></blockquote><blockquote><p>react是面向组件设计, 一个组件就是一个密封舱, 很少会对所有虚拟DOM进行比较, 由于强制使用单向流动, 减少每次变动需要的diff. 没有绑定对象与wrapper的内存占用高的问题.</p></blockquote><h3 id="实现函数柯里化"><a href="#实现函数柯里化" class="headerlink" title="实现函数柯里化"></a>实现函数柯里化</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> context = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">let</span> args = []</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...arg</span>) </span>&#123;</span><br><span class="line">    args = args.concat(arg)</span><br><span class="line">    <span class="keyword">if</span> (arg.length) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">arguments</span>.callee</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> f.apply(context, arg)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="arguments-callee-与arguments-caller的区别"><a href="#arguments-callee-与arguments-caller的区别" class="headerlink" title="arguments.callee 与arguments.caller的区别"></a><code>arguments.callee</code> 与<code>arguments.caller</code>的区别</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// arguments.callee : [Function:f]</span></span><br><span class="line">  <span class="comment">//  arguments.caller : [Function:g]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  f()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类数组对象有哪些"><a href="#类数组对象有哪些" class="headerlink" title="类数组对象有哪些"></a>类数组对象有哪些</h3><p>具有length属性的并且能使用索引访问的 比如arguments dom相关的数据结构 localstorage sesstionstorage..</p><h3 id="函数提升跟变量提升"><a href="#函数提升跟变量提升" class="headerlink" title="函数提升跟变量提升"></a>函数提升跟变量提升</h3><p>函数声明的优先级最高，会被提升至当前作用域最顶端</p><h3 id="实现深拷贝"><a href="#实现深拷贝" class="headerlink" title="实现深拷贝"></a>实现深拷贝</h3><h3 id="循环递归实现"><a href="#循环递归实现" class="headerlink" title="循环递归实现"></a>循环递归实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  name: <span class="string">'mary'</span>,</span><br><span class="line">  age: <span class="number">20</span>,</span><br><span class="line">  friend: &#123;</span><br><span class="line">    name: <span class="string">'哈哈'</span>,</span><br><span class="line">    age: <span class="number">19</span>,</span><br><span class="line">    hobby: <span class="string">'eat'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deep</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> newobj = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="comment">// 此处遍历的key包括了实例对象和它原型的属性，所以要用hasOwnProperty进行筛选(node环境不会，浏览器环境会列举原型属性)</span></span><br><span class="line">    <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">      <span class="comment">// 如果是基本类型则进行复制</span></span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        <span class="keyword">typeof</span> obj[key] === <span class="string">'number'</span> ||</span><br><span class="line">        <span class="keyword">typeof</span> obj[key] === <span class="string">'string'</span> ||</span><br><span class="line">        <span class="keyword">typeof</span> obj[key] === <span class="string">'boolean'</span> ||</span><br><span class="line">        obj[key] === <span class="literal">undefined</span> ||</span><br><span class="line">        obj[key] === <span class="literal">null</span></span><br><span class="line">      ) &#123;</span><br><span class="line">        newobj[key] = obj[key]</span><br><span class="line">        <span class="comment">// 如果不是则为array或者object,仍然需要深层次的递归复制</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newobj[key] = deep(obj[key])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newobj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="load-事件与-DOMContentLoaded-事件-document-ready"><a href="#load-事件与-DOMContentLoaded-事件-document-ready" class="headerlink" title="load 事件与 DOMContentLoaded 事件,$(document).ready()"></a>load 事件与 DOMContentLoaded 事件,$(document).ready()</h3><ul><li>当 DOMContentLoaded 事件触发时，仅当 DOM 加载完成，不包括样式表，图片。</li><li>当 onload 事件触发时，页面上所有的 DOM，样式表，脚本，图片都已经加载完成了。</li><li>$(document).ready()是DOM结构绘制完毕后就执行，不必等到加载完毕</li><li>window.onload不能同时编写多个，如果有多个window.onload方法，只会执行一个，$(document).ready()可以同时编写多个，并且都可以得到执行,$(document).ready(function(){})可以简写成$(function(){})</li></ul><h3 id="构造函数的返回值"><a href="#构造函数的返回值" class="headerlink" title="构造函数的返回值"></a>构造函数的返回值</h3><blockquote><p>构造函数不需要显示的返回值。使用 new 来创建对象(调用构造函数)时，如果 return 的是非对象(数字、字符串、布尔类型等)会忽而略返回值;如果 return 的是对象，则返回该对象(注：若 return null 也会忽略返回值）。</p></blockquote><h3 id="大数求和"><a href="#大数求和" class="headerlink" title="大数求和"></a>大数求和</h3><p>采用小时侯学加法时的手动计算的方法，从最低位依次相加，得到最后的结果<br>因为对于较大的数js会自动采用科学记数法的方式表示，所以参与计算的参数用字符串表示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSum</span>(<span class="params">d1, d2</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果第一个数较大则交换两个数</span></span><br><span class="line">    <span class="keyword">if</span> (d1.length &lt; d2.length) &#123;</span><br><span class="line">        [d1, d2] = [d2, d1];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将两个数转为数组形式</span></span><br><span class="line">    <span class="keyword">let</span> [arr1, arr2] = [[...d1].reverse(), [...d2].reverse()];</span><br><span class="line">    <span class="comment">// num用作当对应位数相加大于10时做进位</span></span><br><span class="line">    <span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 循环arr1.length次求和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr1.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr2[i]) &#123;</span><br><span class="line">            arr1[i] = <span class="built_in">Number</span>.parseInt(arr1[i]) + <span class="built_in">Number</span>.parseInt(arr2[i]) + num;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            arr1[i] = <span class="built_in">Number</span>.parseInt(arr1[i]) + num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arr1[i] &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">            [arr1[i], num] = [arr1[i] % <span class="number">10</span>, <span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            num = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果最后进位为1，则结果前应加1为</span></span><br><span class="line">    <span class="keyword">if</span> (num === <span class="number">1</span>) &#123;</span><br><span class="line">        arr1[arr1.length] = num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回结果字符串</span></span><br><span class="line">    <span class="keyword">return</span> arr1.reverse().join(<span class="string">''</span>);</span><br><span class="line">&#125;</span><br><span class="line">args=args.concat(arg)</span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### generator函数的使用场景</span></span><br><span class="line"><span class="string">* 多文件上传 上传完第一组文件之后暂停执行 做其他的事情 之后再继续上传 通过返回值done属性是否为真来判断能否继续执行</span></span><br><span class="line"><span class="string">* 生成具有index的enumerate结构 (返回的是iterator对象 能直接使用for in遍历，也能作为Array.from等的参数)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 深度比较两个对象</span></span><br><span class="line"><span class="string">1.通过json.parse(json.stringify)... 相等直接返回true</span></span><br><span class="line"><span class="string">2.object.keys.length不相等 返回false</span></span><br><span class="line"><span class="string">3.遍历 遇到为对象的属性递归</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 实现 bind</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line"><span class="comment">// 定义这个方法为myBind</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.my_bind = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>, <span class="comment">// 保存原函数</span></span><br><span class="line">    context = <span class="built_in">Array</span>.prototype.shift.call(<span class="built_in">arguments</span>), <span class="comment">// 保存需要绑定的this上下文</span></span><br><span class="line">    <span class="comment">// 上一行等价于 context = [].shift.call(arguments);</span></span><br><span class="line">    args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>) <span class="comment">// 剩余的参数转为数组</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 返回一个新函数</span></span><br><span class="line">    self.apply(</span><br><span class="line">      context,</span><br><span class="line">      <span class="built_in">Array</span>.prototype.concat.call(args, <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>))</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="promise的构造函数跟他的then方法是异步还是同步"><a href="#promise的构造函数跟他的then方法是异步还是同步" class="headerlink" title="promise的构造函数跟他的then方法是异步还是同步"></a>promise的构造函数跟他的then方法是异步还是同步</h3><p>promise构造函数是同步执行的，then方法因为是微任务是异步执行的</p><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><ul><li>为什么要模块化<br>为了避免全局污染</li><li>思维导图<br><a href="https://www.processon.com/view/link/5c8409bbe4b02b2ce492286a#map" target="_blank" rel="noopener">https://www.processon.com/view/link/5c8409bbe4b02b2ce492286a#map</a></li></ul><h3 id="js类型转换"><a href="#js类型转换" class="headerlink" title="js类型转换"></a>js类型转换</h3><ul><li><p>强制类型转换<br>通过 Number()、parseInt()、parseFloat()、toString()、String()、Boolean(),进行强制类型转换。</p></li><li><p>隐式类型转换<br>逻辑运算符(&amp;&amp;、 ||、 !)、运算符(+、-、*、/)、关系操作符(&gt;、 &lt;、 &lt;= 、&gt;=)、相等运算符(==)或者 if/while 的条件，可能会进行隐式类型转换。<br>关于valueof tostring<br>在数值运算里，会优先调用valueOf() 字符串运算优先调用后者</p></li></ul><h3 id="实现数组扁平化"><a href="#实现数组扁平化" class="headerlink" title="实现数组扁平化"></a>实现数组扁平化</h3><ul><li>方式一</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;[].concat.apply([], [[<span class="number">1</span>], [<span class="number">2</span>], [<span class="number">3</span>]]) <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><ul><li><p>chrome 69 后数组自带 flat 方法</p></li><li><p>方式二</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev, item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> prev.concat(<span class="built_in">Array</span>.isArray(item) ? flatten(item) : item)</span><br><span class="line">  &#125;, [])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方式三</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(arr.some(<span class="function"><span class="params">item</span>=&gt;</span><span class="built_in">Array</span>.isArray(item))&#123;</span><br><span class="line">        arr = [].concat(...arr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现-1-2-mutiple-1-2-1-4"><a href="#实现-1-2-mutiple-1-2-1-4" class="headerlink" title="实现[1,2].mutiple() = [1,2,1,4]"></a>实现<code>[1,2].mutiple() = [1,2,1,4]</code></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.mutiple = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> tail = <span class="keyword">this</span>.map(<span class="function">(<span class="params">item</span>) =&gt;</span> item ** <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">return</span> [...this, ...tail]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现compose函数"><a href="#实现compose函数" class="headerlink" title="实现compose函数"></a>实现compose函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">...funcs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (funcs.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">arg</span> =&gt;</span> arg</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (funcs.length === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> funcs[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> last = funcs[funcs.length - <span class="number">1</span>]</span><br><span class="line">  <span class="keyword">const</span> rest = funcs.slice(<span class="number">0</span>, <span class="number">-1</span>)</span><br><span class="line">  <span class="comment">// reduceright:将数组中每一项从右向左调用callback</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> rest.reduceRight(<span class="function">(<span class="params">composed, f</span>) =&gt;</span> f(composed), last(...args))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="var-a3-name-“前端开发”-var-b3-a3-a3-null-console-log-b3"><a href="#var-a3-name-“前端开发”-var-b3-a3-a3-null-console-log-b3" class="headerlink" title="var a3 = {name: “前端开发”}; var b3 = a3; a3 = null console.log(b3)?"></a>var a3 = {name: “前端开发”}; var b3 = a3; a3 = null console.log(b3)?</h3><p>// {name: “前端开发”}</p><h3 id="事件委托的优缺点"><a href="#事件委托的优缺点" class="headerlink" title="事件委托的优缺点"></a>事件委托的优缺点</h3><ul><li>优点<br>减少事件注册 减小内存</li><li>缺点<br>有的事件不支持冒泡</li></ul><h3 id="0-1-0-2-0-3"><a href="#0-1-0-2-0-3" class="headerlink" title="0.1+0.2!=0.3"></a>0.1+0.2!=0.3</h3><p>十进制的 0.1 和 0.2 都会被转换成二进制，但由于浮点数用二进制表达时是无穷的，例如。<br>JavaScript 代码:<br>0.1 -&gt; 0.0001100110011001…(无限)<br>0.2 -&gt; 0.0011001100110011…(无限)<br>IEEE 754 标准的 64 位双精度浮点数的小数部分最多支持 53 位二进制位，所以两者相加之后得到二进制为：<br>JavaScript 代码:<br>0.0100110011001100110011001100110011001100110011001100<br>因浮点数小数位的限制而截断的二进制数字，再转换为十进制，就成了 0.30000000000000004。所以在进行算术计算时会产生误差</p><h3 id="怎么设置对象的属性不能被删除？"><a href="#怎么设置对象的属性不能被删除？" class="headerlink" title="怎么设置对象的属性不能被删除？"></a>怎么设置对象的属性不能被删除？</h3><p><code>definePropperty</code>设置<code>configurable</code> false<br>why? <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/delete" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/delete</a></p><h3 id="addeventListener的第三个参数"><a href="#addeventListener的第三个参数" class="headerlink" title="addeventListener的第三个参数"></a>addeventListener的第三个参数</h3><p>是一个对象option,包括<code>capture, passive,once</code>选项 不支持这种写法的默认第三个参数是<code>usecapture</code></p><h3 id="几种判断数组类型的优缺点"><a href="#几种判断数组类型的优缺点" class="headerlink" title="几种判断数组类型的优缺点"></a>几种判断数组类型的优缺点</h3><p>instanceof不能检测来自iframe的数组。就是window.frames[xx].Array构造出来的数组<br>Array.isArray兼容性没那么好</p><h3 id="为什么表单能跨域"><a href="#为什么表单能跨域" class="headerlink" title="为什么表单能跨域"></a>为什么表单能跨域</h3><p>因为表单的请求一般都是提交数据 并且传统form表单提交浏览器会发生跳转 并且不需要返回响应数据 是安全的</p><h3 id="为什么箭头函数不能使用new操作符"><a href="#为什么箭头函数不能使用new操作符" class="headerlink" title="为什么箭头函数不能使用new操作符"></a>为什么箭头函数不能使用<code>new</code>操作符</h3><p>因为它没有自己的this与prototype 属性 ，而 new 命令在执行时需要将构造函数的 prototype 赋值给新的对象的 <strong>proto</strong></p><h2 id="react-相关"><a href="#react-相关" class="headerlink" title="react 相关"></a>react 相关</h2><h3 id="React-中-setState-什么时候是同步的，什么时候是异步的"><a href="#React-中-setState-什么时候是同步的，什么时候是异步的" class="headerlink" title="React 中 setState 什么时候是同步的，什么时候是异步的"></a>React 中 setState 什么时候是同步的，什么时候是异步的</h3><p>在 React 中，如果是由 React 引发的事件处理也就是合成事件（比如通过 onClick 引发的事件处理），调用 setState 不会同步更新 this.state，除此之外的 setState 调用会同步执行 this.state。所谓“除此之外”，指的是绕过 React 通过 addEventListener 直接添加的事件处理函数也就是原生事件，还有通过 setTimeout/setInterval 产生的异步调用。</p><p><strong>原因：</strong>在 React 的 setState 函数实现中，会根据一个变量 isBatchingUpdates 判断是直接更新 this.state 还是放到队列中回头再说，而 isBatchingUpdates 默认是 false，也就表示 setState 会同步更新 this.state，但是，有一个函数 batchedUpdates，这个函数会把 isBatchingUpdates 修改为 true，而当 React 在调用事件处理函数之前就会调用这个 batchedUpdates，造成的后果，就是由 React 控制的事件处理过程 setState 不会同步更新 this.state。</p><h3 id="jsx-语法为什么-需要-import-react-包"><a href="#jsx-语法为什么-需要-import-react-包" class="headerlink" title="jsx 语法为什么 需要 import react 包"></a>jsx 语法为什么 需要 import react 包</h3><p>JSX 语法只是一种语法糖，<code>babel</code>转译之后就会变成<code>React.createElement</code></p><h3 id="react-生命周期变更的原因"><a href="#react-生命周期变更的原因" class="headerlink" title="react 生命周期变更的原因"></a>react 生命周期变更的原因</h3><p>在 fiber 中，更新是分阶段的，具体分为两个阶段，首先是 reconciliation 的阶段，这个阶段在计算前后 dom 树的差异，然后是 commit 的阶段，这个阶段将把更新渲染到页面上。第一个阶段是可以打断的，因为这个阶段耗时可能会很长，因此需要暂停下来去执行其他更高优先级的任务，第二个阶段则不会被打断，会一口气把更新渲染到页面上。</p><p>由于 <code>reconciliation</code> 的阶段会被打断，可能会导致 <code>commit</code> 前的这些生命周期函数多次执行。react 官方目前已经把 <code>componentWillMount</code>、<code>componentWillReceiveProps</code> 和 <code>componetWillUpdate</code> 标记为 unsafe，并使用新的生命周期函数 <code>getDerivedStateFromProps</code> 和 <code>getSnapshotBeforeUpdate</code> 进行替换。</p><p>组件的渲染被分为两个阶段：第一个阶段（也叫做 render 阶段）是可以被 React 打断的，一旦被打断，这阶段所做的所有事情都被废弃，当 React 处理完紧急的事情回来，依然会重新渲染这个组件，这时候第一阶段的工作会重做一遍；第二个阶段叫做 commit 阶段，一旦开始就不能中断，也就是说第二个阶段的工作会稳稳当当地做到这个组件的渲染结束。</p><p>两个阶段的分界点，就是  render  函数。render 函数之前的所有生命周期函数（包括 render)都属于第一阶段，之后的都属于第二阶段。<br>render 之前的生命周期函数（也就是第一阶段生命周期函数）包括这些：</p><blockquote><p>componentWillReceiveProps<br>shouldComponentUpdate<br>componentWillUpdate<br>componentWillMount<br>render</p></blockquote><p>getDerivedStateFromProps 应该是一个纯函数，React 就是通过要求这种纯函数，强制开发者们必须适应异步渲染。</p><h4 id="reconciliation-阶段"><a href="#reconciliation-阶段" class="headerlink" title="reconciliation 阶段"></a>reconciliation 阶段</h4><p>虚拟 dom 的数据对比</p><h4 id="commit-阶段"><a href="#commit-阶段" class="headerlink" title="commit 阶段"></a>commit 阶段</h4><p>将 change list 更新到 dom 上 不适合拆分是因为使用 vdom 的意义就是为了节省耗时的 dom 操作</p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>React16.3 开启异步渲染</p><h4 id="新增的两个"><a href="#新增的两个" class="headerlink" title="新增的两个"></a>新增的两个</h4><ul><li><p>getDerivedStateFromProps<br>触发时间(v16.4 修正)：组件每次被 render 的时候，包括在组件构建之后(虚拟 dom 之后，实际 dom 挂载之前)，每次获取新的 props 或 state 之后。在 v16.3 版本时，组件 state 的更新不会触发该生命周期。<br>每次接收新的 props 之后都会返回一个对象作为新的 state，返回 null 则说明不需要更新 state.<br>配合 componentDidUpdate，可以覆盖 componentWillReceiveProps 的所有用法<br>getDerivedStateFromProps 是一个静态函数，所以函数体内不能访问 this，输出完全由输入决定。</p></li><li><p>getSnapshotBeforeUpdate</p></li></ul><p>触发时间: update 发生的时候，在 render 之后，在组件 dom 渲染之前。<br>返回一个值，作为 componentDidUpdate 的第三个参数。<br>配合 componentDidUpdate, 可以覆盖 componentWillUpdate 的所有用法</p><h4 id="setState可以接受函数为参数吗？有什么作用？"><a href="#setState可以接受函数为参数吗？有什么作用？" class="headerlink" title="setState可以接受函数为参数吗？有什么作用？"></a>setState可以接受函数为参数吗？有什么作用？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(<span class="function">(<span class="params">prevState, props</span>) =&gt;</span> (&#123;</span><br><span class="line">  counter: prevState.counter + props.increment</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><h4 id="关于componentDidCatch的触发时机"><a href="#关于componentDidCatch的触发时机" class="headerlink" title="关于componentDidCatch的触发时机"></a>关于<code>componentDidCatch</code>的触发时机</h4><p>componentDidCatch()<br>componentDidCatch(err, info)<br>任何子组件在渲染期间，生命周期方法中或者构造函数 constructor 发生错误时调用。</p><p>错误边界不会捕获下面的错误：</p><ul><li>事件处理 (Event handlers) （因为事件处理不发生在 React 渲染时，报错不影响渲染）</li><li>异步代码 (Asynchronous code) (e.g. setTimeout or requestAnimationFrame callbacks)</li><li>服务端渲染 (Server side rendering)</li><li>错误边界本身(而不是子组件)抛出的错误</li></ul><h4 id="补充：static-getDerivedStateFromError"><a href="#补充：static-getDerivedStateFromError" class="headerlink" title="补充：static getDerivedStateFromError"></a>补充：<code>static getDerivedStateFromError</code></h4><p>此生命周期会在后代组件抛出错误后被调用。 它将抛出的错误作为参数，并返回一个值以更新 state,可以在此生命周期中 更新 state 使下一次渲染可以显降级 UI。<br>getDerivedStateFromError() 会在渲染阶段调用，因此不允许出现副作用。 如遇此类情况，请改用 componentDidCatch()</p><blockquote><p>note: UNSAFE_componentWillMount() 在挂载之前被调用。它在 render() 之前调用，因此在此方法中同步调用 setState() 不会触发额外渲染。通常，我们建议使用 constructor() 来初始化 state。</p></blockquote><h4 id="react-router-的原理"><a href="#react-router-的原理" class="headerlink" title="react-router 的原理"></a><a href="https://www.cnblogs.com/chenjinxinlove/p/8467744.html" target="_blank" rel="noopener">react-router 的原理</a></h4><h4 id="react-router的实现原理"><a href="#react-router的实现原理" class="headerlink" title="react-router的实现原理"></a><code>react-router</code>的实现原理</h4><ul><li><p>createBrowserHistory: 利用 HTML5 里面的 history</p></li><li><p>createHashHistory: 通过 hash 来存储在不同状态下的 history 信息</p></li><li><p>createMemoryHistory: 在内存中进行历史记录的存储</p></li></ul><h4 id="link组件跟a标签的区别"><a href="#link组件跟a标签的区别" class="headerlink" title="link组件跟a标签的区别"></a>link组件跟a标签的区别</h4><p>有onclick那就执行onclick<br>click的时候阻止a标签默认事件（这样子点击<a href="/abc">123</a>就不会跳转和刷新页面）<br>再取得跳转href（即是to），用history（前端路由两种方式之一，history &amp; hash）跳转，此时只是链接变了，并没有刷新页面</p><h4 id="伪代码实现"><a href="#伪代码实现" class="headerlink" title="伪代码实现"></a>伪代码实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// createBrowserHistory(HTML5)中的前进实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">finishTransition</span>(<span class="params">location</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">const</span> historyState = &#123; key &#125;;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (location.action === <span class="string">'PUSH'</span>) ) &#123;</span><br><span class="line">    <span class="built_in">window</span>.history.pushState(historyState, <span class="literal">null</span>, path);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">window</span>.history.replaceState(historyState, <span class="literal">null</span>, path)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// createHashHistory的内部实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">finishTransition</span>(<span class="params">location</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (location.action === <span class="string">'PUSH'</span>) ) &#123;</span><br><span class="line">    <span class="built_in">window</span>.location.hash = path;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">window</span>.location.replace(</span><br><span class="line">    <span class="built_in">window</span>.location.pathname + <span class="built_in">window</span>.location.search + <span class="string">'#'</span> + path</span><br><span class="line">  );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// createMemoryHistory的内部实现</span></span><br><span class="line">entries = [];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">finishTransition</span>(<span class="params">location</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">switch</span> (location.action) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'PUSH'</span>:</span><br><span class="line">      entries.push(location);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'REPLACE'</span>:</span><br><span class="line">      entries[current] = location;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="vue-相关"><a href="#vue-相关" class="headerlink" title="vue 相关"></a>vue 相关</h2><ul><li>为什么组件的 data 必须是一个函数<br>为了让每一个实例维护一份返回对象的独立的拷贝，这样各个组件的 data 变化的时候互不影响</li></ul><h2 id="node相关"><a href="#node相关" class="headerlink" title="node相关"></a>node相关</h2><ul><li>node文件查找机制<br>总体流程<br><img src="https://img-blog.csdn.net/20140518175333390?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWFha2luZ3dpbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="image"><br>其余的<br><img src="https://img-blog.csdn.net/20140518175420125?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWFha2luZ3dpbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="image"></li></ul><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul><li><a href="https://juejin.im/post/5b0b9b9051882515773ae714" target="_blank" rel="noopener">浅谈 instanceof 和 typeof 的实现原理</a></li><li><a href="https://zhuanlan.zhihu.com/p/32031325" target="_blank" rel="noopener">两个大数求和</a></li><li><a href="https://github.com/sisterAn/blog/issues/26" target="_blank" rel="noopener">深入 setstate 机制</a></li><li><a href="https://segmentfault.com/a/1190000020348448" target="_blank" rel="noopener">大话 react 生命周期 2019：react-v16.3 新生命周期总结</a></li><li><a href="https://blog.csdn.net/tangzhl/article/details/79696055" target="_blank" rel="noopener">react-router 的实现原理</a></li><li><a href="https://juejin.im/post/5af3cc4af265da0ba3521028" target="_blank" rel="noopener">社招中级前端笔试面试题总结</a></li><li><a href="https://www.quora.com/Why-is-Reacts-virtual-DOM-so-much-faster-than-the-real-DOM" target="_blank" rel="noopener">Why is React’s virtual DOM so much faster than the real DOM?</a></li><li><a href="https://github.com/yygmind/blog/issues/43" target="_blank" rel="noopener">前端 100 问：能搞懂80%的请把简历给我</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019年度总结</title>
      <link href="/ashley271017.github.io/2019/12/10/2019%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
      <url>/ashley271017.github.io/2019/12/10/2019%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p><img src="https://www.2008php.com/2014_Website_appreciate/2015-12-16/20151216171611.jpg" alt="img"></p><h2 id="写给自己的准则"><a href="#写给自己的准则" class="headerlink" title="写给自己的准则"></a>写给自己的准则</h2><ul><li><p>不管改动的文件再多，都要一个个检查，看有没有误改的地方，自己的改动有没有影响其他的功能</p></li><li><p>写代码前，请三思，请三思，请三思，不要急于动手</p></li><li><p>不要相信测试，一定要在上线之前用各种设备，各种大小的屏幕，各种浏览器，测试一遍所有相关的功能，所有可能出现的情况</p></li><li><p>一个功能一个分支，时刻保持与线上同步</p></li><li><p>多研究研究各种应用，站在用户的角度去测试而不是自己的角度</p></li><li><p>不明白的，容易记混的知识点要自己归纳总结，多动手，不要今天看几篇文章明天又忘了</p></li><li><p>晚上要睡好，避免第二天打瞌睡</p></li></ul><h2 id="写给2020年的自己"><a href="#写给2020年的自己" class="headerlink" title="写给2020年的自己"></a>写给2020年的自己</h2><p>   多动手写代码，多点工作之外的输出，巩固js基础，希望我能在这条路越走越远吧。。。</p>]]></content>
      
      
      <categories>
          
          <category> 成长 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>webpack常用配置速查</title>
      <link href="/ashley271017.github.io/2019/12/08/webpack%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%E9%80%9F%E6%9F%A5/"/>
      <url>/ashley271017.github.io/2019/12/08/webpack%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%E9%80%9F%E6%9F%A5/</url>
      
        <content type="html"><![CDATA[<h3 id="生产环境常用插件"><a href="#生产环境常用插件" class="headerlink" title="生产环境常用插件"></a>生产环境常用插件</h3><h4 id="imagemin-webpack-plugin-图片压缩插件"><a href="#imagemin-webpack-plugin-图片压缩插件" class="headerlink" title="imagemin-webpack-plugin - 图片压缩插件"></a>imagemin-webpack-plugin - 图片压缩插件</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入插件</span></span><br><span class="line"><span class="keyword">var</span> ImageminPlugin = <span class="built_in">require</span>(<span class="string">'imagemin-webpack-plugin'</span>).default;</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置</span></span><br><span class="line">plugins: [</span><br><span class="line">    <span class="keyword">new</span> ImageminPlugin(&#123;</span><br><span class="line">      disable: process.env.NODE_ENV !== <span class="string">'production'</span>, <span class="comment">// 开发时不启用</span></span><br><span class="line">      pngquant: &#123;<span class="comment">//图片质量</span></span><br><span class="line">        quality: ...</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="mini-css-extract-plugin-依据每个entry生成单个css文件（将css从js中提取出来）"><a href="#mini-css-extract-plugin-依据每个entry生成单个css文件（将css从js中提取出来）" class="headerlink" title="mini-css-extract-plugin - 依据每个entry生成单个css文件（将css从js中提取出来）"></a>mini-css-extract-plugin - 依据每个entry生成单个css文件（将css从js中提取出来）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将style-loader换成mini-css-extract..</span></span><br><span class="line"> use: [</span><br><span class="line">        &#123;</span><br><span class="line">          loader: MiniCssExtractPlugin.loader</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">'css-loader'</span></span><br><span class="line">        ...</span><br><span class="line"> ]</span><br><span class="line"> ...</span><br><span class="line"> <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">        filename: <span class="string">'static/css/[name].[contenthash:8].css'</span>,</span><br><span class="line">        chunkFilename: <span class="string">'static/css/[name].[contenthash:8].chunk.css'</span> <span class="comment">// import() dynamically import</span></span><br><span class="line">      &#125;)</span><br></pre></td></tr></table></figure><h4 id="cleanwebpackplugin"><a href="#cleanwebpackplugin" class="headerlink" title="cleanwebpackplugin"></a>cleanwebpackplugin</h4><p>在webpack中打包的文件通常是通过hash生成的，如果文件改动，那么打包的文件就会越来越多,这个插件用来清除之前的文件</p><h4 id="postcss-loader"><a href="#postcss-loader" class="headerlink" title="postcss-loader"></a>postcss-loader</h4><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p>能够像less一样的自动补全浏览器前缀，需要与<code>autoprefixer</code>一起使用,PostCSS的一大特点是，允许使用最新的CSS特性，在你的CSS里提供统计数据，或者是允许你使用 Sass，Less或是Stylus等CSS预处理器。</p><h5 id="postcss的生态圈提供了上百种插件"><a href="#postcss的生态圈提供了上百种插件" class="headerlink" title="postcss的生态圈提供了上百种插件"></a>postcss的生态圈提供了上百种插件</h5><p>Autoprefixer</p><blockquote><p>根据用户的使用场景来解析CSS和添加vendor prefixes（前文注2）。</p></blockquote><p>PostCSS Focus</p><blockquote><p>一种利用键盘操作为每个:hover添加:focus选择器的PostCSS插件。</p></blockquote><p>PreCSS</p><blockquote><p>一个允许你在代码中使用类似Sass标记的插件。</p></blockquote><p>Stylelint</p><blockquote><p>一种强大的，先进的可以使你在CSS样式中保持一致性，避免错误的CSS linter工具。</p></blockquote><p>PostCSS CSSnext</p><blockquote><p>一种可以让你使用CSS最新特性的插件。它通过将最新的CSS特性转变为现阶段浏览器所兼容的特性，这样你不用再等待浏览器对某一特定新特性的支持。</p></blockquote><p>…</p><h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><p>需要结合<code>postcss.config.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// postcss.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">'precss'</span>),</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line">  test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">&#123;</span><br><span class="line">          loader: <span class="built_in">require</span>.resolve(<span class="string">'postcss-loader'</span>),</span><br><span class="line">          options: &#123;</span><br><span class="line">            ident: <span class="string">'postcss'</span>,</span><br><span class="line">            plugins: <span class="function"><span class="params">()</span> =&gt;</span> [</span><br><span class="line">              <span class="built_in">require</span>(<span class="string">'postcss-flexbugs-fixes'</span>),</span><br><span class="line">              <span class="built_in">require</span>(<span class="string">'postcss-preset-env'</span>)(&#123;</span><br><span class="line">                 autoprefixer: &#123;</span><br><span class="line">                  flexbox: <span class="string">'no-2009'</span></span><br><span class="line">                &#125;,</span><br><span class="line">                stage: <span class="number">3</span></span><br><span class="line">              &#125;)</span><br><span class="line">            ]</span><br></pre></td></tr></table></figure><h4 id="terser-webpack-plugin-js压缩插件"><a href="#terser-webpack-plugin-js压缩插件" class="headerlink" title="terser-webpack-plugin - js压缩插件"></a><a href="https://www.npmjs.com/package/terser-webpack-plugin" target="_blank" rel="noopener">terser-webpack-plugin</a> - js压缩插件</h4><h5 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">optimization: &#123;</span><br><span class="line">  ...</span><br><span class="line">      minimize: <span class="literal">true</span>,</span><br><span class="line">      minimizer: [</span><br><span class="line">      <span class="keyword">new</span> TerserJSPlugin(&#123;</span><br><span class="line">        terserOptions: &#123;</span><br><span class="line">          output: &#123;</span><br><span class="line">            comments: <span class="literal">false</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        extractComments: <span class="literal">false</span></span><br><span class="line">      &#125;),</span><br><span class="line">      <span class="keyword">new</span> OptimizeCSSAssetsPlugin(&#123;&#125;)</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="progress-bar-webpack-plugin"><a href="#progress-bar-webpack-plugin" class="headerlink" title="progress-bar-webpack-plugin"></a>progress-bar-webpack-plugin</h4><h5 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h5><p>显示<code>build</code>进度</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> ProgressBarPlugin()</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="optimize-css-assets-webpack-plugin-css压缩插件"><a href="#optimize-css-assets-webpack-plugin-css压缩插件" class="headerlink" title="optimize-css-assets-webpack-plugin - css压缩插件"></a><a href="https://www.npmjs.com/package/optimize-css-assets-webpack-plugin" target="_blank" rel="noopener">optimize-css-assets-webpack-plugin</a> - css压缩插件</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">plugins:[</span><br><span class="line">  ...</span><br><span class="line">    <span class="keyword">new</span> OptimizeCssAssetsPlugin(&#123;</span><br><span class="line">      assetNameRegExp: <span class="regexp">/\.optimize\.css$/g</span>,</span><br><span class="line">      cssProcessor: <span class="built_in">require</span>(<span class="string">'cssnano'</span>),</span><br><span class="line">      cssProcessorPluginOptions: &#123;</span><br><span class="line">        preset: [<span class="string">'default'</span>, &#123; <span class="attr">discardComments</span>: &#123; <span class="attr">removeAll</span>: <span class="literal">true</span> &#125; &#125;],</span><br><span class="line">      &#125;,</span><br><span class="line">      canPrint: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="webpack-bundle-analyzer"><a href="#webpack-bundle-analyzer" class="headerlink" title="webpack-bundle-analyzer"></a><a href="https://www.npmjs.com/package/webpack-bundle-analyzer" target="_blank" rel="noopener">webpack-bundle-analyzer</a></h4><h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><p>可以看到打包之后各个文件的大小 之后可以做一些优化</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> BundleAnalyzerPlugin = <span class="built_in">require</span>(<span class="string">'webpack-bundle-analyzer'</span>).BundleAnalyzerPlugin;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> BundleAnalyzerPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="开发环境常用插件"><a href="#开发环境常用插件" class="headerlink" title="开发环境常用插件"></a>开发环境常用插件</h3><h4 id="HotModuleReplacementPlugin"><a href="#HotModuleReplacementPlugin" class="headerlink" title="HotModuleReplacementPlugin"></a>HotModuleReplacementPlugin</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plugins:</span><br><span class="line">...</span><br><span class="line"><span class="keyword">new</span> webpack.HotModuleReplacementPlugin()</span><br></pre></td></tr></table></figure><h4 id="friendly-errors-webpack-plugin-友好的webpack错误提示"><a href="#friendly-errors-webpack-plugin-友好的webpack错误提示" class="headerlink" title="friendly-errors-webpack-plugin - 友好的webpack错误提示"></a><a href="https://www.npmjs.com/package/friendly-errors-webpack-plugin" target="_blank" rel="noopener">friendly-errors-webpack-plugin</a> - 友好的webpack错误提示</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> FriendlyErrorsPlugin(&#123;</span><br><span class="line">  compilationSuccessInfo: &#123;</span><br><span class="line">    messages: [<span class="string">'You application is running here http://localhost:3000'</span>],</span><br><span class="line">    notes: [<span class="string">'Some additionnal notes to be displayed unpon successful compilation'</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  onErrors: <span class="function"><span class="keyword">function</span> (<span class="params">severity, errors</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// You can listen to errors transformed and prioritized by the plugin</span></span><br><span class="line">    <span class="comment">// severity can be 'error' or 'warning'</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h3><h4 id="htmlwebpackplugin"><a href="#htmlwebpackplugin" class="headerlink" title="htmlwebpackplugin"></a><a href="https://www.npmjs.com/package/html-webpack-plugin" target="_blank" rel="noopener">htmlwebpackplugin</a></h4><p><a href="https://juejin.im/post/5ce96ad7e51d455a2f2201e1" target="_blank" rel="noopener">https://juejin.im/post/5ce96ad7e51d455a2f2201e1</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">    inject: <span class="literal">true</span>,</span><br><span class="line">    excludeAssets: [...], </span><br><span class="line">    chunks: [page.toLowerCase()].concat(</span><br><span class="line">      isEnvProduction ? [<span class="string">'assets'</span>, <span class="string">'vendors'</span>...] : []</span><br><span class="line">    ),</span><br><span class="line">    templateParameters: ...,</span><br><span class="line">    minify: isEnvProduction &amp;&amp; &#123;</span><br><span class="line">      removeComments: <span class="literal">true</span>,</span><br><span class="line">      collapseWhitespace: <span class="literal">true</span>,</span><br><span class="line">      removeRedundantAttributes: <span class="literal">true</span>,</span><br><span class="line">      useShortDoctype: <span class="literal">true</span>,</span><br><span class="line">      removeEmptyAttributes: <span class="literal">true</span>,</span><br><span class="line">      removeStyleLinkTypeAttributes: <span class="literal">true</span>,</span><br><span class="line">      keepClosingSlash: <span class="literal">true</span>,</span><br><span class="line">      minifyJS: <span class="literal">true</span>,</span><br><span class="line">      minifyCSS: <span class="literal">true</span>,</span><br><span class="line">      minifyURLs: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    filename: ...</span><br><span class="line">    template: ...</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul><li><a href="https://juejin.im/entry/57635cdda341310064c5910a" target="_blank" rel="noopener">关于 PostCSS 普及的一点微小的工作</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端性能优化</title>
      <link href="/ashley271017.github.io/2019/11/07/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
      <url>/ashley271017.github.io/2019/11/07/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h3 id="前端性能优化最佳实践"><a href="#前端性能优化最佳实践" class="headerlink" title="前端性能优化最佳实践"></a><a href="https://csspod.com/frontend-performance-best-practices/" target="_blank" rel="noopener">前端性能优化最佳实践</a></h3><h3 id="针对-spa-的性能优化"><a href="#针对-spa-的性能优化" class="headerlink" title="针对 spa 的性能优化"></a>针对 spa 的性能优化</h3><ul><li>优化首屏渲染</li></ul><p>将所有用于首屏渲染的 css 文件整合成一个内嵌到 head 标签，由于 http 数据包的限制，文件大小不能超过 14kb<br>http/2 能让 css 文件使用单个文件存储，通过服务器推送 css 文件的传输方式减少 html 文件数据量</p><ul><li><p>骨架屏</p></li><li><p>预加载</p></li><li><p>异步路由</p><blockquote><p>路由拆分,减少初始加载体积: 利用异步加载方式，<strong>仅在需要进入对应路由时，对应组件才会被加载进来</strong>。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">route(&#123;</span><br><span class="line">  Home: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'@/coms/home'</span>),</span><br><span class="line">  About: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'@/coms/about'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>服务端渲染（SSR）</p><blockquote><p>简单的来讲，就是浏览器发送请求到服务器端，服务器端处理请求，填充数据，生成 html 返回给浏览器 ,服务端必须是 node.js 或者专门跑个 node.js 来支持<br>优势：更好的 SEO； 首屏性能好，不需要先下载一堆 js 和 css 后才能看到页面<br>劣势：不能实现部分更新。即使只有一部分变动，也需要后端重新返回整个页面给浏览器。</p></blockquote></li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="重绘-回流的概念"><a href="#重绘-回流的概念" class="headerlink" title="重绘 回流的概念"></a>重绘 回流的概念</h4><ul><li>repaint，就是浏览器得知元素产生了不影响排版的情况下后对这个元素进行重新绘制的过程。例如我们改变了元素的颜色，加个下划线等。</li><li>reflow, 浏览器得知元素产生了对文档树排版有影响的样式变化，对所有受影响的dom节点进行重新排版工作<h4 id="减少回流"><a href="#减少回流" class="headerlink" title="* 减少回流"></a>* 减少回流</h4></li></ul><p>回流的发生：<br>1、DOM 树的结构变化，如添加或删除元素。（当新增多个元素的时候使用文档碎片）包括设置 display:none 设置 visibility 只会触发重绘<br>2、元素的几何属性的改变（如 margin、padding、width、height、border 等）。<br>3、页面初始化渲染。<br>4、获取某些属性，浏览器为取得准确的值也会触发回流（offsetTop、clientTop、scrollTop、getComputedSyle()等等）。<br>5、浏览器窗口尺寸的改变</p><p>为什么获取某些属性会触发回流？<br>由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列。但是！当你获取布局信息的操作的时候，会强制队列刷新，比如当你访问以下属性或者使用以下方法：</p><ul><li>offsetTop、offsetLeft、offsetWidth、offsetHeight</li><li>scrollTop、scrollLeft、scrollWidth、scrollHeight</li><li>clientTop、clientLeft、clientWidth、clientHeight</li><li>getComputedStyle()</li><li>getBoundingClientRect</li></ul><p>以上属性和方法都需要返回最新的布局信息，因此浏览器不得不清空队列，触发回流重绘来返回正确的值。</p><h4 id="怎么避免"><a href="#怎么避免" class="headerlink" title="怎么避免"></a>怎么避免</h4><ul><li>对于复杂的动画效果，让其绝对定位</li><li>避免多次访问上述的属性</li><li>使用类名</li><li>使用 csstext</li><li>当添加插入大量的元素的时候 使用文档碎片或者是在父元素在被插入之前设置<code>display:none</code>让其脱离文档流 之后再带回文档流</li><li>硬件加速，使用 css3 硬件加速，可以让 transform、opacity、filters 这些动画不会引起回流重绘 。但是对于动画的其它属性，比如 background-color 这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能</li></ul><blockquote><p>常见的触发硬件加速的 css 属性：transform,opacity,filters,Will-change</p></blockquote><h3 id="使用控制台的performance监测页面的性能（原来的-timeline）"><a href="#使用控制台的performance监测页面的性能（原来的-timeline）" class="headerlink" title="使用控制台的performance监测页面的性能（原来的 timeline）"></a>使用控制台的<a href="https://zhuanlan.zhihu.com/p/29879682" target="_blank" rel="noopener">performance</a>监测页面的性能（原来的 timeline）</h3><p>使用指南：<a href="https://www.cnblogs.com/xiaohuochai/p/9182710.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiaohuochai/p/9182710.html</a></p><h4 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h4><ul><li>复杂的计算使用web workers</li><li>事件委托</li><li>正则表达式不要过于复杂</li></ul><h3 id="使用-webpack-优化"><a href="#使用-webpack-优化" class="headerlink" title="使用 webpack 优化"></a>使用 webpack 优化</h3><ul><li>优化图片 - 使用<code>url-loader</code> 设置<code>limit</code> 大的图转成<code>base64</code></li><li>使用各种插件压缩代码</li><li><a href="https://webpack.docschina.org/guides/tree-shaking/" target="_blank" rel="noopener">tree-shaking</a><br>是什么？<br>用于描述移除 JavaScript 上下文中的未引用代码<br>怎么做？<blockquote><p>使用 ES2015 模块语法（即 import 和 export）。<br>确保没有 compiler 将 ES2015 模块语法转换为 CommonJS 模块（这也是流行的 Babel preset 中 @babel/preset-env 的默认行为 \</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置 Babel 让其保留 ES6 模块化语句 </span></span><br><span class="line"><span class="comment">// babelrc</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"presets"</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">"env"</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"modules"</span>: <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>在项目 package.json 文件中，添加一个 “sideEffects” 属性。比如polyfill等 只要引入 就会产生副作用 当该属性设置为false的时候会删除所有未引用的文件 所以polyfill需要声明sideeffects,true 是默认值，如果不指定其他值的话。这意味着所有的文件都有副作用，也就是没有一个文件可以 tree-shaking。</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 所有文件都有副作用，全都不可 tree-shaking</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"sideEffects"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">// 没有文件有副作用，全都可以 tree-shaking</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"sideEffects"</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">// 只有这些文件有副作用，所有其他文件都可以 tree-shaking，但会保留这些文件</span><br><span class="line">&#123;</span><br><span class="line"> <span class="attr">"sideEffects"</span>: [</span><br><span class="line">  <span class="string">"./src/file1.js"</span>,</span><br><span class="line">  <span class="string">"./src/file2.js"</span></span><br><span class="line"> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>通过将 mode 选项设置为 production，启用 minification(代码压缩) 和 tree shaking。<br>开启 optimization.usedExports,编译时可以分析出解构写法引入的esm模块，哪些export用到了，哪些模块没有用到。然后就需要分别进行标记,标记如下 并使用压缩插件压缩代码 webpack4 mode为production时候默认就有这两个设置</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* harmony export (immutable) */</span> __webpack_exports__[<span class="string">"xxx"</span>] = xxxx;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* unused harmony export xxx */</span> 标记为这个就是需要删掉的</span><br></pre></td></tr></table></figure><p>以上述方式声明sideeffects会出现的问题：以<code>import &#39;xxx.css</code>直接导入到 JavaScript 文件中的样式表都将从输出中删除<br>解决办法是：webpack的配置文件中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line"> rules: [</span><br><span class="line">  &#123;</span><br><span class="line">   test: <span class="regexp">/...css.../</span>,</span><br><span class="line">   use: [loaders],</span><br><span class="line">   sideEffects: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line"> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>引入的时候使用解构赋值</p></blockquote><ul><li>不用的依赖及时删除</li><li>external 把我们的依赖申明为一个外部依赖，外部依赖通过 &lt; script&gt; 外链脚本引入。</li><li>optimization 配置细节<br><a href="https://imweb.io/topic/5b66dd601402769b60847149" target="_blank" rel="noopener">https://imweb.io/topic/5b66dd601402769b60847149</a></li><li>alias 和 noParse<br>当需要将这个外部依赖打包进入到你的 bundle 的时候</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">webpackConfig</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">+ webpackConfig.resolve.alias = &#123;</span><br><span class="line">+   <span class="string">'react'</span>: <span class="string">'react/dist/react.min'</span></span><br><span class="line">+ &#125;</span><br><span class="line">+ webpackConfig.module.noParse.push(</span><br><span class="line">+  <span class="regexp">/react.min/</span></span><br><span class="line">+ )</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> webpackConfig;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="其他-优化SEO"><a href="#其他-优化SEO" class="headerlink" title="其他 - 优化SEO"></a>其他 - 优化SEO</h4><p>重要的内容放在首页 因为爬虫会先从首页开始爬<br>提交sitemap<br>加快页面加载速度 提升搜索引擎排名<br>…</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/52076790" target="_blank" rel="noopener">你真的了解回流和重绘吗</a></li><li><a href="https://juejin.im/entry/585232e21b69e6006c7e33fb" target="_blank" rel="noopener">Webpack 构建性能优化探索</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 性能优化 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>css中宽高的新值复习</title>
      <link href="/ashley271017.github.io/2019/10/17/css%E4%B8%AD%E5%AE%BD%E9%AB%98%E7%9A%84%E6%96%B0%E5%80%BC%E5%A4%8D%E4%B9%A0/"/>
      <url>/ashley271017.github.io/2019/10/17/css%E4%B8%AD%E5%AE%BD%E9%AB%98%E7%9A%84%E6%96%B0%E5%80%BC%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<ul><li><p>fill-available<br>　出现fill-available关键字值的价值在于，可以让元素的100%自动填充特性不仅仅在block水平元素上，也可以应用在其他元素<br>利用它实现等高布局</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.inner</span>&#123;</span></span><br><span class="line"><span class="css">  <span class="selector-tag">width</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line"><span class="css">  <span class="selector-tag">height</span><span class="selector-pseudo">:-webkit-fill-available</span>;</span></span><br><span class="line"><span class="css">  <span class="selector-tag">margin</span><span class="selector-pseudo">:0</span> 10<span class="selector-tag">px</span>;</span></span><br><span class="line">  display: inline-block;</span><br><span class="line">  vertical-align: middle;</span><br><span class="line">  background-color: pink;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"height: 100px;"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"inner"</span>&gt;</span>HTML<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"inner"</span>&gt;</span>CSS<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"inner"</span>&gt;</span>JS<span class="tag">&lt;<span class="name">br</span>&gt;</span>jQyery<span class="tag">&lt;<span class="name">br</span>&gt;</span>Vue<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>max-content<br>fit-content uses max-content, unless available &lt; max-content, then it uses available. Unless available &lt; min-content, then it uses min-content.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.outer</span>&#123;</span></span><br><span class="line"><span class="css">  <span class="selector-tag">width</span><span class="selector-pseudo">:-webkit-max-content</span>;</span></span><br><span class="line"><span class="css">  <span class="selector-tag">border</span><span class="selector-pseudo">:1px</span> <span class="selector-tag">solid</span> <span class="selector-tag">black</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"outer"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"height:10px;width:100px;background:lightgreen"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"background-color: pink;"</span>&gt;</span>测试测试测试测试测试测 hi 是测试测试测试测你测试测试测试测试<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="每日小知识点"><a href="#每日小知识点" class="headerlink" title="每日小知识点"></a>每日小知识点</h3><ul><li>关于下载的文件的后缀<br>你在网上下载一个很大的文件，下载过程中你怎么知道自己下载的对不对呢？所以MD5 就是为了这种情景而生的。即网上的文件除了有资源本身外，还会有一个MD5值，然后你下载到本地后的文件也可以算出一个MD5 值，然后二者对比，如果完全相同则说明下的文件是正确的。</li></ul><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul><li><a href="https://www.jianshu.com/p/9ed3e8759ce3" target="_blank" rel="noopener">浏览器缓存控制详解（cookie、session、localStorage、Cache-Control等</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>控制react的state为合法状态</title>
      <link href="/ashley271017.github.io/2019/10/14/%E6%8E%A7%E5%88%B6react%E7%9A%84state%E4%B8%BA%E5%90%88%E6%B3%95%E7%8A%B6%E6%80%81/"/>
      <url>/ashley271017.github.io/2019/10/14/%E6%8E%A7%E5%88%B6react%E7%9A%84state%E4%B8%BA%E5%90%88%E6%B3%95%E7%8A%B6%E6%80%81/</url>
      
        <content type="html"><![CDATA[<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> zipList = <span class="function"><span class="params">initialArray</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [initialActive, ...restOfTabs] = initialArray</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> zip = &#123;</span><br><span class="line">    previous: [],</span><br><span class="line">    current: initialActive,</span><br><span class="line">    next: restOfTabs,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> setActive = <span class="function"><span class="params">zip</span> =&gt;</span> <span class="function"><span class="params">newActive</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> fill this in</span></span><br><span class="line">    <span class="keyword">const</span> newZip = zip</span><br><span class="line">    <span class="keyword">return</span> apiForZip(newZip)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> apiForZip = <span class="function"><span class="params">zip</span> =&gt;</span> (&#123;</span><br><span class="line">    asArray: <span class="function"><span class="params">()</span> =&gt;</span> [...zip.previous, zip.current, ...zip.next],</span><br><span class="line">    isActive: <span class="function"><span class="params">tab</span> =&gt;</span> zip.current === tab,</span><br><span class="line">    setActive: setActive(zip),</span><br><span class="line">    activeTab: <span class="function"><span class="params">()</span> =&gt;</span> zip.current,</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> apiForZip(zip)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> [tabs, setTabs] = React.useState(</span><br><span class="line">  zipList([</span><br><span class="line">    &#123; <span class="attr">title</span>: <span class="string">'Tab One'</span>, <span class="attr">content</span>: <span class="string">'This is tab one'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">title</span>: <span class="string">'Tab Two'</span>, <span class="attr">content</span>: <span class="string">'This is tab two'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">title</span>: <span class="string">'Tab Three'</span>, <span class="attr">content</span>: <span class="string">'This is tab three'</span> &#125;,</span><br><span class="line">  ])</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="每日小知识点"><a href="#每日小知识点" class="headerlink" title="每日小知识点"></a>每日小知识点</h2><ul><li><p>字体的旋转<br>将字体设置成<code>display:block</code>即可</p></li><li><p>run build文件夹（为了更接近线上的效果）<br>使用<code>http-server</code>工具 执行命令: （原理是puputeer抓取build下的资源 然后。。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http-server build/ project name</span><br></pre></td></tr></table></figure></li><li><p>尽量不要使用<code>push</code>跳转路由 因为这种动态的方式不利于<code>ssr</code></p></li><li><p><code>git config -list</code> 查看当前项目的git配置</p></li><li><p>请求被重定向 （network出现…html…很长的路径 并被canceled） 可能是后端正在部署到新的服务器</p></li></ul><h2 id="每日bug记录"><a href="#每日bug记录" class="headerlink" title="每日bug记录"></a>每日bug记录</h2><ul><li><p>请求返回500 发现是传的参数的格式不对 应该是<code>form</code>表单的形式 而不是<code>application/json</code>格式 虽然API文档中没有标出 但是也要注意</p></li><li><p>发现重新进入页面加载数据的时候没有出现<code>loading</code> 是因为数据存储在mobx中 没有刷新被清除 所以要在每次请求之前清除一次或者是不走mobx流程</p></li><li><p>父层叠上下文中的子层叠上下文 </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="selector-tag">position</span><span class="selector-pseudo">:relative</span> <span class="comment">/* 父 */</span></span><br><span class="line">...</span><br><span class="line"><span class="selector-tag">position</span><span class="selector-pseudo">:absolute</span></span><br><span class="line"><span class="selector-tag">z-index</span><span class="selector-pseudo">:2</span>  <span class="comment">/*子*/</span></span><br><span class="line">...</span><br><span class="line"><span class="selector-tag">position</span><span class="selector-pseudo">:absolute</span></span><br><span class="line"><span class="selector-tag">z-index</span><span class="selector-pseudo">:1</span> <span class="comment">/* 叔叔 */</span></span><br></pre></td></tr></table></figure></li></ul><p>最后还是叔叔显示在子节点的上面 因为子层叠上下文属于父层叠上下文</p><ul><li><p><code>table</code> 设置flex布局 td元素不会自动填充满tbody</p></li><li><p>node <code>exec</code>不执行回调函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> exec = <span class="built_in">require</span>(<span class="string">'child_process'</span>).exec;</span><br><span class="line">exec(<span class="string">"&#123;COMMAND&#125; &gt; results.log"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">error, stdout, stderr</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'callback called!'</span>); <span class="comment">// this never gets called.</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><p>是因为重定向到了另一个文件</p><p>*</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ts小知识点</title>
      <link href="/ashley271017.github.io/2019/10/11/ts%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/ashley271017.github.io/2019/10/11/ts%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<ul><li>用 <code>keyof</code> 来约定方法的参数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> type keys = &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    appId: number;</span><br><span class="line">    config: object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 参数和值约束范围</span></span><br><span class="line">    <span class="keyword">set</span>&lt;T extends keyof keys&gt;(key: T, val: keys[T])</span><br><span class="line">    <span class="keyword">get</span>&lt;T extends keyof keys&gt;(key: T): keys[T]</span><br><span class="line">&#125;</span><br><span class="line">----</span><br></pre></td></tr></table></figure><h2 id="interface-vs-type"><a href="#interface-vs-type" class="headerlink" title="interface vs type"></a>interface vs type</h2><p>我们可以使用 in 来约束属性名必须为三家运营商之一：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">type ChinaMobilePhones = <span class="string">'10086'</span> | <span class="string">'10010'</span> | <span class="string">'10000'</span></span><br><span class="line"></span><br><span class="line">interface ChinaMobile &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    website: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只能 type 使用， interface 无法使用</span></span><br><span class="line">type ChinaMobileList = &#123;</span><br><span class="line">    <span class="comment">// 遍历属性</span></span><br><span class="line">    [phone <span class="keyword">in</span> ChinaMobilePhones]: ChinaMobile</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类型定义文件"><a href="#类型定义文件" class="headerlink" title="类型定义文件"></a>类型定义文件</h2><p>在 TypeScript 中，我们可以很简单的，在代码编写中定义类型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface IBaseModel &#123;</span><br><span class="line">    say(keys: string[] | <span class="literal">null</span>): object</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="title">implements</span> <span class="title">IBaseModel</span> </span>&#123;</span><br><span class="line">    name: string</span><br></pre></td></tr></table></figure><p><code>但是主流的库都是 JavaScript 编写的，TypeScript 身为 JavaScript 的超集，自然需要考虑到如何让 JS 库也能定义静态类型</code>。</p><p>TypeScript 经过了一系列的摸索，先后提出了 tsd(已废弃)、typings(已废弃)，最终在 TypeScript 2.0 的时候重新整理了类型定义，提出了 DefinitelyTyped。</p><p>DefinitelyTyped 就是让你把 “类型定义文件(*.d.ts)”，发布到 npm 中，配合编辑器(或插件)，就能够检测到 JS 库中的静态类型。</p><p>类型定义文件的以 .d.ts 结尾，里面主要用来定义类型。<br>比如：</p><blockquote><p>因为这几个库是 js 的，没有 ts 的类型声明<br>也没有好的@types/对应的库</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">declare <span class="built_in">module</span> <span class="string">'classnames'</span>;</span><br><span class="line">declare <span class="built_in">module</span> <span class="string">'htmr'</span>;</span><br><span class="line">declare <span class="built_in">module</span> <span class="string">'showdown-katex'</span>;</span><br></pre></td></tr></table></figure><blockquote><p>内置类型定义就是把你的类型定义文件和 npm 包一起发布</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pageage.json</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"demo"</span>,</span><br><span class="line">    <span class="string">"author"</span>: <span class="string">"demo project"</span>,</span><br><span class="line">    <span class="string">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">    <span class="string">"main"</span>: <span class="string">"./lib/main.js"</span>,</span><br><span class="line">    <span class="comment">// 定义主类型定义文件</span></span><br><span class="line">    <span class="string">"types"</span>: <span class="string">"./lib/main.d.ts"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>定义数组的类型为第一项是函数 其余的是对象</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Arglist &#123;</span><br><span class="line">  [index: <span class="built_in">number</span>]: object</span><br><span class="line">  <span class="number">0</span>: <span class="built_in">Function</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a1: Arglist = [func]</span><br><span class="line"><span class="keyword">const</span> a2: Arglist = [<span class="number">22</span>] <span class="comment">// fails</span></span><br><span class="line"><span class="keyword">const</span> a3: Arglist = [func, <span class="string">'foo'</span>]</span><br><span class="line"><span class="comment">// 方式二</span></span><br><span class="line"><span class="keyword">type</span> FAs = [<span class="built_in">Function</span>, &#123;&#125;]</span><br></pre></td></tr></table></figure><ul><li>继承的时候排除父接口中的一部分属性</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> Omit&lt;T, K <span class="keyword">extends</span> keyof T&gt; = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> ICollapseProps <span class="keyword">extends</span> Omit&lt;React.HTMLAttributes&lt;HTMLUListElement&gt;,"title"&gt;</span><br></pre></td></tr></table></figure><ul><li><code>react.cloneElement</code>的正确用法</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cloneElement(children  <span class="keyword">as</span> React.ReactElement&lt;<span class="built_in">any</span>&gt;, &#123;</span><br><span class="line">                ref,</span><br><span class="line">                <span class="keyword">type</span>: hasError ? <span class="string">'error'</span> : <span class="string">'default'</span>,</span><br></pre></td></tr></table></figure><ul><li><code>index signature</code> 索引签名<br>适用于无法确定属性名称的场景<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> NetCache &#123;</span><br><span class="line">    [propName: <span class="built_in">string</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>useImmperativeHandle</code> 结合 需要定义静态属性的组件 组件的定义应该如下</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> IMessage <span class="keyword">extends</span> React.ForwardRefExoticComponent&lt;</span><br><span class="line">IMessageProps &amp; React.RefAttributes&lt;HTMLDivElement | refType&gt;</span><br><span class="line">&gt; &#123;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"> <span class="keyword">const</span> ref = createRef&lt;refType &amp; HTMLDivElement&gt;()</span><br><span class="line"> &lt;Message ref=&#123;ref&#125;/&gt;</span><br></pre></td></tr></table></figure></li><li><p>Using a forwardRef component with children in TypeScript</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ButtonProps = React.HTMLProps&lt;HTMLButtonElement&gt; or React.ComponentPropsWithoutRef&lt;<span class="string">'button'</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> FancyButton = React.forwardRef&lt;HTMLButtonElement, ButtonProps&gt;<span class="function">(<span class="params">(<span class="params">props, ref</span>) =&gt; (<span class="params"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">  &lt;button <span class="keyword">type</span>="button" ref=&#123;ref&#125; className="FancyButton"&gt;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">    &#123;props.children&#125;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">  &lt;/button&gt;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params"></span>)</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="params">You</span> <span class="params">can</span> <span class="params">now</span> <span class="params">get</span> <span class="params">a</span> <span class="params">ref</span> <span class="params">directly</span> <span class="params">to</span> <span class="params">the</span> <span class="params">DOM</span> <span class="params">button</span>:</span></span><br><span class="line"><span class="function"><span class="params">const</span> <span class="params">ref</span> = <span class="params">React</span>.<span class="params">createRef</span>&lt;<span class="params">HTMLButtonElement</span>&gt;<span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">&lt;<span class="params">FancyButton</span> <span class="params">ref</span>=&#123;<span class="params">ref</span>&#125;&gt;<span class="params">Click</span> <span class="params">me</span>!&lt;/<span class="params">FancyButton</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>当报错的时候一定要仔细看错误 然后多试一试</p>]]></content>
      
      
      <categories>
          
          <category> ts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ts </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sass中的map和list</title>
      <link href="/ashley271017.github.io/2019/10/11/sass%E4%B8%AD%E7%9A%84map/"/>
      <url>/ashley271017.github.io/2019/10/11/sass%E4%B8%AD%E7%9A%84map/</url>
      
        <content type="html"><![CDATA[<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>类似于 js 中的 map 数据结构</p><h3 id="主要函数"><a href="#主要函数" class="headerlink" title="主要函数"></a>主要函数</h3><table><thead><tr><th>函数</th><th>功能</th><th>示例</th></tr></thead><tbody><tr><td>map-keys(map)</td><td>返回 map 里面所有的 key(list)</td><td>map-keys((“foo”: 1, “bar”: 2)) =&gt; “foo”, “bar”</td></tr><tr><td>map-values(map)</td><td>返回 map 里面所有的 value(list)</td><td>map-values((“foo”: 1, “bar”: 2)) =&gt; 1, 2</td></tr><tr><td>map-get(map,key)</td><td>返回 map 里面指定可以的 value</td><td>map-get((“foo”: 1, “bar”: 2), “foo”) =&gt; 1</td></tr><tr><td>map-has-key(map,key)</td><td>返回 map 里面是否含有指定的 key</td><td>map-has-key((“foo”: 1, “bar”: 2), “foo”) =&gt; true</td></tr><tr><td>map-merge(map1,map2)</td><td>合并 map(map)</td><td>map-merge((“foo”: 1), (“bar”: 2)) =&gt; (“foo”: 1, “bar”: 2)</td></tr><tr><td>map-remove(map,keys)</td><td>删除指定 map 中的指定 key(map)</td><td>map-remove((“foo”: 1, “bar”: 2), “bar”) =&gt; (“foo”: 1)</td></tr><tr><td>keywords(args)</td><td>返回一个函数参数组成的 map(map)</td><td>@mixin foo(args…){@debug keywords($args); //=&gt; (arg1: val, arg2: val)}</td></tr></tbody></table><h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>类似js中的数组</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$list: ( </span><br><span class="line">        ("<span class="selector-tag">item-1</span><span class="selector-class">.1</span>", "<span class="selector-tag">item-1</span><span class="selector-class">.2</span>", "<span class="selector-tag">item-1</span><span class="selector-class">.3</span>"), </span><br><span class="line">        ("<span class="selector-tag">item-2</span><span class="selector-class">.1</span>", "<span class="selector-tag">item-2</span><span class="selector-class">.2</span>", "<span class="selector-tag">item-2</span><span class="selector-class">.3</span>"),</span><br><span class="line">        ("<span class="selector-tag">item-3</span><span class="selector-class">.1</span>", "<span class="selector-tag">item-3</span><span class="selector-class">.2</span>", "<span class="selector-tag">item-3</span><span class="selector-class">.3</span>")</span><br><span class="line">       );</span><br></pre></td></tr></table></figure><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul><li><p>length 检测其长度：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">length($a) =&gt; 1</span><br></pre></td></tr></table></figure></li><li><p>nth 获取第n项：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nth($a,1) =&gt; test</span><br></pre></td></tr></table></figure></li><li><p>index($list,$value)：返回$value在$list中的位置</p></li><li><p>append($list,$value[,$separator])：使用$separator分隔符将$value列表项添加到$list最后（如果没有显式指定 $separator分隔符，会以当前分隔符分隔）</p></li><li><p>join($list-1,$list-2[,$separator]):使用$separator分隔符将$list-2附加到$list-1（如果没有显式指定分隔符，将对* $list-1中的分隔符）</p></li><li><p>zip($lists):将多个$list组合在一起成为一个多维列表。如果列表源长度并不是所有都相同，结果列表长度将以最短的一个为准</p></li><li><p>reject($list,$value)：这是Compass中的一个函数，将$value值从$list中删除</p></li><li><p>compact(*$args)：Compass函数，返回一个删除非真值的新列表</p></li></ul><h3 id="list应用"><a href="#list应用" class="headerlink" title="list应用"></a>list应用</h3><ul><li>扩展选择器 如:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.home .nav-home,</span><br><span class="line">.about .nav-about,</span><br><span class="line">.products .nav-products,</span><br><span class="line">.contact .nav-contact</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$pages: home,about,products,contact;</span><br><span class="line">$selector:();</span><br><span class="line">@<span class="keyword">each</span> $item in $pages &#123;</span><br><span class="line">    //我们创建$selector</span><br><span class="line">&#125;</span><br><span class="line">#&#123;$selector&#125;&#123;</span><br><span class="line">    //样式写在这里</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>自定义函数<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//定义first()函数，获取列表中的第一个列表项</span><br><span class="line">@<span class="keyword">function</span> first($list)&#123;</span><br><span class="line">    @<span class="keyword">return</span> nth($list,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//定义last()函数，获取列表中的最后一个列表项</span><br><span class="line">@<span class="keyword">function</span> last($list)&#123;</span><br><span class="line">    @<span class="keyword">return</span> nth($list,length($list));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="每日小知识点"><a href="#每日小知识点" class="headerlink" title="每日小知识点"></a>每日小知识点</h2><ul><li>unquote 用来去除字符串中的引号</li><li>quote 给字符串增加引号</li><li>传递内容块到 mixin: <code>@content</code></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">mixin</span> apply-to-ie6-only &#123;</span><br><span class="line">  * <span class="selector-tag">html</span> &#123;</span><br><span class="line">    @content;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">include</span> apply-to-ie6-only &#123;</span><br><span class="line">  <span class="selector-id">#logo</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(/logo.gif);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>target 伪类可以在不新增类名的时候直接实现标签页的效果<br>原理： 也就是给一个元素 A 设定 id，另一个元素 B 指定跳转到这个 id，然后就向 a:hover 那样，在 css 中设定 “元素：target”并改变样式，那么点击 B 元素，就会根据你的设定改变 A 的样式。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"swiper-box"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"swiper-cont"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"swiper1"</span> <span class="attr">id</span>=<span class="string">"swiper1"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"swiper2"</span> <span class="attr">id</span>=<span class="string">"swiper2"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"swiper3"</span> <span class="attr">id</span>=<span class="string">"swiper3"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"swiper-num"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#swiper1"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#swiper2"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#swiper3"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>focus:within 伪类 应用于当子元素中出现获得焦点的元素时候</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:focus</span><span class="selector-pseudo">:within</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>css 伪类与伪元素<br>css 伪类<br>css 伪类用于向某些选择器添加特殊的效果。<br>:link, :visited, :hover, :focus, :active, :first-child, :lang<br>css3 新增的伪类：<br>:last-child, :only-child, :first-of-type, :last-of-type, :only-of-type, :nth-child(n), :nth-last-child(n), :nth-of-type(n), :nth-last-of-type(n), :root, :empty, :target, :enabled, :disabled, :checked, :not(selector),</li></ul><p>css 伪元素<br>css 伪元素用于向某些选择器设置特殊效果。<br>::first-letter, ::first-line, ::before, ::after<br>css3 新增的伪元素<br>::selection</p><ul><li>通过 <code>first-letter text-transform: uppercase text-transform: lowercase</code>控制大小写</li></ul><h2 id="每日-bug-记录"><a href="#每日-bug-记录" class="headerlink" title="每日 bug 记录"></a>每日 bug 记录</h2><ul><li><p>max-height 设置 transition 的时候不生效 是因为 max-height 设置了一个很大的范围 比如从 0 到 1000 而实际的内容高度只有 100 那么剩下的时间大都是在滚动这 900</p></li><li><p>使用 js 设置元素的行内样式可以应用样式表中的 transition</p></li><li><p>git 冲突的理解<br>只有当同时修改了某个文件的时候才会出现冲突 要是本地的状态是 nothing commit git pull 的时候会直接覆盖掉本地的文件</p></li><li><p>git merge 的理解<br>从父分支切出子分支 子分支 pull 父分支 子分支上的代码会与父分支保持一致 但是父分支 merge 子分支 父分支的内容不一定要与子分支保持一致</p></li><li><p>在一个hooks里面维护一份state 然后在另一个组件中setState 一个组件中获取state 两个组件的state并不会同步</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> sass </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sass css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019春招回顾</title>
      <link href="/ashley271017.github.io/2019/08/14/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%9B%9E%E9%A1%BE%E6%98%A5%E6%8B%9B/"/>
      <url>/ashley271017.github.io/2019/08/14/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%9B%9E%E9%A1%BE%E6%98%A5%E6%8B%9B/</url>
      
        <content type="html"><![CDATA[<h3 id="使用-Linux-命令模拟发起一个请求"><a href="#使用-Linux-命令模拟发起一个请求" class="headerlink" title="使用 Linux 命令模拟发起一个请求"></a>使用 Linux 命令模拟发起一个请求</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">一、<span class="keyword">get</span>请求：</span><br><span class="line"></span><br><span class="line">　　1、使用curl命令：</span><br><span class="line">// 在终端敲下该命令之后回车会出现响应内容</span><br><span class="line"></span><br><span class="line">　　curl “http://www.baidu.com” 如果这里的URL指向的是一个文件或者一幅图都可以直接下载到本地</span><br><span class="line"></span><br><span class="line">　　curl -i “http://www.baidu.com” 显示全部信息</span><br><span class="line"></span><br><span class="line">　　curl -l “http://www.baidu.com” 只显示头部信息</span><br><span class="line"></span><br><span class="line">　　curl -v “http://www.baidu.com” 显示<span class="keyword">get</span>请求全过程解析</span><br><span class="line"></span><br><span class="line">　　2、使用wget命令：</span><br><span class="line"></span><br><span class="line">　　wget “http://www.baidu.com”也可以</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">二、post请求</span><br><span class="line"></span><br><span class="line">　　1、使用curl命令（通过-d参数，把访问参数放在里面）：</span><br><span class="line"></span><br><span class="line">　　curl -d “param1=value1¶m2=value2” “http://www.baidu.com”</span><br><span class="line"></span><br><span class="line">　　2、使用wget命令：（--post-data参数来实现）</span><br><span class="line"></span><br><span class="line">　　wget --post-data ‘user=foo&amp;password=bar’ http://www.baidu.com</span><br><span class="line"></span><br><span class="line">　　以上就是Linux模拟Http的<span class="keyword">get</span>或post请求的方法了，这样一来Linux系统也能向远程服务器发送消息了。</span><br><span class="line"></span><br><span class="line">## 防抖节流</span><br><span class="line"># Throttle and debounce</span><br><span class="line"></span><br><span class="line">## Throttle （函数节流）</span><br><span class="line"></span><br><span class="line">### Throttle 定义</span><br><span class="line"></span><br><span class="line">就是指连续触发事件后在 n 秒内函数只能执行一次</span><br><span class="line"></span><br><span class="line">如果将水龙头拧紧直到水是以水滴的形式流出，那你会发现每隔一段时间，就会有一滴水流出。</span><br><span class="line"></span><br><span class="line">也就是会说预先设定一个执行周期，当调用动作的时刻大于等于执行周期则执行该动作，然后进入下一个新周期</span><br><span class="line"></span><br><span class="line">```js</span><br><span class="line">/**</span><br><span class="line"> * 频率控制 返回函数连续调用时，action 执行频率限定为 次 / delay</span><br><span class="line"> * @param delay  &#123;number&#125;    延迟时间，单位毫秒</span><br><span class="line"> * @param action &#123;<span class="function"><span class="keyword">function</span>&#125;  请求关联函数，实际应用需要调用的函数</span></span><br><span class="line"><span class="function"> * @<span class="title">return</span> </span>&#123;<span class="function"><span class="keyword">function</span>&#125;    返回客户调用函数</span></span><br><span class="line"><span class="function"> */</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">var</span> <span class="title">throttle</span> = <span class="title">function</span>(<span class="params">delay, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> last = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> curr = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="keyword">if</span> (curr - last &gt; delay) &#123;</span><br><span class="line">      action.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">      last = curr;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>版本二：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fun, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> last, deferTimer;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> that = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">let</span> _args = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="keyword">let</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="keyword">if</span> (last &amp;&amp; now &lt; last + delay) &#123;</span><br><span class="line">      clearTimeout(deferTimer);</span><br><span class="line">      <span class="comment">// 保证一定会执行一次 这就是跟防抖不一样的地方</span></span><br><span class="line">      deferTimer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        last = now;</span><br><span class="line">        fun.apply(that, _args);</span><br><span class="line">      &#125;, delay);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 第一次或者当时间间隔达到要求的时候会执行函数</span></span><br><span class="line">      last = now;</span><br><span class="line">      fun.apply(that, _args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如搜索框 当用户输入频繁的时候</p><h2 id="Debounce-函数去抖"><a href="#Debounce-函数去抖" class="headerlink" title="Debounce (函数去抖)"></a>Debounce (函数去抖)</h2><h3 id="Debounce-定义"><a href="#Debounce-定义" class="headerlink" title="Debounce 定义"></a>Debounce 定义</h3><p>就是指触发事件后在 n 秒内函数只能执行一次（最后一次），如果在 n 秒内又触发了事件，则会重新计算函数执行时间。</p><p>如果用手指一直按住一个弹簧，它将不会弹起直到你松手为止。</p><p>也就是说当调用动作 n 毫秒后，才会执行该动作，若在这 n 毫秒内又调用此动作则将重新计算执行时间</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 空闲控制 返回函数连续调用时，空闲时间必须大于或等于 idle，action 才会执行</span></span><br><span class="line"><span class="comment"> * @param idle   &#123;number&#125;    空闲时间，单位毫秒</span></span><br><span class="line"><span class="comment"> * @param action &#123;function&#125;  请求关联函数，实际应用需要调用的函数</span></span><br><span class="line"><span class="comment"> * @return &#123;function&#125;    返回客户调用函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> debounce = <span class="function"><span class="keyword">function</span>(<span class="params">idle, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> last;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ctx = <span class="keyword">this</span>,</span><br><span class="line">      args = <span class="built_in">arguments</span>;</span><br><span class="line">    clearTimeout(last);</span><br><span class="line">    last = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      action.apply(ctx, args);</span><br><span class="line">    &#125;, idle);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul><li>debounce<br>search 搜索联想，用户在不断输入值时，用防抖来节约请求资源。<br>window 触发 resize 的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次</li><li>throttle<br>鼠标不断点击触发，mousedown(单位时间内只触发一次)<br>监听滚动事件，比如是否滑到底部自动加载更多，用 throttle 来判断</li></ul><h2 id="vue-的路由如何实现，最后提到了服务器端渲染，解释其过程"><a href="#vue-的路由如何实现，最后提到了服务器端渲染，解释其过程" class="headerlink" title="vue 的路由如何实现，最后提到了服务器端渲染，解释其过程"></a>vue 的路由如何实现，最后提到了服务器端渲染，解释其过程</h2><blockquote><p>前端路由实现的就是匹配不同的 url 路径，进行解析，然后动态的渲染出区域 html 内容</p><ol><li>hash 模式。hash 值变化，浏览器不发出请求，但是会触发 hashchange 这个事件， 通过这个事件我们就可以知道 hash 值发生了哪些变化，来更新页面内容</li></ol></blockquote>   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">matchAndUpdate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// todo 匹配 hash 做 dom 更新操作</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"hashchange"</span>, matchAndUpdate);</span><br></pre></td></tr></table></figure><blockquote><ol start="2"><li>history 模式. pushState 和 replaceState 分别可以添加和修改历史记录条目,通过这两个 API 可以改变 url 地址且不会发送请求,当用户刷新页面之类的操作时，浏览器还是会给服务器发送请求。为了避免出现这种情况，所以这个实现需要服务器的支持，需要把所有路由都重定向到根页面。当处于激活状态的历史记录条目发生变化时,popstate 事件就会在对应 window 对象上触发</li></ol></blockquote><h2 id="animation-transition的区别"><a href="#animation-transition的区别" class="headerlink" title="animation transition的区别"></a>animation transition的区别</h2><ul><li>transition 动画可以通过事件监听启动和完成<code>transitionstart</code>、<code>transitionrun</code>、<code>transitionend</code>,transition 动画有几个局限：<ol><li>需要通过用户的行为（如点击，悬浮等）触发，所以没法在网页加载时自动发生</li><li>是一次性的，不能重复发生</li><li>只能定义开始状态和结束状态，不能定义中间状态，也就是说只有两个状态。<ul><li>keyframes: 关键帧 keyframe 自定义动画,能够自定义任意阶段的动画动作。</li></ul></li><li>animation 在不需要触发事件的情况下，也可以随时间变化来改变元素 CSS 属性。</li><li>可以指定动画具体播放的次数</li><li>可以指定各个阶段的状态，而不是只有开始和结尾。</li></ol></li></ul><h2 id="介绍-requestAnimateFrame，与-setInterval-或-setTimeout-的区别"><a href="#介绍-requestAnimateFrame，与-setInterval-或-setTimeout-的区别" class="headerlink" title="介绍 requestAnimateFrame，与 setInterval 或 setTimeout 的区别"></a>介绍 requestAnimateFrame，与 setInterval 或 setTimeout 的区别</h2><ol><li><p><code>setTimeout</code>: seTimeout 实现的动画容易出现卡顿、抖动的现象，有两个原因可能会导致丢帧：</p><ul><li>setTimeout 的执行时间并不是确定的, setTimeout 任务被放进了异步队列中，只有当主线程上的任务执行完以后，才会去检查该队列里的任务是否需要开始执行，所以 setTimeout 的实际执行时机一般要比其设定的时间晚一些。</li><li>刷新频率受 屏幕分辨率 和 屏幕尺寸 的影响，不同设备的屏幕绘制频率可能会不同，而 setTimeout 只能设置一个固定的时间间隔，这个时间不一定和屏幕的刷新时间相同。</li></ul></li><li><p><code>requestAnimateFrame</code>：请求浏览器在下一次重绘之前调用指定的函数来更新动画,回调的次数通常是每秒 60 次,返回一个 long 整数，请求 ID，可以传这个值给 window.cancelAnimationFrame() 以取消回调函数. 最大的优势是<strong>rAF 的执行步伐跟着浏览器的绘制频率走，这样就不会引起丢帧现象，也不会导致动画出现卡顿的问题。</strong></p></li></ol><h2 id="js-为什么要单线程的"><a href="#js-为什么要单线程的" class="headerlink" title="js 为什么要单线程的"></a>js 为什么要单线程的</h2><blockquote><p>在多线程操作的情况下可以实现应用的并行处理，而提高整个应用程序的性能和吞吐量，更大粒度的榨取本机的 CPU 利用率，特别是现代很多语言都支持了多核并行处理技术。JavaScript 是单线程执行，因为如果 JavaScript 是多线程的方式来操作 UI，则可能出现 UI 操作的冲突, 如果引入一些锁的机制来解决这些冲突，则容易引入更大的复杂性，所以 JavaScript 从开始就选择了单线程执行。</p></blockquote><h2 id="同步与非同步-阻塞非阻塞-并发并行的区别"><a href="#同步与非同步-阻塞非阻塞-并发并行的区别" class="headerlink" title="## 同步与非同步 阻塞非阻塞 并发并行的区别"></a>## 同步与非同步 阻塞非阻塞 并发并行的区别</h2><p>用普通的水壶烧，人在边上看着，水开了再去看球。（同步，阻塞）这个是常规做法，但是我看球不爽了。<br>用普通水壶烧，人去看球，隔几分钟去厨房看看。（同步，非阻塞）这个又大问题，万一在我离开的几分钟水开了，我就麻烦了。<br>用会叫的水壶，人在边上看着。（异步，阻塞）这个没有问题，但是我太傻了。<br>用会叫的水壶，人去看球，听见水壶叫了再去看。（异步，非阻塞）这个应该是最好的。<br>等着看球的我：阻塞</p><p>看着电视的我：非阻塞</p><p>普通水壶：同步</p><p>会叫的水壶：异步 (内核会通知)</p><ul><li>同步过程中进程触发 IO 操作并等待或者轮询的去查看 IO 操作是否完成。异步过程中进程触发 IO 操作以后，直接返回，做自己的事情，IO 交给内核来处理，完成后内核通知进程 IO 完成。</li></ul><ul><li>阻塞</li></ul><p>阻塞的概念往往伴随着线程。阻塞一般是指：在调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会被唤醒执行后续的操作。</p><ul><li>非阻塞</li></ul><p>那么非阻塞，毫无疑问是阻塞的反向操作。非阻塞式的调用指：在结果没有返回之前，该调用不会阻塞住当前线程。</p><ul><li><p>并发：当有多个线程在操作时，如果系统只有一个 CPU，操作系统只能把 CPU 运行时间划分成若干个时间段,再将时间段分配给各个线程执行，在一个时间段的快速的切换不同的线程代码运行。</p></li><li><p>并行：当系统有多个 CPU 时，可以存在当一个 CPU 执行一个线程时，另一个 CPU 可以执行另一个线程，两个线程互不抢占 CPU 资源，可以同时进行。</p></li></ul><h3 id="nodejs-中的阻塞非阻塞"><a href="#nodejs-中的阻塞非阻塞" class="headerlink" title="nodejs 中的阻塞非阻塞"></a>nodejs 中的阻塞非阻塞</h3><p>阻塞，读取文件同步 I/O 操作，等待文件读取完再进行其他操作。</p><p>非阻塞，读取文件是异步回调，在等待文件读取时可以进行其他操作，这就大大提高了 Node.js 的性能，可以处理大量的并发请求。</p><h2 id="react-的-filber-（16-3之后开启异步渲染"><a href="#react-的-filber-（16-3之后开启异步渲染" class="headerlink" title="react 的 filber （16.3之后开启异步渲染)"></a>react 的 filber （16.3之后开启异步渲染)</h2><blockquote><p>在 fiber 中，更新是分阶段的，具体分为两个阶段，首先是 reconciliation 的阶段，这个阶段在计算前后 dom 树的差异，然后是 commit 的阶段，这个阶段将把更新渲染到页面上。第一个阶段是可以打断的，因为这个阶段耗时可能会很长，因此需要暂停下来去执行其他更高优先级的任务，第二个阶段则不会被打断，会一口气把更新渲染到页面上。</p></blockquote><p>由于 reconciliation 的阶段会被打断，可能会导致 commit 前的这些生命周期函数多次执行。react 官方目前已经把 componentWillMount、componentWillReceiveProps 和 componetWillUpdate 标记为 unsafe，并使用新的生命周期函数 getDerivedStateFromProps 和 getSnapshotBeforeUpdate 进行替换。</p><p>组件的渲染被分为两个阶段：第一个阶段（也叫做 render 阶段）是可以被 React 打断的，一旦被打断，这阶段所做的所有事情都被废弃，当 React 处理完紧急的事情回来，依然会重新渲染这个组件，这时候第一阶段的工作会重做一遍；第二个阶段叫做 commit 阶段，一旦开始就不能中断，也就是说第二个阶段的工作会稳稳当当地做到这个组件的渲染结束。</p><p>两个阶段的分界点，就是  render  函数。render 函数之前的所有生命周期函数（包括 render)都属于第一阶段，之后的都属于第二阶段。<br>render 之前的生命周期函数（也就是第一阶段生命周期函数）包括这些：</p><ul><li>componentWillReceiveProps</li><li>shouldComponentUpdate</li><li>componentWillUpdate</li><li>componentWillMount</li><li>render</li></ul><p>getDerivedStateFromProps 应该是一个纯函数，React 就是通过要求这种纯函数，强制开发者们必须适应异步渲染。</p><h2 id="reconciliation-阶段"><a href="#reconciliation-阶段" class="headerlink" title="reconciliation 阶段"></a>reconciliation 阶段</h2><p>虚拟 dom 的数据对比</p><h2 id="commit-阶段"><a href="#commit-阶段" class="headerlink" title="commit 阶段"></a>commit 阶段</h2><p>将 change list 更新到 dom 上 不适合拆分是因为使用 vdom 的意义就是为了节省耗时的 dom 操作</p><h2 id="linux常见命令"><a href="#linux常见命令" class="headerlink" title="linux常见命令"></a>linux常见命令</h2><ul><li><p>创建符号链接（类似windows的快捷方式)</p><blockquote><p>ln -s source_file symbolic_link</p></blockquote></li><li><p>打开文件跳到第一个匹配的行</p><blockquote><p>$ vim +/search-term filename.txt</p></blockquote></li><li><p>grep相关</p></li></ul><p>1.在文件中查找字符串不区分大小写</p><blockquote><p>$ grep -i “the” demo_file<br>2.在一个文件夹中递归查询包含指定字符串的文件<br>$ grep -r “ramesh” *</p></blockquote><ul><li><p>查找指定文件名的文件(不区分大小写)</p><blockquote><p>find -iname ‘..’</p></blockquote></li><li><p>登录到远程主机</p><blockquote><p>$ ssh -l jsmith remotehost.example.com</p></blockquote></li><li><p>ps</p></li></ul><p>1.查看当前正在运行的所有进程</p><blockquote><p>$ ps -ef | more<br>2.以树状结构显示当前正在运行的进程，H选项表示显示进程的层次结构<br>$ ps -efH | more</p><ul><li>显示当前系统中占用资源最多的一些进程<br>top</li></ul></blockquote><ul><li><p>查看所有网络接口及其状态</p><blockquote><p>$ ifconfig -a</p></blockquote></li><li><p>使用up和down命令启动或停止某个接口</p><blockquote><p>$ ifconfig eth0 up</p></blockquote></li></ul><blockquote><p>$ ifconfig eth0 down</p></blockquote><ul><li><p>查找某个命令的位置</p><blockquote><p>$ whereis cmd</p></blockquote></li><li><p>不加载整个文件的前提下显示文件内容 (查看大型日志文件的时候)</p><blockquote><p>$ less</p></blockquote></li><li><p>设置环境变量</p><blockquote><p>$ export …</p></blockquote></li><li><p>cat追加a内容到文件b的末尾</p><blockquote><p>$ cat a &gt; b</p></blockquote></li><li><p>cat覆盖原有文件的内容</p><blockquote><p>$ cat a &gt;&gt; b</p></blockquote></li><li><p>curl命令相关</p></li></ul><p>1.模仿浏览器</p><blockquote><p>$ curl -A “Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.0)” <a href="http://www.linux.com" target="_blank" rel="noopener">http://www.linux.com</a><br>2.伪造referer（盗链）<br>$ curl -e “<a href="http://www.linux.com&quot;" target="_blank" rel="noopener">www.linux.com&quot;</a> <a href="http://mail.linux.com" target="_blank" rel="noopener">http://mail.linux.com</a><br>3.利用curl下载文件<br>使用内置option：-o(小写)<br>$ curl -o dodo1.jpg http:<a href="http://www.linux.com/dodo1.JPG" target="_blank" rel="noopener">www.linux.com/dodo1.JPG</a><br>4.使用curl发送POST请求<br>$ curl -d “user=admin&amp;passwd=12345678” <a href="http://127.0.0.1:8080/login" target="_blank" rel="noopener">http://127.0.0.1:8080/login</a></p></blockquote><h3 id="前端模块化"><a href="#前端模块化" class="headerlink" title="前端模块化"></a>前端模块化</h3><p>CommonJs用在服务器端，AMD和CMD用在浏览器环境<br>AMD:提前执行（异步加载：依赖先执行）+延迟执行<br>CMD:延迟执行（运行到需加载，根据顺序执行）</p><h2 id="移动端相关"><a href="#移动端相关" class="headerlink" title="移动端相关"></a>移动端相关</h2><h3 id="移动端点击-300ms-延迟是什么？怎样消除？"><a href="#移动端点击-300ms-延迟是什么？怎样消除？" class="headerlink" title="移动端点击 300ms 延迟是什么？怎样消除？"></a>移动端点击 300ms 延迟是什么？怎样消除？</h3><p>为了双击缩放，页面点击会有 300ms 延迟<br>解决方法，禁用缩放，更改默认的视口宽度<br>&lt;meta name=”viewport” content=”user-scalable=no, initial-scale=1,maximum-scale=1, width=device-width”&gt;</p>]]></content>
      
      
      
        <tags>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端文件上传</title>
      <link href="/ashley271017.github.io/2019/06/14/%E5%89%8D%E7%AB%AF%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
      <url>/ashley271017.github.io/2019/06/14/%E5%89%8D%E7%AB%AF%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="上传文件的几种方式"><a href="#上传文件的几种方式" class="headerlink" title="上传文件的几种方式"></a>上传文件的几种方式</h2><ul><li><p>普通表单上传<br>使用 PHP 来展示常规的表单上传是一个不错的选择。首先构建文件上传的表单，并指定表单的提交内容类型为 enctype=”multipart/form-data”，表明表单需要上传二进制数据。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/index.php"</span> <span class="attr">method</span>=<span class="string">"POST"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"myfile"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>文件编码上传<br>第一个思路是将文件进行编码，然后在服务端进行解码，之前写过一篇在前端实现图片压缩上传的博客，其主要实现原理就是将图片转换成 base64 进行传递<br>var imgURL = URL.createObjectURL(file);<br>ctx.drawImage(imgURL, 0, 0);<br>// 获取图片的编码，然后将图片当做是一个很长的字符串进行传递<br>var data = canvas.toDataURL(“image/jpeg”, 0.5);</p></li></ul><p>除了进行 base64 编码，还可以在前端直接读取文件内容后以二进制格式上传</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取二进制文件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readBinary</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(text.length)</span><br><span class="line">  <span class="keyword">var</span> ui8a = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(data, <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; text.length; i++) &#123;</span><br><span class="line">    ui8a[i] = text.charCodeAt(i) &amp; <span class="number">0xff</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(ui8a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> reader = <span class="keyword">new</span> FileReader()</span><br><span class="line">reader.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  readBinary(<span class="keyword">this</span>.result) <span class="comment">// 读取result或直接上传</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把从input里读取的文件内容，放到fileReader的result字段里</span></span><br><span class="line">reader.readAsBinaryString(file)</span><br></pre></td></tr></table></figure><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uploadAndSubmit</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> form = <span class="built_in">document</span>.forms[<span class="string">"demoForm"</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (form[<span class="string">"file"</span>].files.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 寻找表单域中的 &lt;input type="file" ... /&gt; 标签</span></span><br><span class="line"><span class="keyword">var</span> file = form[<span class="string">"file"</span>].files[<span class="number">0</span>];</span><br><span class="line"><span class="comment">// try sending</span></span><br><span class="line"><span class="keyword">var</span> reader = <span class="keyword">new</span> FileReader();</span><br><span class="line"></span><br><span class="line">reader.onloadstart = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// 这个事件在读取开始时触发</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"onloadstart"</span>);</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"bytesTotal"</span>).textContent = file.size;</span><br><span class="line">&#125;</span><br><span class="line">reader.onprogress = <span class="function"><span class="keyword">function</span>(<span class="params">p</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 这个事件在读取进行中定时触发</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"onprogress"</span>);</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"bytesRead"</span>).textContent = p.loaded;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reader.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 这个事件在读取成功结束后触发</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"load complete"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reader.onloadend = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 这个事件在读取结束后，无论成功或者失败都会触发</span></span><br><span class="line"><span class="keyword">if</span> (reader.error) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(reader.error);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"bytesRead"</span>).textContent = file.size;</span><br><span class="line"><span class="comment">// 构造 XMLHttpRequest 对象，发送文件 Binary 数据</span></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="comment">/* method */</span> <span class="string">"POST"</span>,</span><br><span class="line"><span class="comment">/* target url */</span> <span class="string">"upload.jsp?fileName="</span> + file.name</span><br><span class="line"><span class="comment">/*, async, default to true */</span>);</span><br><span class="line"><span class="comment">// 二进制流</span></span><br><span class="line"><span class="comment">// 指定一个MIME类型用于替代服务器指定的类型，使服务端响应信息中传输的数据按照该指定MIME类型处理</span></span><br><span class="line">xhr.overrideMimeType(<span class="string">"application/octet-stream"</span>);</span><br><span class="line">xhr.sendAsBinary(reader.result);</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (xhr.readyState == <span class="number">4</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (xhr.status == <span class="number">200</span>) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"upload complete"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"response: "</span> + xhr.responseText);</span><br></pre></td></tr></table></figure><ul><li>formData 异步上传<br>FormData 对象主要用来组装一组用 XMLHttpRequest 发送请求的键/值对，可以更加灵活地发送 Ajax 请求。可以使用 FormData 来模拟表单提交。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> files = e.target.files <span class="comment">// 获取 input 的 file 对象</span></span><br><span class="line"><span class="keyword">let</span> formData = <span class="keyword">new</span> FormData()</span><br><span class="line">formData.append(<span class="string">'file'</span>, file)</span><br><span class="line">axios.post(url, formData)</span><br></pre></td></tr></table></figure><h2 id="大文件上传"><a href="#大文件上传" class="headerlink" title="大文件上传"></a>大文件上传</h2><p>大文件上传最主要的问题就在于：在同一个请求中，要上传大量的数据，导致整个过程会比较漫长，且失败后需要重头开始上传。试想，如果我们将这个请求拆分成多个请求，每个请求的时间就会缩短，且如果某个请求失败，只需要重新发送这一次请求即可，无需从头开始，这样是否可以解决大文件上传的问题呢？</p><ul><li>文件切片<br>参考： 大文件切割上传<br>编码方式上传中，在前端我们只要先获取文件的二进制内容，然后对其内容进行拆分，最后将每个切片上传到服务端即可。<br>在 JavaScript 中，文件 FIle 对象是 Blob 对象的子类，Blob 对象包含一个重要的方法 slice，通过这个方法，我们就可以对二进制文件进行拆分。<br>下面是一个拆分文件的示例</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">slice</span>(<span class="params">file, piece = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">5</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> totalSize = file.size; <span class="comment">// 文件总大小</span></span><br><span class="line">  <span class="keyword">let</span> start = <span class="number">0</span>; <span class="comment">// 每次上传的开始字节</span></span><br><span class="line">  <span class="keyword">let</span> end = start + piece; <span class="comment">// 每次上传的结尾字节</span></span><br><span class="line">  <span class="keyword">let</span> chunks = []</span><br><span class="line">  <span class="keyword">while</span> (start &lt; totalSize) &#123;</span><br><span class="line">    <span class="comment">// 根据长度截取每次需要上传的数据</span></span><br><span class="line">    <span class="comment">// File对象继承自Blob对象，因此包含slice方法</span></span><br><span class="line">    <span class="keyword">let</span> blob = file.slice(start, end);</span><br><span class="line">    chunks.push(blob)</span><br><span class="line"></span><br><span class="line">    start = end;</span><br><span class="line">    end = start + piece;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> chunks</span><br><span class="line">&#125;</span><br><span class="line">将文件拆分成piece大小的分块，然后每次请求只需要上传这一个部分的分块即可</span><br><span class="line"><span class="keyword">let</span> file =  <span class="built_in">document</span>.querySelector(<span class="string">"[name=file]"</span>).files[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> LENGTH = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">0.1</span>;</span><br><span class="line"><span class="keyword">let</span> chunks = slice(file, LENGTH); <span class="comment">// 首先拆分切片</span></span><br><span class="line"></span><br><span class="line">chunks.forEach(<span class="function"><span class="params">chunk</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> fd = <span class="keyword">new</span> FormData();</span><br><span class="line">  fd.append(<span class="string">"file"</span>, chunk);</span><br><span class="line">  post(<span class="string">'/mkblk.php'</span>, fd)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>断点续传<br>即使将大文件拆分成切片上传，我们仍需等待所有切片上传完毕，在等待过程中，可能发生一系列导致部分切片上传失败的情形，如网络故障、页面关闭等。由于切片未全部上传，因此无法通知服务端合成文件。这种情况下可以通过断点续传来进行处理。<br>断点续传指的是：可以从已经上传部分开始继续上传未完成的部分，而没有必要从头开始上传，节省上传时间。<br>由于整个上传过程是按切片维度进行的，且 mkfile 接口是在所有切片上传完成后由客户端主动调用的，因此断点续传的实现也十分简单：</li></ul><p>在切片上传成功后，保存已上传的切片信息<br>当下次传输相同文件时，遍历切片列表，只选择未上传的切片进行上传<br>所有切片上传完毕后，再调用 mkfile 接口通知服务端进行文件合并</p><p>因此问题就落在了如何保存已上传切片的信息了，保存一般有两种策略</p><p>可以通过 locaStorage 等方式保存在前端浏览器中，这种方式不依赖于服务端，实现起来也比较方便，缺点在于如果用户清除了本地文件，会导致上传记录丢失<br>服务端本身知道哪些切片已经上传，因此可以由服务端额外提供一个根据文件 context 查询已上传切片的接口，在上传文件前调用该文件的历史上传记录<br>下面让我们通过在本地保存已上传切片记录，来实现断点上传的功能</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 获取已上传切片记录</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUploadSliceRecord</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> record = localStorage.getItem(context)</span><br><span class="line">  <span class="keyword">if</span>(!record)&#123;</span><br><span class="line">    <span class="keyword">return</span> []</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(record)</span><br><span class="line">    &#125;<span class="keyword">catch</span>(e)&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 保存已上传切片</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">saveUploadSliceRecord</span>(<span class="params">context, sliceIndex</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> list = getUploadSliceRecord(context)</span><br><span class="line">  list.push(sliceIndex)</span><br><span class="line">  localStorage.setItem(context, <span class="built_in">JSON</span>.stringify(list))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 然后对上传逻辑稍作修改，主要是增加上传前检测是已经上传、上传后保存记录的逻辑</span></span><br><span class="line"><span class="keyword">let</span> context = createContext(file);</span><br><span class="line"><span class="comment">// 获取上传记录</span></span><br><span class="line"><span class="keyword">let</span> record = getUploadSliceRecord(context);</span><br><span class="line"><span class="keyword">let</span> tasks = [];</span><br><span class="line">chunks.forEach(<span class="function">(<span class="params">chunk, index</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 已上传的切片则不再重新上传</span></span><br><span class="line">  <span class="keyword">if</span>(record.includes(index))&#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> fd = <span class="keyword">new</span> FormData();</span><br><span class="line">  fd.append(<span class="string">"file"</span>, chunk);</span><br><span class="line">  fd.append(<span class="string">"context"</span>, context);</span><br><span class="line">  fd.append(<span class="string">"chunk"</span>, index + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> task = post(<span class="string">"/mkblk.php"</span>, fd).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 上传成功后保存已上传切片记录</span></span><br><span class="line">    saveUploadSliceRecord(context, index)</span><br><span class="line">    record.push(index)</span><br><span class="line">  &#125;)</span><br><span class="line">  tasks.push(task);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>此时上传时刷新页面或者关闭浏览器，再次上传相同文件时，之前已经上传成功的切片就不会再重新上传了。<br>服务端实现断点续传的逻辑基本相似，只要在 getUploadSliceRecord 内部调用服务端的查询接口获取已上传切片的记录即可，因此这里不再展开。<br>此外断点续传还需要考虑切片过期的情况：如果调用了 mkfile 接口，则磁盘上的切片内容就可以清除掉了，如果客户端一直不调用 mkfile 的接口，放任这些切片一直保存在磁盘显然是不可靠的，一般情况下，切片上传都有一段时间的有效期，超过该有效期，就会被清除掉。基于上述原因，断点续传也必须同步切片过期的实现逻辑。</p><h3 id="上传进度和暂停"><a href="#上传进度和暂停" class="headerlink" title="上传进度和暂停"></a>上传进度和暂停</h3><p>通过 xhr.upload 中的 progress 方法可以实现监控每一个切片上传进度。<br>上传暂停的实现也比较简单，通过 xhr.abort 可以取消当前未完成上传切片的上传，实现上传暂停的效果，恢复上传就跟断点续传类似，先获取已上传的切片列表，然后重新发送未上传的切片。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">xhr.upload.onprogress = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (event.lengthComputable) &#123;</span><br><span class="line">    <span class="keyword">var</span> percentComplete = (event.loaded / event.total) * <span class="number">100</span></span><br><span class="line">    <span class="comment">// 对进度进行处理</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中事件的 lengthComputable 属性代表文件总大小是否可知。如果 lengthComputable 属性的值是 false，那么意味着总字节数是未知并且 total 的值为零。</p><p>如果是现代浏览器，可以直接配合 HTML5 提供的</p><progress id="myProgress" value="50" max="100"></progress><h3 id="图片预览"><a href="#图片预览" class="headerlink" title="图片预览"></a>图片预览</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleImageFile</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> previewArea = <span class="built_in">document</span>.getElementById(<span class="string">'previewArea'</span>)</span><br><span class="line">  <span class="keyword">var</span> img = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>)</span><br><span class="line">  <span class="keyword">var</span> fileInput = <span class="built_in">document</span>.getElementById(<span class="string">'myFile'</span>)</span><br><span class="line">  <span class="keyword">var</span> file = fileInput.files[<span class="number">0</span>]</span><br><span class="line">  img.file = file</span><br><span class="line">  previewArea.appendChild(img)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> reader = <span class="keyword">new</span> FileReader()</span><br><span class="line">  reader.onload = (<span class="function"><span class="keyword">function</span>(<span class="params">aImg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">      aImg.src = e.target.result</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)(img)</span><br><span class="line">  reader.readAsDataURL(file)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们使用 FileReader 来处理图片的异步加载。在创建新的 FileReader 对象之后，我们建立了 onload 函数，然后调用 readAsDataURL()开始在后台进行读取操作。当图像文件加载后，转换成一个 data: URL，并传递到 onload 回调函数中设置给 img 的 src。<br>该函数可以帮助实现预览以及压缩图片的功能</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">另外我们还可以通过使用对象URL来实现预览</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> img = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>)</span><br><span class="line">img.src = <span class="built_in">window</span>.URL.createObjectURL(file)</span><br><span class="line">img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 明确地通过调用释放</span></span><br><span class="line">  <span class="built_in">window</span>.URL.revokeObjectURL(<span class="keyword">this</span>.src)</span><br><span class="line">&#125;</span><br><span class="line">previewArea.appendChild(img)</span><br></pre></td></tr></table></figure><h3 id="多文件支持"><a href="#多文件支持" class="headerlink" title="多文件支持"></a>多文件支持</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=<span class="string">"myFile"</span> type=<span class="string">"file"</span> multiple&gt;</span><br><span class="line"><span class="comment">// 我们就能在打开的文件选择对话框中选中多个文件了。然后你在代码里拿到的FileUpload对象的files属性就是一个选中的多文件的数组了。</span></span><br><span class="line"><span class="keyword">var</span> fileInput = <span class="built_in">document</span>.getElementById(<span class="string">"myFile"</span>);</span><br><span class="line"><span class="keyword">var</span> files = fileInput.files;</span><br><span class="line"><span class="keyword">var</span> formData = <span class="keyword">new</span> FormData();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; files.length; i++) &#123;</span><br><span class="line"><span class="keyword">var</span> file = files[i];</span><br><span class="line">formData.append(<span class="string">'files[]'</span>, file, file.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FormData的append方法提供第三个可选参数用于指定文件名，这样就可以使用同一个表单项名，然后用文件名区分上传的多个文件。这样也方便前后台的循环操作。</p><h3 id="图片压缩"><a href="#图片压缩" class="headerlink" title="图片压缩"></a>图片压缩</h3><p>使用filereader读取到图片之后使用canvas压缩图片的尺寸</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">compress (data, callback) &#123;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 压缩图片</span></span><br><span class="line"><span class="comment">        * @param data file文件 数据会一直向下传递</span></span><br><span class="line"><span class="comment">        * @param callback 下一步回调</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">const</span> &#123;compressionRatio&#125; = <span class="keyword">this</span>.props;</span><br><span class="line">       <span class="keyword">const</span> imgFile = data.file;</span><br><span class="line">       <span class="keyword">const</span> img = <span class="keyword">new</span> <span class="built_in">window</span>.Image();</span><br><span class="line"></span><br><span class="line">       img.src = data.dataUrl;</span><br><span class="line"></span><br><span class="line">       img.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">           <span class="keyword">const</span> canvas = <span class="built_in">document</span>.createElement(<span class="string">'canvas'</span>);</span><br><span class="line">           <span class="keyword">const</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line"></span><br><span class="line">           canvas.width = img.width;</span><br><span class="line">           canvas.height = img.height;</span><br><span class="line"></span><br><span class="line">           ctx.drawImage(img, <span class="number">0</span>, <span class="number">0</span>, canvas.width, canvas.height);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">let</span> compressedDataUrl;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span>(data.compress)&#123;</span><br><span class="line">               compressedDataUrl = canvas.toDataURL(imgFile.type, (compressionRatio / <span class="number">100</span>));</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               compressedDataUrl = canvas.toDataURL(imgFile.type, <span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           data.compressedDataUrl = compressedDataUrl;</span><br><span class="line"></span><br><span class="line">           callback(data);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="结合-xhr-的-progress-事件实现上传进度条"><a href="#结合-xhr-的-progress-事件实现上传进度条" class="headerlink" title="结合 xhr 的 progress 事件实现上传进度条"></a>结合 xhr 的 progress 事件实现上传进度条</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">uploadImg (data, formData) &#123;</span><br><span class="line">        <span class="comment">// 开始发送请求上传</span></span><br><span class="line">        <span class="keyword">const</span> _this = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">        <span class="keyword">const</span> &#123;uploadUrl&#125; = <span class="keyword">this</span>.props;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进度监听</span></span><br><span class="line">        xhr.upload.addEventListener(<span class="string">'progress'</span>, _this.handleProgress.bind(_this, data.uuid), <span class="literal">false</span>);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">        xhr.open(<span class="string">'POST'</span>, uploadUrl , <span class="literal">true</span>);</span><br><span class="line">        xhr.send(formData);</span><br><span class="line">    &#125;</span><br><span class="line"> handleProgress (id, e) &#123;</span><br><span class="line">        <span class="comment">// 监听上传进度 操作DOM 显示进度</span></span><br><span class="line">        <span class="keyword">const</span> number = <span class="built_in">Number</span>.parseInt((e.loaded / e.total) * <span class="number">100</span>) + <span class="string">"%"</span>;</span><br><span class="line">        <span class="keyword">const</span> text = <span class="built_in">document</span>.querySelector(<span class="string">'#text-'</span>+id);</span><br><span class="line">        <span class="keyword">const</span> progress = <span class="built_in">document</span>.querySelector(<span class="string">'#progress-'</span>+id);</span><br><span class="line"></span><br><span class="line">        text.innerHTML = number;</span><br><span class="line">        progress.style.width = number;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="上传多个文件"><a href="#上传多个文件" class="headerlink" title="上传多个文件"></a>上传多个文件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">*uploadGenerator (uploadQueue) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 多张图片并发上传控制规则</span></span><br><span class="line"><span class="comment">         * 上传1-max数量的图片</span></span><br><span class="line"><span class="comment">         * 设置一个最大上传数量</span></span><br><span class="line"><span class="comment">         * 保证最大只有这个数量的上传请求</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最多只有三个请求在上传</span></span><br><span class="line">        <span class="keyword">const</span> maxUploadSize = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(uploadQueue.length &gt; maxUploadSize)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> result = [];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; uploadQueue.length; i++)&#123;</span><br><span class="line">                <span class="comment">// 第一次return maxUploadSize数量的图片</span></span><br><span class="line">                <span class="keyword">if</span>(i &lt; maxUploadSize)&#123;</span><br><span class="line">                    result.push(uploadQueue[i]);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(i === maxUploadSize - <span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="keyword">yield</span> result;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">yield</span> [uploadQueue[i]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">yield</span> uploadQueue.map(<span class="function">(<span class="params">item</span>)=&gt;</span>(item));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="comment">// 通过该函数获取每次要上传的数组</span></span><br><span class="line">        <span class="keyword">this</span>.uploadGen = <span class="keyword">this</span>.uploadGenerator(uploadQueue);</span><br><span class="line">        <span class="comment">// 第一次要上传的数量</span></span><br><span class="line">        <span class="keyword">const</span> firstUpload = <span class="keyword">this</span>.uploadGen.next();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 真正开始上传流程</span></span><br><span class="line">        firstUpload.value.map(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 图片上传分成5步</span></span><br><span class="line"><span class="comment">             * 图片转dataUrl</span></span><br><span class="line"><span class="comment">             * 压缩</span></span><br><span class="line"><span class="comment">             * 处理数据格式</span></span><br><span class="line"><span class="comment">             * 准备数据上传</span></span><br><span class="line"><span class="comment">             * 上传</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * 前两步是回调的形式 后面是同步的形式</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">this</span>.transformFileToDataUrl(item, <span class="keyword">this</span>.compress, <span class="keyword">this</span>.processData);</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="comment">// 上传下一个 function uploadImg</span></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (xhr.status === <span class="number">200</span> || xhr.status === <span class="number">201</span>) &#123;</span><br><span class="line">                    <span class="comment">// 上传成功</span></span><br><span class="line">                    _this.handleUploadEnd(data, <span class="number">2</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 上传失败</span></span><br><span class="line">                    _this.handleUploadEnd(data, <span class="number">3</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"><span class="comment">// function handleuploadend</span></span><br><span class="line"> <span class="keyword">const</span> nextUpload = <span class="keyword">this</span>.uploadGen.next();</span><br><span class="line">        <span class="keyword">if</span>(!nextUpload.done)&#123;</span><br><span class="line">            nextUpload.value.map(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">                _this.transformFileToDataUrl(item, _this.compress, _this.processData);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="移动端上传文件的兼容性问题"><a href="#移动端上传文件的兼容性问题" class="headerlink" title="移动端上传文件的兼容性问题"></a>移动端上传文件的兼容性问题</h3><p>部分安卓微信浏览器无法触发 onchange 事件（第一步就特么遇到问题）<br>这其实安卓微信的一个遗留问题。 查看讨论 解决办法也很简单：input 标签 &lt;input type=“file” name=”image” accept=”image/gif, image/jpeg, image/png”&gt;要写成<input type="file" name="image" accept="“image/*”">就没问题了。<br>部分安卓微信不支持 Blob 对象<br>部分 Blob 对象 append 进 FormData 中出现问题<br>iOS 8 不支持 new File Constructor，但是支持 input 里的 file 对象。<br>iOS 上经过压缩后的图片可以上传成功 但是 size 是 0 无法打开。<br>部分手机出现图片上传转换问题，请移步。<br>安卓手机不支持多选，原因在于 multiple 属性根本就不支持。<br>多张图片转 base64 时候卡顿，因为调用了 cpu 进行了计算。<br>上传图片可以使用 base64 上传或者 formData 上传</p><ul><li>解决对策<br><img src="https://image-static.segmentfault.com/620/361/62036185-595a6630913f2_articlex" alt="img"></li></ul><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul><li><a href="https://segmentfault.com/a/1190000010034177" target="_blank" rel="noopener">移动端 H5 实现图片上传</a></li></ul><h3 id="每日小知识点"><a href="#每日小知识点" class="headerlink" title="每日小知识点"></a>每日小知识点</h3><ul><li>选取第一个到倒数第二个元素<blockquote><p>aaa.slice(0,-1)</p></blockquote></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 基础技能 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
