{"meta":{"title":"Ashley's blog","subtitle":null,"description":null,"author":"Ashley","url":"https://ashleyblog.xyz","root":"/ashley271017.github.io/"},"pages":[{"title":"","date":"2023-04-02T14:00:30.300Z","updated":"2023-04-02T14:00:30.300Z","comments":true,"path":"404.html","permalink":"https://ashleyblog.xyz/404.html","excerpt":"","text":"404 Not Found | Material X function setLoadingBarProgress(num) { document.getElementById('loading-bar').style.width=num+\"%\"; } Ashley's blog &nbsp;博文 &nbsp;收藏 &nbsp;关于 Material X &nbsp;示例 &nbsp;分类 &nbsp;标签 &nbsp;近期文章 &nbsp;我的友链 setLoadingBarProgress(40); 404 Not Found **很抱歉，您访问的页面不存在** 可能是输入地址有误或该地址已被删除 &nbsp;Comments &nbsp;&nbsp;站内导航 近期文章 我的友链 &nbsp;&nbsp;Hot Tags BOM css css hooks es6 eslint - eslint git git sass hooks,react-router js技巧 node进程 node进程通信 模块化 动态引入 pm2 react hooks react-router react-router useeffect react-transition-group react状态管理 sass css scss ts webpack 前端工具 基础技能 效率提升配置 模块化 正则表达式 移动端适配 面经 项目搭建 Ashley © 2018-2019 鄂ICP备17030443号 本站使用 Material X 作为主题 , 总访问量为 次 . setLoadingBarProgress(80); setLoadingBarProgress(60); var GOOGLE_CUSTOM_SEARCH_API_KEY = \"\"; var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = \"\"; var ALGOLIA_API_KEY = \"\"; var ALGOLIA_APP_ID = \"\"; var ALGOLIA_INDEX_NAME = \"\"; var AZURE_SERVICE_NAME = \"\"; var AZURE_INDEX_NAME = \"\"; var AZURE_QUERY_KEY = \"\"; var BAIDU_API_ID = \"\"; var SEARCH_SERVICE = \"hexo\" || \"hexo\"; var ROOT = \"/\"||\"/\"; if(!ROOT.endsWith('/'))ROOT += '/'; $(function() { const $reveal = $('.reveal'); if ($reveal.length === 0) return; const sr = ScrollReveal({ distance: 0 }); sr.reveal('.reveal'); }); $(function() { Waves.attach('.flat-btn', ['waves-button']); Waves.attach('.float-btn', ['waves-button', 'waves-float']); Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']); Waves.attach('.flat-box', ['waves-block']); Waves.attach('.float-box', ['waves-block', 'waves-float']); Waves.attach('.waves-image'); Waves.init(); }); $(function(){ if ('.cover') { $('.cover').backstretch( [\"/images/banner.jpg\"], { duration: \"6000\", fade: \"2500\" }); } else { $.backstretch( [\"/images/banner.jpg\"], { duration: \"6000\", fade: \"2500\" }); } }); var GUEST_INFO = ['nick','mail','link']; var guest_info = 'nick,mail,link'.split(',').filter(function(item){ return GUEST_INFO.indexOf(item) > -1 }); var notify = 'true' == true; var verify = 'true' == true; var valine = new Valine(); valine.init({ el: '#valine_container', notify: notify, verify: verify, guest_info: guest_info, path: \"/404.html\", appId: \"vu5VJ9hGtTUPkCsBP1ItVzg9-gzGzoHsz\", appKey: \"HfSu2jw0KjCyYYMydHTCArO2\", placeholder: \"请留言告诉我您要访问哪个页面找不到了\", pageSize:'10', avatar:'mp', lang:'zh-cn', highlight:'true' }) let COPY_SUCCESS = \"Copied\"; let COPY_FAILURE = \"Copy failed\"; /*页面载入完成后，创建复制按钮*/ !function (e, t, a) { /* code */ var initCopyCode = function(){ var copyHtml = ''; copyHtml += ''; copyHtml += ' Copy'; copyHtml += ''; $(\".highlight .code pre\").before(copyHtml); var clipboard = new ClipboardJS('.btn-copy', { target: function(trigger) { return trigger.nextElementSibling; } }); clipboard.on('success', function(e) { //您可以加入成功提示 console.info('Action:', e.action); console.info('Text:', e.text); console.info('Trigger:', e.trigger); success_prompt(COPY_SUCCESS); e.clearSelection(); }); clipboard.on('error', function(e) { //您可以加入失败提示 console.error('Action:', e.action); console.error('Trigger:', e.trigger); fail_prompt(COPY_FAILURE); }); } initCopyCode(); }(window, document); /** * 弹出式提示框，默认1.5秒自动消失 * @param message 提示信息 * @param style 提示样式，有alert-success、alert-danger、alert-warning、alert-info * @param time 消失时间 */ var prompt = function (message, style, time) { style = (style === undefined) ? 'alert-success' : style; time = (time === undefined) ? 1500 : time*1000; $('') .appendTo('body') .addClass('alert ' + style) .html(message) .show() .delay(time) .fadeOut(); }; // 成功提示 var success_prompt = function(message, time) { prompt(message, 'alert-success', time); }; // 失败提示 var fail_prompt = function(message, time) { prompt(message, 'alert-danger', time); }; // 提醒 var warning_prompt = function(message, time) { prompt(message, 'alert-warning', time); }; // 信息提示 var info_prompt = function(message, time) { prompt(message, 'alert-info', time); }; let LAZY_LOAD_IMAGE = \"\"; $(\".article-entry\").find(\"fancybox\").find(\"img\").each(function () { var element = document.createElement(\"a\"); $(element).attr(\"data-fancybox\", \"gallery\"); $(element).attr(\"href\", $(this).attr(\"src\")); /* 图片采用懒加载处理时, * 一般图片标签内会有个属性名来存放图片的真实地址，比如 data-original, * 那么此处将原本的属性名src替换为对应属性名data-original, * 修改如下 */ if (LAZY_LOAD_IMAGE) { $(element).attr(\"href\", $(this).attr(\"data-original\")); } $(this).wrap(element); }); setLoadingBarProgress(100); if ('serviceWorker' in navigator) { navigator.serviceWorker.register('/sw.js?t=1680508050137') .then(function () {console.log('ServiceWorker Register Successfully.')}) .catch(function (e) {console.error(e)}); }"},{"title":"","date":"2023-04-02T14:00:30.303Z","updated":"2023-04-02T14:00:30.303Z","comments":true,"path":"manifest.json","permalink":"https://ashleyblog.xyz/manifest.json","excerpt":"","text":"{\"name\":\"Ashley's Blog\",\"short_name\":\"blog\",\"theme_color\":\"#2196f3\",\"background_color\":\"#2196f3\",\"display\":\"fullscreen\",\"orientation\":\"portrait\",\"Scope\":\"/\",\"start_url\":\"/\",\"icons\":[{\"src\":\"images/icons/icon-72x72.png\",\"sizes\":\"72x72\",\"type\":\"image/png\"}],\"splash_pages\":null}"},{"title":"","date":"2023-04-02T14:00:30.286Z","updated":"2023-04-02T14:00:30.285Z","comments":true,"path":"archive/index.html","permalink":"https://ashleyblog.xyz/archive/index.html","excerpt":"","text":""},{"title":"404 Not Found","date":"2023-04-02T14:00:30.305Z","updated":"2023-04-02T14:00:30.305Z","comments":true,"path":"404/index.html","permalink":"https://ashleyblog.xyz/404/index.html","excerpt":"","text":"404 Not Found **很抱歉，您访问的页面不存在** 可能是输入地址有误或该地址已被删除"},{"title":"关于","date":"2023-04-02T14:00:30.301Z","updated":"2023-04-02T14:00:30.301Z","comments":true,"path":"about/index.html","permalink":"https://ashleyblog.xyz/about/index.html","excerpt":"","text":"关于本站 主要用于记录日常开发中的收获与学到的新技能～～之前是与朋友一起维护一个叫做frontnote的github仓库 但是发现记的太乱冲突太多了。。 已升级https,支持PWA~ 下一步:接入百度统计 优化seo… Day Day up~"},{"title":"collect","date":"2019-09-01T06:48:25.000Z","updated":"2023-04-02T14:00:30.285Z","comments":true,"path":"collect/index.html","permalink":"https://ashleyblog.xyz/collect/index.html","excerpt":"","text":"node 从零开发一个node命令行工具 node进程 你可能想知道的 Node 子进程模块 你应该知道的Node.js子进程 Node.js 子进程：你需要知道的一切 Node JS后端项目开发与生产环境总结 node流 Node.js 流: 你需要知道的一切 webpack webpack 4 Code Splitting 的 splitChunks 配置探索 - 腾讯Web前端 IMWeb 团队社区 | blog | 团队博客 webpack多入口文件 要点 glob.sync docker 命令说明 · Docker —— 从入门到实践 flutter (1) Flutter 状态管理之 Scoped Model &amp; Redux - 掘金 Flutter · 语雀 面试必备计算机基础 http2 pwa service worker介绍 生成manifest.json service worker生命周期 service worker离线缓存 常见问题 跨域问题 SEO 作为前端，你不得不知道的搜索引擎优化 前端性能监控 前端错误监控与收集探究 如何分析网页性能瓶颈"},{"title":"我的朋友们","date":"2023-04-02T14:00:30.304Z","updated":"2023-04-02T14:00:30.304Z","comments":true,"path":"friends/index.html","permalink":"https://ashleyblog.xyz/friends/index.html","excerpt":"","text":""},{"title":"","date":"2023-04-02T14:00:30.303Z","updated":"2023-04-02T14:00:30.303Z","comments":true,"path":"private/index.html","permalink":"https://ashleyblog.xyz/private/index.html","excerpt":"","text":"前端配置本地代理方法总结 https://juejin.im/post/5c0a6be4f265da616f6fc79c123456789101112131415161718192021devServer: &#123; proxy: &#123; '/api': &#123; // 需要直接代理到线上环境的接口 target: 'http://ad.server.com', changeOrigin: true, headers: &#123; // 后端要校验请求源，那改下 host 或者 origin 不就美滋滋了？ Host: 'ad.server.com', Origin: 'ad.server.com' &#125;, &#125;, '/apitest': &#123; // 需要与后端联调的接口 target: '10.8.0.1:9909',// 后端本地开发环境 &#125;, '/iframe': &#123; target: 'http://localhost:8085', &#125; // 另外还有 iframe 里的 api 调用指向线上环境 &#125; &#125; 然而，后端接口残酷地给跳转到登陆接口去了 😭。猜想一下可能后端的接口是通过 cookie 来判断当前登陆域的，从 localhost 过去的请求不带 cookie。后来尝试发现在 proxy的headers里再增加 cookie 即可破跳转，但是请求过去返回结果还是在报错，后端表示仍然是认证失败 作者：表示很不蛋定链接：https://juejin.im/post/5c0a6be4f265da616f6fc79c来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 解读 Redux 中间件的原理 https://juejin.im/post/59dc7e43f265da4332268906"},{"title":"所有分类","date":"2023-04-02T14:00:30.302Z","updated":"2023-04-02T14:00:30.302Z","comments":true,"path":"blog/category/index.html","permalink":"https://ashleyblog.xyz/blog/category/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2023-04-02T14:00:30.302Z","updated":"2023-04-02T14:00:30.302Z","comments":true,"path":"blog/tags/index.html","permalink":"https://ashleyblog.xyz/blog/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"算法填坑","slug":"算法填坑","date":"2020-01-06T14:06:55.000Z","updated":"2023-04-02T14:00:30.296Z","comments":true,"path":"2020/01/06/算法填坑/","link":"","permalink":"https://ashleyblog.xyz/2020/01/06/算法填坑/","excerpt":"","text":"贪心法方法是从某一起点开始，在每一个解决问题步骤中使用贪心原则，即采取在当前状态下最有利或者是最优化的选择，贪心法常用于找出图的最小生成树，最短路径，哈夫曼编码等等应用：在一定的时间之内上完尽量多的课程策略：每次选择最早结束的课程 123456789101112131415161718192021# 首先将已选课程的列表初始化为空，然后执行贪心算法def executeSchedule(courses,selectionRule): selectedCourses = [] while len(courses) &gt; 0: selCourse = earliestFinishTime(courses) selectedCourses.append(selCourse) courses = removeConflictingCourses(selCourse,courses) return selectedCoursesdef earliestFinishTime(courses): earliestFinishTime = courses[0] for i in courses: if i[1] &lt; earliestFinishTime[1]: earliestFinishTime = i return earliestFinishTime# 排除已选课程中与当前选中的课程冲突的课程def removeConflictingCourses(selCourse,courses): noConflictingCourses = [] for s in courses: if s[1] &lt;= selCourse[0] or s[0] &gt;= selCourse[1]: noConflictingCourses.append(s) return noConflictingCourses 动态规划法也是将一个问题拆解成若干个子问题，但是跟分治法不一样的是它会将每一个子问题的答案存储起来，以供下次求解的时候使用，这样能够减少计算的时间 回溯一种可以找出所有解或者是一部分解的算法，一旦发现不正常的数据就不再继续，而是会回到上一层 递归分治应用：一堆真币中有一个是假的，假币的重于真的，找出假币 123456789101112131415161718192021222324252627282930313233coinslist=[1,1,4,1,1,1]def coinComparison(coinslist): counter=0 currlist=coinslist while len(currlist) &gt; 1: group1,group2,group3 = splitCoins(currlist) currlist = findFakeGroup(group1,group2,group3) counter+=1 fake=currlist[0]def findFakeGroup(group1,group2,group3): resultland2 = compare(group1,group2) if resultland2 == 'left': fakeGroup = group1 elif resultland2 == 'right' fakeGroup = group2 elif resultland2 == 'equal' fakeGroup = group3 return fakeGroupdef compare(groupA,groupB): if sum(groupA)&gt;sum(groupB): result = 'left' elif sum(groupB)&gt;sum(groupA): result = 'right' else: result = 'equal' return resultdef splitCoins(coinslist): length = len(coinslist) group1=coinslist[0:length//3] group2=coinslist[length//3:length//3*2] group3=coinslist[length//3*2:length] return group1,group2,group3 记忆递归应用：有以下的硬币，需要选择部分硬币使得他们的和最大化，并且不能选择相邻的硬币1 3 2 44 5 1234567891011121314151617def coins(row,memo): if len(row) == 0: memo[0] = 0 return 0,memo elif len(row) == 1: memo[1] = row[0] return row[0],memo try: retukrn (memo[len(row)],memo) except KeyError: # 对应选中第一枚硬币 pick = coins(row[2:],memo)[0]+row[0]) # 对应跳过第一枚硬币 skip = coins(row[1:],memo)[0] result = max(pick,skip) memo[len(row)] = result return (result,memo) 图的广度优先搜索应用：六度分隔，每个人与其他任何人都只需要经过六步以内的介绍，分隔度指的是每一个人之间的最大分隔度 12345678910111213141516171819202122232425262728small = &#123; &apos;A&apos;:[&apos;B&apos;,&apos;C&apos;], &apos;B&apos;:[&apos;A&apos;,&apos;C&apos;]&#125;def degreesOfSeparation(graph,start): if start not in graph: return -1 visited = set() frontier = set() degrees=0 visited.add(start) frontier.add(start) while len(frontier) &gt; 0: print(frontier,&apos;:&apos;,degrees) degrees += 1 newfront = set() for g in frontier: for next in graph[g]: if next not in visited: visited.add(next) newfront.add(next) # 将当前先锋设置为新的先锋 frontier = newfront return degrees -=1degreesOfSeparation(small,&apos;A&apos;)# &#123;&apos;A&apos;&#125;:0# &#123;&apos;C&apos;,&apos;B&apos;&#125;:1# ...","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://ashleyblog.xyz/tags/算法/"}]},{"title":"日常记录","slug":"记录","date":"2020-01-06T13:51:48.000Z","updated":"2023-04-02T14:00:30.288Z","comments":true,"path":"2020/01/06/记录/","link":"","permalink":"https://ashleyblog.xyz/2020/01/06/记录/","excerpt":"","text":"年前的空档期去了某厂搬砖，感慨生活的不易的同时深感靠知识赚钱是一件多么幸福的事情，突然极度渴望迅速提升自己的技术水平，渴望依靠技术而不是机械性的劳动赚钱。 过完年就 23 岁了，能享受年轻的日子已经不多了，三年之后开始衰老，不再是小鲜肉，可能不再有少年的激情，可能会安于现状，一心只想求稳，可能回首今天，会觉得这根本没什么大不了，因为我现在已经稳定下来了呀。。。想到这些，既觉得得到了安慰又觉得索然无味。 我到底想要过怎样的人生？想要走什么样的职业道路？其实现在的我也不明确，未来的日子，道阻且长，唯一的愿望是希望自己可以少留遗憾，能一路向前不要回头吧。。。","categories":[],"tags":[{"name":"生活","slug":"生活","permalink":"https://ashleyblog.xyz/tags/生活/"}]},{"title":"面试中的编程题","slug":"面试中的编程题～不定期更新","date":"2019-12-24T09:46:29.000Z","updated":"2023-04-02T14:00:30.292Z","comments":true,"path":"2019/12/24/面试中的编程题～不定期更新/","link":"","permalink":"https://ashleyblog.xyz/2019/12/24/面试中的编程题～不定期更新/","excerpt":"","text":"求多个数组的交集 12345678function jiaojiArr(a,b)&#123; return new Set([...a].filter(item=&gt;b.includes(item)))&#125;function getJiaoji(...arrs)&#123;return arrs.reduce((jiaoji,arr)=&gt;&#123;return Array.from(jiaojiArr(jiaoji,arr))&#125;)&#125; 实现indexof 12345678910111213Array.prototype.indexOf=function (target,start=0)&#123; let str=this.slice(start).join(',') let strArr=str.split(`$&#123;target&#125;,`) if(strArr.length===1)&#123; return -1 &#125; return strArr[0].split(',').length - 1+start&#125;String.prototype.indexOf=function(target,start=0)&#123; let str=this.slice(start) let result=str.replace(new RegExp(`$&#123;target&#125;\\\\w+`,'g'),'').length+start return result===this.length? -1 : result&#125; 判断链表中是否存在环 思路：设置一个 slow 指针 slow = slow-&gt;next，一个 fast 指针 fast = fast-&gt;next-&gt;next。因为 fast 指针移动的比 slow 快，要是有环的话一定会相遇 12345678910111213141516171819202122232425262728293031function linknode(x)&#123;this.val=xthis.next=null&#125;class linklist()&#123;constructor(x)&#123; this.head=new linknode(x)&#125;append(x)&#123; const newnode=new linknode(x) let current=this.head while(current.next)&#123;current=current.next &#125; current.next=newnode&#125;judge()&#123; if(!this.head.next)&#123; return false &#125;let fast=this.head.next.nextlet low=this.head.nextwhile(fast.next)&#123; if(fast.next===low.next)&#123; return true &#125; fast=fast.next.next low=low.next&#125;&#125;&#125; 从数组中取得随机数不能有重复的 12345678910111213function getRandomNumFromArr(arr, count) &#123; if (count &gt;= arr.length) &#123; return arr &#125; let result = [] while (result.length &lt; count) &#123; let random = Math.floor(Math.random() * (arr.length-1)) if (!result.includes(arr[random])) &#123; result.push(arr[random]) &#125; &#125; return result&#125; 实现add函数 1234567891011121314151617function add(n) &#123; let fn = function(m) &#123; return add(n + m) &#125; // valueOf 在 算术运算时生效如 +add(2)(3) fn.valueOf = function() &#123; return n &#125; // toString 在 转换为字符串时调用 add(2)(3) fn.toString = function() &#123; return '' + n &#125; return fn&#125;add(1); // 1add(1)(2); // 3add(1)(2)(3)； // 6 获得所有父级的ID 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253const data = [ &#123; id: '1', name: 'test1', children: [ &#123; id: '11', name: 'test11', children: [ &#123; id: '111', name: 'test111' &#125; ] &#125;, &#123; id: '12', name: 'test12', children: [ &#123; id: '121', name: 'test121' &#125; ] &#125; ] &#125;]// 正则表达式版function getParentId(data) &#123; const str = JSON.stringify(data) const childReg = /\\&#123;[^&#123;&#125;]+\\&#125;/g const childCollects = str.match(chilReg) const idReg = /(?&lt;=id\\\":\\\")\\d+/g const childIdCollects = childCollects.map((child) =&gt; child.match(idReg)[0]) const totalIdCollects = str.match(idReg) return totalIdCollects.filter((item) =&gt; !childIdCollects.includes(item))&#125;// DFSfunction getParentId(data) &#123; let result = &#123;&#125; ;(function(data) &#123; const parents = data.filter((item) =&gt; 'children' in item) parents.reduce((obj, item) =&gt; &#123; obj[item.id] = Symbol() return obj &#125;, result) for (let k of parents) &#123; arguments.callee(k.children) &#125; &#125;)(data) return result&#125; 深度合并两个对象 1234567891011121314151617function mergeDeep(target, obj) &#123; let result = &#123; ...target&#125; ;(function merge(origin, obj) &#123; for (let k in obj) &#123; if ( typeof origin[k] !== 'object' || typeof obj[k] !== 'object' || Array.isArray(origin[k]) !== Array.isArray(obj[k]) ) &#123; origin[k] = obj[k] &#125; else &#123; merge(origin[k], obj[k]) &#125; &#125; &#125;)(result, obj) return result&#125;","categories":[{"name":"面试","slug":"面试","permalink":"https://ashleyblog.xyz/categories/面试/"},{"name":"js","slug":"面试/js","permalink":"https://ashleyblog.xyz/categories/面试/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://ashleyblog.xyz/tags/js/"}]},{"title":"面经css篇","slug":"面经css篇","date":"2019-12-18T13:58:19.000Z","updated":"2023-04-02T14:00:30.292Z","comments":true,"path":"2019/12/18/面经css篇/","link":"","permalink":"https://ashleyblog.xyz/2019/12/18/面经css篇/","excerpt":"","text":"水平垂直居中的各种姿势，补充 gird布局 1234567div.parent &#123; display: grid;&#125;div.child &#123; justify-self: center; align-self: center;&#125; flex 123456div.parent&#123; display:flex;&#125;div.child&#123; margin:auto;&#125; link vs @import当一个页面被加载的时候（就是被浏览者浏览的时候），link引用的CSS会同时被加载，而@import引用的CSS 会等到页面全部被下载完再被加载。 line-height 2 与200% 父元素设置line-height: 200%;属性时 父元素设置这个属性后，其所有子元素的行高都是一个具体的值，即他们父元素字体大小的200%。下例可看出子元素的行高都一致，即父元素字体大小的2倍，32px。 父元素设置line-height: 2;属性时 父元素设置这个属性后，其所有子元素的行高都是自身字体大小的2倍。下例可看出子元素的行高都是不一致的","categories":[{"name":"面经","slug":"面经","permalink":"https://ashleyblog.xyz/categories/面经/"},{"name":"css","slug":"面经/css","permalink":"https://ashleyblog.xyz/categories/面经/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://ashleyblog.xyz/tags/css/"}]},{"title":"面经浏览器篇","slug":"面经计算机网络篇","date":"2019-12-12T03:37:37.000Z","updated":"2023-04-02T14:00:30.298Z","comments":true,"path":"2019/12/12/面经计算机网络篇/","link":"","permalink":"https://ashleyblog.xyz/2019/12/12/面经计算机网络篇/","excerpt":"","text":"Http请求中的keep-alive在http早期，每个http请求都要求打开一个tpc socket连接，并且使用一次之后就断开这个tcp连接。使用keep-alive可以改善这种状态，即在一次TCP连接中可以持续发送多份数据而不会断开连接。通过使用keep-alive机制，可以减少tcp连接建立次数，也意味着可以减少TIME_WAIT状态连接，以此提高性能和提高httpd服务器的吞吐率(更少的tcp连接意味着更少的系统内核调用,socket的accept()和close()调用)。但是，keep-alive并不是免费的午餐,长时间的tcp连接容易导致系统资源无效占用。配置不当的keep-alive，有时比重复利用连接带来的损失还更大。所以，正确地设置keep-alive timeout时间非常重要。 浏览器为什么要限制get请求的参数的长度是因为url的长度会被限制 HTTPS 握手过程中，客户端如何验证证书的合法性（1）首先浏览器读取证书中的证书所有者、有效期等信息进行校验，校验证书的网站域名是否与证书颁发的域名一致，校验证书是否在有效期内（2）浏览器开始查找操作系统中已内置的受信任的证书发布机构CA，与服务器发来的证书中的颁发者CA比对，用于校验证书是否为合法机构颁发（3）如果找不到，浏览器就会报错，说明服务器发来的证书是不可信任的。（4）如果找到，那么浏览器就会从操作系统中取出颁发者CA 的公钥(多数浏览器开发商发布版本时，会事先在内部植入常用认证机关的公开密钥)，然后对服务器发来的证书里面的签名进行解密（5）浏览器使用相同的hash算法计算出服务器发来的证书的hash值，将这个计算的hash值与证书中签名做对比（6）对比结果一致，则证明服务器发来的证书合法，没有被冒充 get与post在缓存方面的区别get请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存。post不同，post做的一般是修改和删除的工作，所以必须与数据库交互，所以不能使用缓存。因此get请求适合于请求缓存。 四种存储 cookie的生存时间如果不设置过期时间expires，则表示这个 cookie 生命周期为浏览器会话期间，只要关闭浏览器窗口，cookie 就消失了。这种生命期为浏览会话期的 cookie 被称为会话 cookie。会话 cookie 一般不保存在硬盘上而是保存在内存里。 如果设置了过期时间，浏览器就会把 cookie 保存到硬盘上，关闭后再次打开浏览器，这些 cookie 依然有效直到超过设定的过期时间。 session session的本质：就是存储在服务器上的一个哈希表。 将sessionID（随机数） 通过 Cookie 发给客户端客户端访问服务器时，服务器读取 sessionID服务器有一块内存（哈希表）保存了所有 session通过sessionID 后台可以得到对应用户的隐私信息，如 id，email这块内存（哈希表）就是服务器上的所有 session 为什么会有 session? cookie能被用户截取 不安全之前的写法：直接将数据放到cookie里面：1response.setHeader('Set-Cookie', `login_email=$&#123;email&#125;`) 这样写一来会暴露用户的个人信息，二来用户可以直接通过浏览器修改cookie，极有可能获取到别人的用户信息，极不安全。因此出现了下面的使用session的操作： 12345let sessions = &#123;&#125;let sessionId = Math.random() * 10000 // 设置sessionId 为一个随机数sessions[sessionId] = &#123;login_email:email&#125; // 将email 存储在sessions这个对象中response.setHeader('Set-Cookie', `sessionId = $&#123;sessionId&#125;`) // cookie中存储的是 sessionId 这个随机数 首先来解释一下上面的代码：即设置cookie的中存储的值为一个随机数，当后台获取到cookie时，就可以获取到该随机数并在sessions这个对象中查找key为这个随机数的value，即可知道用户的邮箱是什么 。 不基于cookie能否实现session后端待用户登陆后设置他的sessionID，但不把它放在 cookie 里，而是将信息通过响应体传JSON给前端。前端拿到响应体中的JSON后将其转换成对象（JSON.parse）将从JSON中获取到的数据（如 sessionID）放在 localStorage 里面（localStorage里的数据目前暂时用不到）以后跳转到其他页面（如首页）时，将 sessionID 放在 URL 的查询参数里（如：window.location.href = ‘/?sessionId=object.sessionId’）那么进入首页后，该页面的 URL 的查询参数就带上了你的sessionID后端通过在用户访问首页时，传到服务器的 URL ，来获取到查询参数，从而获取到用户的 sessionID，然后在数据库中查到sessionID对应的信息就可以知道用户是谁。 为什么通常在发送数据埋点请求的时候使用的是 1x1 像素的透明 gif 图片作用：工作中，用于前端监控，比如曝光等等，谷歌和百度的都是用的1x1 像素的透明 gif 图片；why? 没有跨域问题，一般这种上报数据，代码要写通用的；（排除ajax）不会阻塞页面加载，影响用户的体验，只要new Image对象就好了；（排除JS/CSS文件资源方式上报）在所有图片中，体积最小；（比较PNG/JPG） cookie 和 localStorage 的区别是什么答：cookie 每次请求会被带给服务器，而 localStorage不会；cookie的最大储存量一般只有4k，而localStorage 一般有5Mb sessionstorage跟localstorage的区别localStorage: 在同一个浏览器内，同源文档之间共享 localStorage 数据，可以互相读取、覆盖。sessionStorage: 与 localStorage 一样需要同一浏览器同源文档这一条件。不仅如此，sessionStorage 的作用域还被限定在了窗口中，也就是说，只有同一浏览器、同一窗口的同源文档才能共享数据。 tcp的流量控制与拥塞控制 流量控制 （实现：主要的方式就是接收方返回的 ACK 中会包含自己的接收窗口的大小，并且利用大小来控制发送方的数据发送。）如果发送者发送数据过快，接收者来不及接收，那么就会有分组丢失。为了避免分组丢失，控制发送者的发送速度，使得接收者来得及接收，这就是流量控制。流量控制根本目的是防止分组丢失，它是构成TCP可靠性的一方面。 流量控制与拥塞控制的区别拥塞控制：拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况；常用的方法就是：（ 1 ）慢开始、拥塞避免（ 2 ）快重传、快恢复。 流量控制：流量控制是作用于接收者的，它是控制发送者的发送速度从而使接收者来得及接收，防止分组丢失的 域名解析1、浏览器中输入想要访问的网站的域名，操作系统会先检查本地的hosts文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。2、如果hosts里没有这个域名的映射，客户端会向本地DNS服务器发起查询。本地DNS服务器收到查询时，如果要查询的域名包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析。3、如果本地DNS服务器本地区域文件与缓存解析都失效，则根据本地DNS服务器的设置，采用递归或者迭代查询，直至解析完成。 递归查询 迭代查询 浏览器安全 CSRF 的防御 1、尽量使用 POST，限制 GETGET 接口太容易被拿来做 CSRF 攻击，看上面示例就知道，只要构造一个 img 标签，而 img 标签又是不能过滤的数据。接口最好限制为 POST 使用，GET 则无效，降低攻击风险。当然 POST 并不是万无一失，攻击者只要构造一个 form 就可以，但需要在第三方页面做，这样就增加暴露的可能性。2、将 cookie 设置为 HttpOnlyCRSF 攻击很大程度上是利用了浏览器的 cookie，为了防止站内的 XSS 漏洞盗取 cookie,需要在 cookie 中设置“HttpOnly”属性，这样通过程序（如 JavaScript 脚本、Applet 等）就无法读取到 cookie 信息，避免了攻击者伪造 cookie 的情况出现。在 Java 的 Servlet 的 API 中设置 cookie 为 HttpOnly 的代码如下：response.setHeader( “Set-Cookie”, “cookiename=cookievalue;HttpOnly”);3、增加 tokenCSRF 攻击之所以能够成功，是因为攻击者可以伪造用户的请求，该请求中所有的用户验证信息都存在于 cookie 中，因此攻击者可以在不知道用户验证信息的情况下直接利用用户的 cookie 来通过安全验证。由此可知，抵御 CSRF 攻击的关键在于：在请求中放入攻击者所不能伪造的信息，并且该信总不存在于 cookie 之中。鉴于此，系统开发人员可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务端进行 token 校验，如果请求中没有 token 或者 token 内容不正确，则认为是 CSRF 攻击而拒绝该请求。假设请求通过 POST 方式提交，则可以在相应的表单中增加一个隐藏域：token 的值通过服务端生成，表单提交后 token 的值通过 POST 请求与参数一同带到服务端，每次会话可以使用相同的 token，会话过期，则 token 失效，攻击者因无法获取到 token，也就无法伪造请求。 note: 1、要确保同一页面中每个表单都含有自己唯一的令牌 2、验证后需要删除相应的随机数 3、Token 保存在 Session 中。假如 Token 保存在 Cookie 中，用户浏览器开了很多页面。在一些页面 Token 被使用消耗掉后新的Token 会被重新种入，但那些老的 Tab 页面对应的 HTML 里还是老 Token。这会让用户觉得为啥几分钟前打开的页面不能正常提交？在 session 中添加 token 的实现代码： 12345HttpSession session = request.getSession();Object token = session.getAttribute(\"_token\");if(token == null I I \"\".equals(token)) &#123; session.setAttribute(\"_token\", UUID.randomUUIDO .toString());&#125; 4、通过 Referer 识别根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。在通常情况下，访问一个安全受限的页面的请求都来自于同一个网站。比如某银行的转账是通过用户访问http://www.xxx.com/transfer.do页面完成的，用户必须先登录www.xxx.com，然后通过单击页面上的提交按钮来触发转账事件。当用户提交请求时，该转账请求的Referer值就会是提交按钮所在页面的 URL（本例为 www.xxx. com/transfer.do）。如果攻击者要对银行网站实施 CSRF 攻击，他只能在其他网站构造请求，当用户通过其他网站发送请求到银行时，该请求的 Referer 的值是其他网站的地址，而不是银行转账页面的地址。因此，要防御 CSRF 攻击，银行网站只需要对于每一个转账请求验证其 Referer 值即可，如果是以 www.xx.om 域名开头的地址，则说明该请求是来自银行网站自己的请求，是合法的；如果 Referer 是其他网站，就有可能是 CSRF 攻击，则拒绝该请求。取得 HTTP 请求 Referer：String referer = request.getHeader(“Referer”);5.使用验证码 xss攻击方式以及防御 中间人攻击中间人攻击过程如下： 服务器向客户端发送公钥。攻击者截获公钥，保留在自己手上。然后攻击者自己生成一个【伪造的】公钥，发给客户端。客户端收到伪造的公钥后，生成加密hash值发给服务器。攻击者获得加密hash值，用自己的私钥解密获得真秘钥。同时生成假的加密hash值，发给服务器。服务器用私钥解密获得假秘钥。服务器用加秘钥加密传输信息防范方法： 服务端在发送浏览器的公钥中加入CA证书，浏览器可以验证CA证书的有效性强制页面使用https 防御中间人攻击 123function requestHandler(req, res)&#123; res.setHeader('Strict-Transport-Security','max-age=31536000; includeSubDomains; preload');&#125; 深入了解浏览器缓存机制https://www.jianshu.com/p/54cc04190252补充：关于强缓存取资源的位置如果开启了Service Worker首先会从Service Worker中拿如果新开一个以前打开过的页面缓存会从Disk Cache中拿（前提是命中强缓存）刷新当前页面时浏览器会根据当前运行环境内存来决定是从 Memory Cache 还是 从Disk Cache中拿(可以看到下图最后几个文件有时候是从 Memory Cache中拿有时候是从Disk Cache中拿) 303与302的区别303 常用于将 POST 请求重定向到 GET 请求，比如你上传了一份个人信息，服务器发回一个 303 响应，将你导向一个“上传成功”页面。 websoket http之间的联系 都是一样基于TCP的，都是可靠性传输协议。 都是应用层协议。 WebSocket在建立握手时，数据是通过HTTP传输的。但是建立之后，在真正传输时候是不需要HTTP协议的。 WebSocket连接的过程是： 首先，客户端发起http请求，经过3次握手后，建立起TCP连接；http请求里存放WebSocket支持的版本号等信息，如：Upgrade、Connection、WebSocket-Version等；然后，服务器收到客户端的握手请求后，同样采用HTTP协议回馈数据；最后，客户端收到连接成功的消息后，开始借助于TCP传输信道进行全双工通信。 http keepaliveHttp keep-alive在 HTTP 1.0 时期，每个 TCP 连接只会被一个 HTTP Transaction（请求加响应）使用，请求时建立，请求完成释放连接。当网页内容越来越复杂，包含大量图片、CSS 等资源之后，这种模式效率就显得太低了。所以，在 HTTP 1.1 中，引入了 HTTP persistent connection 的概念，也称为 HTTP keep-alive，目的是复用TCP连接，在一个TCP连接上进行多次的HTTP请求从而提高性能。 tcp keepalive在使用TCP长连接（复用已建立TCP连接）的场景下，需要对TCP连接进行保活，避免被网关干掉连接。在应用层，可以通过定时发送心跳包的方式实现。 数字签名工作原理https://blog.51cto.com/winda/1968298 参考文章 浏览器缓存控制详解（cookie、session、localStorage、Cache-Control等 安全|常见的Web攻击手段之CSRF攻击 前端 100 问：能搞懂80%的请把简历给我","categories":[{"name":"面经","slug":"面经","permalink":"https://ashleyblog.xyz/categories/面经/"},{"name":"浏览器","slug":"面经/浏览器","permalink":"https://ashleyblog.xyz/categories/面经/浏览器/"}],"tags":[]},{"title":"秋季前端面经记录","slug":"秋季前端面经记录","date":"2019-12-11T09:16:23.000Z","updated":"2023-04-02T14:00:30.297Z","comments":true,"path":"2019/12/11/秋季前端面经记录/","link":"","permalink":"https://ashleyblog.xyz/2019/12/11/秋季前端面经记录/","excerpt":"","text":"问到sessionstorage跟localstorage的区别 答前者只在当前窗口有效是对的 再问一遍又不确定了 说明基础不牢固容易被套路 存储大小： 都为 5MB 存储位置： 都在客户端，不予服务器进行交互通信 存储内容类型： 字符串，复杂的对象可以使用 ECMAScript 提供的 JSON stringify 和 parse 来处理 获取方式：window.localStorage, window.sessionStorage 应用场景： localStorage 用于长期登录 and 判断用户是否已登录sessionStorage 敏感账号一次性登录 页面卡顿 怎么监测到是哪一部分的代码出现了问题火焰图(可以看到每个函数占据的宽度，越宽表示执行的时间越长) 要是不用框架的话 怎么优化代码的结构？MVVM又称状态机制，View 和 ViewModel 是进行绑定的，改变 ViewModel 就会直接作用到 View 视图上，而 View 会把事件传递给 ViewModel,ViewModel 去对 Model 进行操作并接受更新。 View：UI 界面 ViewModel：它是 View 的抽象，负责 View 与 Model 之间信息转换，将 View 的 Command 传送到 Model；比起 MVP 中 View 需要自己提供 API，MVVM 在 VM 中构建一组状态数据（state data），作为 View 状态的抽象。然后通过双向数据绑定（data binding）使 VM 中的状态数据（state data）与 View 中的显示状态（screen state）保持一致。这样，VM 中的展示逻辑只需要修改对应的状态数据，就可以控制 View 的状态，从而避免在 View 上开发大量的接口 Model：数据访问层 ？不适合 SEO？ 例如，我们定义好一个 JavaScript 对象作为 Model，并且把这个 Model 的两个属性绑定到 DOM 节点上： MVCView 持有了 Controller，把事件传递给 Controller，Controller 由此去触发 Model 层的事件，Model 更新完数据（网络或者本地数据）之后触发 View 的更新事件 View 负责渲染用户界面，应该避免在 View 中涉及业务逻辑 Controller 负责接收用户输入，根据用户输入调用 Model 逻辑，将产生的结果交给 View 部分，让 View 渲染出必要的输出 Model 负责管理数据，大部分业务逻辑也应该放在 Model 缺点： 由于在实现的过程中，往往出现 View 与 Model 不经过 Controller 通信的现象，造成数据流混乱，难以维护和增加功能 mvc 与 mvvm 的区别MVVM 与 MVC 最大的区别就是：它实现了 View 和 Model 的自动同步，也就是当 Model 的属性改变时，我们不用再自己手动操作 Dom 元素，来改变 View 的显示，而是改变属性后该属性对应 View 层显示会自动改变 拿典型的 MVVM 模式的代表，Vue，来举例html 部分相当于 View 层，可以看到这里的 View 通过通过模板语法来声明式的将数据渲染进 DOM 元素，当 ViewModel 对 Model 进行更新时，通过数据绑定更新到 View。 Vue 实例中的 data 相当于 Model 层，而 ViewModel 层的核心是 Vue 中的双向数据绑定，即 Model 变化时 VIew 可以实时更新，View 变化也能让 Model 发生变化。 跨域补充： cra 生成的项目支持在package.json字段设置proxy如：will proxy your request to http://localhost:4000/api/todos as a fallback 1\"proxy\": \"http://localhost:4000\", 本地测试用 配置 hosts 文件 如：’127.0.0.1 xx.com’或者是配置 switchyomega 比如输入 test.xxx.com 代理到 localhost 这样发请求的时候的 origin 是 test 就不会出现跨域错误 （midc 有些接口是能跨域的，所以 origin 是 localhost 的时候也不会报错） postmessage+iframe 性能优化 （不要一直说 react）虚拟 dom就是一个普通的 JavaScript 对象，包含了 tag、props、children 三个属性。 1234567891011121314151617&#123; tag: 'div', props: &#123; id: 'app' &#125;, chidren: [ &#123; tag: 'p', props: &#123; className: 'text' &#125;, chidren: [ 'hello world!!!' ] &#125; ]&#125; 主流的虚拟 DOM 库（snabbdom、virtual-dom），通常都有一个 h 函数，也就是 React 中的 React.createElement，以及 Vue 中的 render 方法中的 createElement，另外 React 是通过 babel 将 jsx 转换为 h 函数渲染的形式，而 Vue 是使用 vue-loader 将模版转为 h 函数渲染的形式（也可以通过 babel-plugin-transform-vue-jsx 插件在 vue 中使用 jsx，本质还是转换为 h 函数渲染形式）。 虚拟 dom 的优势减少 JavaScript 操作真实 DOM 的带来的性能消耗。虽然这一个虚拟 DOM 带来的一个优势，但并不是全部。虚拟 DOM 最大的优势在于抽象了原本的渲染过程，实现了跨平台的能力，而不仅仅局限于浏览器的 DOM，可以是安卓和 IOS 的原生组件，可以是近期很火热的小程序，也可以是各种 GUI 深浅拷贝的区别 怎么深拷贝一个函数 浅拷贝—浅拷贝是指复制对象的时候，只对第一层键值对进行独立的复制，如果对象内还有对象，则只能复制嵌套对象的地址 12// 浅拷贝数组a.slice() || a.concat() 深拷贝—深拷贝是指复制对象的时候完全的拷贝一份对象，即使嵌套了对象，两者也相互分离，修改一个对象的属性，也不会影响另一个。其实只要递归下去，把那些属性的值仍然是对象的再次进入对象内部一 一进行复制即可。 note! JSON.parse(JSON.stringify(obj))的缺陷是不能够拷贝函数 因为 JSON 不允许包含函数，JSON.stringify() 会删除 JavaScript 对象的函数，包括 key 和 value。 解决JSON.stringify不能拷贝函数的问题 123456789101112131415161718192021222324252627function deepClone(source, hash = new WeakMap()) &#123; let obj const Constructor = source.constructor switch (Constructor) &#123; case Date: obj = new Constructor(source.getTime()) break case RegExp: obj = new Constructor(source) break default: if (hash.has(source)) &#123; return hash.get(source) &#125; obj = new Constructor() hash.set(source, obj) break &#125; for (let key in source) &#123; obj[key] = isObject(source[key]) ? deepClone(source[key], hash) : source[key] &#125; return obj&#125; doctype 的作用声明了的话浏览器就会使用标准模式解析页面 这样所有浏览器显示的样式就是一样的 使用symbol会遇到哪些问题 symbol的特点1.Symbol(‘key’) !== Symbol(‘key’) //true,返回不同2.Symbol(“know”).name = 1; // TypeError,只读3.for…in 、 Object.keys(obj) 、Object.getOwnPropertyNames(obj)会忽略 Symbol,即自身不可枚举 4.不能用 obj.prop 的形式访问 symbol的使用场景第一个作用是作为属性名避免属性名冲突，第二个作用是替代代码中多次使用的字符串（例如：abc），多次使用的字符串在代码中不易维护，而这时候定义一个对象的属性（属性名用 Symbol 格式），值为 abc，就可以作为全局变量来使用了。第三个，由于以 Symbol 值作为名称的属性，不会被常规方法遍历得到。我们可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法。第四个，这个有时，我们希望重新使用同一个 Symbol 值，Symbol.for 方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建并返回一个以该字符串为名称的 Symbol 值。 生成一个唯一值 因为我们在使用它的时候属性值是多少都无所谓 1234567var race = &#123; protoss: Symbol(), terran: Symbol(), zerg: Symbol()&#125;race.protoss !== race.terran // true 基本数据类型的判断 typeof Symbol() === ‘symbol’ redux的原理（要深入 中间件）关于使用hooks实现reduxdispatch 一个 action 的时候将 action 传入所有的 reducers,然后返回更新的 state 同时触发使用subscribe方法注册的所有 listener 函数(为什么在 hasChanged 为 true 的时候还要接着调用后面的 reducers 呢？) 为什么reducer要是一个纯函数 react 有一个 shouldcomponentupdate 事件作为优化，当我们重渲染时也希望订阅事件能差异化更新以优化性能，怎么实现？比对一次更新里的新老 state当 reducer 是纯函数时，生成一个新 state，新老对象地址引用不一，能实现若 reducer 是副作用，那么虽然对象内变化，新老对象地址一致，不能实现此外在combinereducers中判断haschanged也是通过nextStateForKey !== previousStateForKey 直接判断引用而不是深度遍历比较两个对象的值 更简洁 如果不是纯函数 返回的 state 就具有不确定性 那么 UI 拿到的数据也具有不确定性 redux 中的观察者模式 store 提供数据的 get 钩子（store.getState）,不直接提供数据的 set，所以必须通过 dispatch（action）来 set 数据。 利用观察者模式（sub/ pub）连接 model 和 view 的中间对象。view 层通过调用 store.dispatch 方法触发 reducer 改变 model。对应 pub。 model 层通过调用 store.subscribe 注册视图更新事件（setstate），该事件会在数据改变之后被调用。对应 sub。 观察者模式和发布订阅模式的区别 关于最近做的项目，自我介绍，错误监控，学了哪些新技术。。。关于函数组件跟类式组件的区别props是不可变数据，永远不会改变。但是，this却始终是可变的 。所以通过this拿到的永远都是最新的值 123456789101112131415161718192021222324class ProfilePage extends React.Component &#123; showMessage = () =&gt; &#123; alert('Followed ' + this.props.user) &#125; handleClick = () =&gt; &#123; setTimeout(this.showMessage, 3000) &#125; render() &#123; return &lt;button onClick=&#123;this.handleClick&#125;&gt;Follow&lt;/button&gt; &#125;&#125;function ProfilePage(props) &#123; const showMessage = () =&gt; &#123; alert('Followed ' + props.user) &#125; const handleClick = () =&gt; &#123; setTimeout(showMessage, 3000) &#125; return &lt;button onClick=&#123;handleClick&#125;&gt;Follow&lt;/button&gt;&#125; 当点击 follow 之后再切换用户的名字，三秒之后函数组件弹出来的依旧是点击 follow 的时候的用户的名字而类组件弹出来的却是切换之后的名字，是因为函数组件能捕获某一时刻的 props 与 state（hooks 也是一样的） 算法红黑树本质是一种二叉查找树，也就是左边的子节点的值比根节点小，右边的比根节点大，在极端情况下，比如连续插入依次递增或递减的节点，查找树将退化成链表红黑树通过如下的性质定义实现自平衡： 节点是红色或黑色。根是黑色。所有叶子都是黑色（叶子是 NIL 节点）。每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点（简称黑高） 实现模糊搜索结果的关键词高亮显示考虑节流、缓存。其实还可以上列表diff+定时清理缓存 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647function debounce(fn, timeout = 300) &#123; let t; return (...args) =&gt; &#123; if (t) &#123; clearTimeout(t); &#125; t = setTimeout(() =&gt; &#123; fn.apply(fn, args); &#125;, timeout); &#125; &#125;// data应该是一个很大的数组 为了减小cache占的内存 缓存用户输入过的关键词 function memorize(fn) &#123; const cache = new Map(); return (name) =&gt; &#123; if (!name) &#123; container.innerHTML = ''; return; &#125; if (cache.get(name)) &#123; container.innerHTML = cache.get(name); return; &#125; const res = fn.call(fn, name).join(''); cache.set(name, res); container.innerHTML = res; &#125; &#125; function handleInput(value) &#123; const reg = new RegExp(`\\($&#123;value&#125;\\)`); const search = data.reduce((res, cur) =&gt; &#123; if (reg.test(cur)) &#123; const match = RegExp.$1; res.push(`&lt;li&gt;$&#123;cur.replace(match, '&lt;bdi&gt;$&amp;&lt;/bdi&gt;')&#125;&lt;/li&gt;`); &#125; return res; &#125;, []); return search; &#125; const data = [\"上海野生动物园\", \"上饶野生动物园\", \"北京巷子\", \"上海中心\", \"上海黄埔江\", \"迪士尼上海\", \"陆家嘴上海中心\"] const container = document.querySelector('.container'); const memorizeInput = memorize(handleInput); document.querySelector('.inp').addEventListener('input', debounce(e =&gt; &#123; memorizeInput(e.target.value); &#125;)) 参考文章 虚拟 DOM 到底是什么 MVC 和 MVVM 的区别 React 函数组件和类组件的差异 “深拷贝” 与 “浅拷贝” 的区别，JS 实现深浅拷贝的几种方法 「每日一题」JS 中的 Symbol 是什么？ 前端 100 问：能搞懂 80%的请把简历给我","categories":[{"name":"面经","slug":"面经","permalink":"https://ashleyblog.xyz/categories/面经/"}],"tags":[]},{"title":"面经项目构建篇","slug":"面经项目构建篇","date":"2019-12-11T02:58:38.000Z","updated":"2023-04-02T14:00:30.286Z","comments":true,"path":"2019/12/11/面经项目构建篇/","link":"","permalink":"https://ashleyblog.xyz/2019/12/11/面经项目构建篇/","excerpt":"","text":"怎么约束代码规范？结合lint-staged与husky 实现在每次提交之前 自动修复本次修改的代码 123456789101112131415161718&#123; \"scripts\": &#123; \"precommit\": \"lint-staged\" //这个钩子是在安装husky之后才有的 package.json中原有的钩子:https://segmentfault.com/a/1190000008832423 &#125;, \"lint-staged\": &#123; \"src/**/*.js\": [\"eslint --fix\", \"git add\"] &#125;&#125;// 或者使用下面的配置，自动格式化代码（谨慎使用）：&#123; \"scripts\": &#123; \"precommit\": \"lint-staged\" &#125;, \"lint-staged\": &#123; \"src/**/*.js\": [\"prettier --write\", \"git add\"] &#125;&#125; webpack打包优化 定位体积大的模块 - webpack-bundle-analyzer 移除不必要的文件使用webpack自带的两个库 IgnorePlugin ContextReplacementPlugin 12345678910// 插件配置plugins: [ // 忽略moment.js中所有的locale文件 new webpack.IgnorePlugin(/^\\.\\/locale$/, /moment$/),],// 使用方式const moment = require('moment');// 引入zh-cn locale文件require('moment/locale/zh-cn');moment.locale('zh-cn'); 模块化引用 1234import &#123;chain, cloneDeep&#125; from 'lodash';// 可以改写为import chain from 'lodash/chain';import cloneDeep from 'lodash/cloneDeep'; 通过CDN引用 服务端开启Gzip压缩开启gzip压缩可以减少HTTP传输的数据量和时间，从而减少客户端请求的响应时间 splitChunks配置代码分割此特性能够把代码分离到不同的 bundle 中，然后可以按需加载或并行加载这些文件。代码分离可以用于获取更小的 bundle，以及控制资源加载优先级，如果使用合理，会极大影响加载时间。 webpack 热更新原理在 webpack 中，都是模块且有唯一标识。在 webpack 编译完成后，将修改的模块 hash 对应的模块重新执行。就达到了局部刷新的效果。 过程webpack-dev-middleware 是用来处理文件打包到哪里，到内存读取速度更快。devServer 在监听 compiler done 后，利用 socket 告诉 devServer/client 修改模块的 hashHMR.runtime 利用 HTTP 请求 hash.hot-update.json 获取更新模块列表 hotDownloadManifest{“h”:”11ba55af05df7c2d3d13”,”c”:{“index-wrap”:true}}再通过 HTTP (jsonp) 获取更新模块的 jsindex-wrap.7466b9e256c084c8463f.hot-update.js返回执行 123webpackHotUpdate(\"index-wrap\", &#123; // ....&#125;) webpackHotUpdate 做了三件事找到过期的模块和依赖并从缓存中删除 12delete installedModules[moduleId];delete outdatedDependencies[moduleId]; 遍历所有的 module.children，重新 installedModules 所有的子模块最后将自身模块的内容做替换修改 1modules[moduleId] = appliedUpdate[moduleId] 最后代码替换之后并没有重新执行，需要手动注册需要重新执行的模块方法 123456if (module.hot) &#123; module.hot.accept('./print.js', function() &#123; console.log('Accepting the updated printMe module!'); printMe(); &#125;) &#125; 国际化方案后端在cookie中设置applocal字段 前端再去拿。。。 参考文章 [用 husky 和 lint-staged 构建超溜的代码检查工作流](用 husky 和 lint-staged 构建超溜的代码检查工作流) Webpack打包优化 轻松理解webpack热更新原理","categories":[],"tags":[{"name":"配置","slug":"配置","permalink":"https://ashleyblog.xyz/tags/配置/"}]},{"title":"面经js篇","slug":"面经js篇","date":"2019-12-10T10:48:35.000Z","updated":"2023-04-02T14:00:30.289Z","comments":true,"path":"2019/12/10/面经js篇/","link":"","permalink":"https://ashleyblog.xyz/2019/12/10/面经js篇/","excerpt":"","text":"原生 jstypeof的原理js 在底层存储变量的时候，会在变量的机器码的低位 1-3 位存储其类型信息 👉 000：对象010：浮点数100：字符串110：布尔1：整数 but, 对于 undefined 和 null 来说，这两个值的信息存储是有点特殊的。null：所有机器码均为 0undefined：用 −2^30 整数来表示所以，typeof 在判断 null 的时候就出现问题了，由于 null 的所有机器码均为 0，因此直接被当做了对象来看待。 instanceof的原理通过判断右边的变量的prototype是否在左边的变量的原型链上 123456789101112function myInstanceOf(leftVal, rightVal) &#123; let rightProto = rightVal.prototype let leftCopy = leftVal.__proto__ while (true) &#123; if (leftCopy === null) &#123; return false &#125; else if (leftCopy === rightProto) &#123; return true &#125; leftCopy = leftCopy.__proto__ &#125;&#125; 生成指定范围内的随机数1234function RandomNum (min, max) &#123; let range = max - min return Math.round(Math.random()*range) + min&#125; null undefined 的区别前者是一个特殊的对象 不会被垃圾回收机制回收 前者转换成数字是 0 后者是 NaN 函数参数是按值传递 为什么传一个对象进去 函数内部的修改会影响该对象传的是是栈内数据的拷贝简单数据类型传的是 值本身 （因为直接把值存在栈内）复杂数据类型传的是 对象在内存里面的地址 （因为复杂对象存在堆内，所以在栈里存对象所在的堆地址） 你觉得jQuery或zepto源码有哪些写的好的地方jquery源码封装在一个匿名函数的自执行环境中，有助于防止变量的全局污染，然后通过传入window对象参数，可以使window对象作为局部变量使用，好处是当jquery中访问window对象的时候，就不用将作用域链退回到顶层作用域了，从而可以更快的访问window对象。同样，传入undefined参数，可以缩短查找undefined时的作用域链。 12345678910111213(function( window, undefined ) &#123; //用一个函数域包起来，就是所谓的沙箱 //在这里边var定义的变量，属于这个函数域内的局部变量，避免污染全局 //把当前沙箱需要的外部变量通过函数参数引入进来 //只要保证参数对内提供的接口的一致性，你还可以随意替换传进来的这个参数 window.jQuery = window.$ = jQuery;&#125;)( window ); 虚拟dom 为什么直接操作dom耗时v8 binding会将原生的dom对象（比如document.a)映射成包装的js对象，所以执行document.a=。。。很快但是document.title=。。。很慢是因为修改title的时候同时也修改了 DOM 对象的 attributes此外很多时候操作dom都会引起重绘与回流 并且很多dom api的读写都会设计页面布局的重新计算以确保返回值的准确 虚拟dom不快 为什么react快 React is fast because it only manipulates the DOM as much as it needs to,Updating changes is much faster than re-building the entire DOM tree from scratch. It’s able to do this because it keeps the virtual DOM representation from the last time we updated or rendered our component in memory. It then compares the two versions and updates the changes. React Virtual DOM is an object,when we create an webpage browser create dom in a tree manner. to find the changes in two different trees &gt;time complexity is O(n^3) but REACT DIFF algorithm can able to do it in O(n) time by using keys of each node.that is why react is faster 为什么虚拟dom性能更好 传统MVC框架,如backbone,它是将某个模板编译成模板函数,需要更新时,是自己手动将数据整体传入模板函数, 得到一个字符串,使用innerHTML刷新某个容器!注意,这里其实可以优化,但由于是手动,是体力活,都是使用很粗放型的innerhTML了事 (使用jQuery的html方法性能会更差,不过好处是它处理了IE下的innerHTML BUG及全平台的无法执行内部的script标签的BUG) 由于整体替换,一下子销毁这么多元素(有时还绑着事件,可能导致GC出问题),又要插入这么多元素,再重新绑定事件(这个可以使用事件代理缓解) 因此性能非常差 knockout那样, 使用时让用户痛苦一些,使用可同步视图的东西用函数(wrapper)包裹起来, 刷新视图,就只需要重新调用这个wrapper.现在所有新的MVVM都是从ko那里学到依赖收集. 这个wraper会通知其依赖的wrapper,通过极其痛苦晦涩的方式进入事件总线, 执行视图刷新函数. knockout是使用闭包用到极致的库,显然这样做性能也很差. 最后react, 首先使用编译手段(jsx的虚拟DOM转换), 将这部分消耗能提前释放出去, 不过将字符串(jsx模板)转换为一个个JS对象,也占不了多少内存. 然后是数据发生变动时, 由于数据变动都是需要用setState方法,因此兼容性很好, 少了Object.defineProperty或wrapper的消耗,然后对应数据通过render转换成字符串,字符串再转换虚拟DOM树 先后虚拟DOM进行比较, 更新视图. react是面向组件设计, 一个组件就是一个密封舱, 很少会对所有虚拟DOM进行比较, 由于强制使用单向流动, 减少每次变动需要的diff. 没有绑定对象与wrapper的内存占用高的问题. 实现函数柯里化123456789101112function curry(f) &#123; const context = this let args = [] return function(...arg) &#123; args = args.concat(arg) if (arg.length) &#123; return arguments.callee &#125; else &#123; return f.apply(context, arg) &#125; &#125;&#125; arguments.callee 与arguments.caller的区别1234567function f() &#123; // arguments.callee : [Function:f] // arguments.caller : [Function:g]&#125;function g() &#123; f()&#125; 类数组对象有哪些具有length属性的并且能使用索引访问的 比如arguments dom相关的数据结构 localstorage sesstionstorage.. 函数提升跟变量提升函数声明的优先级最高，会被提升至当前作用域最顶端 实现深拷贝循环递归实现12345678910111213141516171819202122232425262728293031var a = &#123; name: 'mary', age: 20, friend: &#123; name: '哈哈', age: 19, hobby: 'eat' &#125;&#125;function deep(obj) &#123; var newobj = &#123;&#125; for (var key in obj) &#123; // 此处遍历的key包括了实例对象和它原型的属性，所以要用hasOwnProperty进行筛选(node环境不会，浏览器环境会列举原型属性) if (obj.hasOwnProperty(key)) &#123; // 如果是基本类型则进行复制 if ( typeof obj[key] === 'number' || typeof obj[key] === 'string' || typeof obj[key] === 'boolean' || obj[key] === undefined || obj[key] === null ) &#123; newobj[key] = obj[key] // 如果不是则为array或者object,仍然需要深层次的递归复制 &#125; else &#123; newobj[key] = deep(obj[key]) &#125; &#125; &#125; return newobj&#125; load 事件与 DOMContentLoaded 事件,$(document).ready() 当 DOMContentLoaded 事件触发时，仅当 DOM 加载完成，不包括样式表，图片。 当 onload 事件触发时，页面上所有的 DOM，样式表，脚本，图片都已经加载完成了。 $(document).ready()是DOM结构绘制完毕后就执行，不必等到加载完毕 window.onload不能同时编写多个，如果有多个window.onload方法，只会执行一个，$(document).ready()可以同时编写多个，并且都可以得到执行,$(document).ready(function(){})可以简写成$(function(){}) 构造函数的返回值 构造函数不需要显示的返回值。使用 new 来创建对象(调用构造函数)时，如果 return 的是非对象(数字、字符串、布尔类型等)会忽而略返回值;如果 return 的是对象，则返回该对象(注：若 return null 也会忽略返回值）。 大数求和采用小时侯学加法时的手动计算的方法，从最低位依次相加，得到最后的结果因为对于较大的数js会自动采用科学记数法的方式表示，所以参与计算的参数用字符串表示 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758function getSum(d1, d2) &#123; // 如果第一个数较大则交换两个数 if (d1.length &lt; d2.length) &#123; [d1, d2] = [d2, d1]; &#125; // 将两个数转为数组形式 let [arr1, arr2] = [[...d1].reverse(), [...d2].reverse()]; // num用作当对应位数相加大于10时做进位 let num = 0; // 循环arr1.length次求和 for (let i = 0; i &lt; arr1.length; i++) &#123; if (arr2[i]) &#123; arr1[i] = Number.parseInt(arr1[i]) + Number.parseInt(arr2[i]) + num; &#125; else &#123; arr1[i] = Number.parseInt(arr1[i]) + num; &#125; if (arr1[i] &gt;= 10) &#123; [arr1[i], num] = [arr1[i] % 10, 1]; &#125; else &#123; num = 0; &#125; &#125; // 如果最后进位为1，则结果前应加1为 if (num === 1) &#123; arr1[arr1.length] = num; &#125; // 返回结果字符串 return arr1.reverse().join('');&#125;args=args.concat(arg)``` ### generator函数的使用场景* 多文件上传 上传完第一组文件之后暂停执行 做其他的事情 之后再继续上传 通过返回值done属性是否为真来判断能否继续执行* 生成具有index的enumerate结构 (返回的是iterator对象 能直接使用for in遍历，也能作为Array.from等的参数)### 深度比较两个对象1.通过json.parse(json.stringify)... 相等直接返回true2.object.keys.length不相等 返回false3.遍历 遇到为对象的属性递归### 实现 bind```js// 定义这个方法为myBindFunction.prototype.my_bind = function() &#123; var self = this, // 保存原函数 context = Array.prototype.shift.call(arguments), // 保存需要绑定的this上下文 // 上一行等价于 context = [].shift.call(arguments); args = Array.prototype.slice.call(arguments) // 剩余的参数转为数组 return function() &#123; // 返回一个新函数 self.apply( context, Array.prototype.concat.call(args, Array.prototype.slice.call(arguments)) ) &#125;&#125; promise的构造函数跟他的then方法是异步还是同步promise构造函数是同步执行的，then方法因为是微任务是异步执行的 模块化 为什么要模块化为了避免全局污染 思维导图https://www.processon.com/view/link/5c8409bbe4b02b2ce492286a#map js类型转换 强制类型转换通过 Number()、parseInt()、parseFloat()、toString()、String()、Boolean(),进行强制类型转换。 隐式类型转换逻辑运算符(&amp;&amp;、 ||、 !)、运算符(+、-、*、/)、关系操作符(&gt;、 &lt;、 &lt;= 、&gt;=)、相等运算符(==)或者 if/while 的条件，可能会进行隐式类型转换。关于valueof tostring在数值运算里，会优先调用valueOf() 字符串运算优先调用后者 实现数组扁平化 方式一 1;[].concat.apply([], [[1], [2], [3]]) // [1, 2, 3] chrome 69 后数组自带 flat 方法 方式二 12345function flatten(arr) &#123; return arr.reduce(function(prev, item) &#123; return prev.concat(Array.isArray(item) ? flatten(item) : item) &#125;, [])&#125; 方式三 123456function flatten(arr)&#123; while(arr.some(item=&gt;Array.isArray(item))&#123; arr = [].concat(...arr); &#125; return arr;&#125; 实现[1,2].mutiple() = [1,2,1,4]1234Array.prototype.mutiple = function() &#123; const tail = this.map((item) =&gt; item ** 2) return [...this, ...tail]&#125; 实现compose函数1234567891011121314export default function compose(...funcs) &#123; if (funcs.length === 0) &#123; return arg =&gt; arg &#125; if (funcs.length === 1) &#123; return funcs[0] &#125; const last = funcs[funcs.length - 1] const rest = funcs.slice(0, -1) // reduceright:将数组中每一项从右向左调用callback return (...args) =&gt; rest.reduceRight((composed, f) =&gt; f(composed), last(...args))&#125; var a3 = {name: “前端开发”}; var b3 = a3; a3 = null console.log(b3)?// {name: “前端开发”} 事件委托的优缺点 优点减少事件注册 减小内存 缺点有的事件不支持冒泡 0.1+0.2!=0.3十进制的 0.1 和 0.2 都会被转换成二进制，但由于浮点数用二进制表达时是无穷的，例如。JavaScript 代码:0.1 -&gt; 0.0001100110011001…(无限)0.2 -&gt; 0.0011001100110011…(无限)IEEE 754 标准的 64 位双精度浮点数的小数部分最多支持 53 位二进制位，所以两者相加之后得到二进制为：JavaScript 代码:0.0100110011001100110011001100110011001100110011001100因浮点数小数位的限制而截断的二进制数字，再转换为十进制，就成了 0.30000000000000004。所以在进行算术计算时会产生误差 怎么设置对象的属性不能被删除？definePropperty设置configurable falsewhy? https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/delete addeventListener的第三个参数是一个对象option,包括capture, passive,once选项 不支持这种写法的默认第三个参数是usecapture 几种判断数组类型的优缺点instanceof不能检测来自iframe的数组。就是window.frames[xx].Array构造出来的数组Array.isArray兼容性没那么好 为什么表单能跨域因为表单的请求一般都是提交数据 并且传统form表单提交浏览器会发生跳转 并且不需要返回响应数据 是安全的 为什么箭头函数不能使用new操作符因为它没有自己的this与prototype 属性 ，而 new 命令在执行时需要将构造函数的 prototype 赋值给新的对象的 proto react 相关React 中 setState 什么时候是同步的，什么时候是异步的在 React 中，如果是由 React 引发的事件处理也就是合成事件（比如通过 onClick 引发的事件处理），调用 setState 不会同步更新 this.state，除此之外的 setState 调用会同步执行 this.state。所谓“除此之外”，指的是绕过 React 通过 addEventListener 直接添加的事件处理函数也就是原生事件，还有通过 setTimeout/setInterval 产生的异步调用。 原因：在 React 的 setState 函数实现中，会根据一个变量 isBatchingUpdates 判断是直接更新 this.state 还是放到队列中回头再说，而 isBatchingUpdates 默认是 false，也就表示 setState 会同步更新 this.state，但是，有一个函数 batchedUpdates，这个函数会把 isBatchingUpdates 修改为 true，而当 React 在调用事件处理函数之前就会调用这个 batchedUpdates，造成的后果，就是由 React 控制的事件处理过程 setState 不会同步更新 this.state。 jsx 语法为什么 需要 import react 包JSX 语法只是一种语法糖，babel转译之后就会变成React.createElement react 生命周期变更的原因在 fiber 中，更新是分阶段的，具体分为两个阶段，首先是 reconciliation 的阶段，这个阶段在计算前后 dom 树的差异，然后是 commit 的阶段，这个阶段将把更新渲染到页面上。第一个阶段是可以打断的，因为这个阶段耗时可能会很长，因此需要暂停下来去执行其他更高优先级的任务，第二个阶段则不会被打断，会一口气把更新渲染到页面上。 由于 reconciliation 的阶段会被打断，可能会导致 commit 前的这些生命周期函数多次执行。react 官方目前已经把 componentWillMount、componentWillReceiveProps 和 componetWillUpdate 标记为 unsafe，并使用新的生命周期函数 getDerivedStateFromProps 和 getSnapshotBeforeUpdate 进行替换。 组件的渲染被分为两个阶段：第一个阶段（也叫做 render 阶段）是可以被 React 打断的，一旦被打断，这阶段所做的所有事情都被废弃，当 React 处理完紧急的事情回来，依然会重新渲染这个组件，这时候第一阶段的工作会重做一遍；第二个阶段叫做 commit 阶段，一旦开始就不能中断，也就是说第二个阶段的工作会稳稳当当地做到这个组件的渲染结束。 两个阶段的分界点，就是 render 函数。render 函数之前的所有生命周期函数（包括 render)都属于第一阶段，之后的都属于第二阶段。render 之前的生命周期函数（也就是第一阶段生命周期函数）包括这些： componentWillReceivePropsshouldComponentUpdatecomponentWillUpdatecomponentWillMountrender getDerivedStateFromProps 应该是一个纯函数，React 就是通过要求这种纯函数，强制开发者们必须适应异步渲染。 reconciliation 阶段虚拟 dom 的数据对比 commit 阶段将 change list 更新到 dom 上 不适合拆分是因为使用 vdom 的意义就是为了节省耗时的 dom 操作 生命周期React16.3 开启异步渲染 新增的两个 getDerivedStateFromProps触发时间(v16.4 修正)：组件每次被 render 的时候，包括在组件构建之后(虚拟 dom 之后，实际 dom 挂载之前)，每次获取新的 props 或 state 之后。在 v16.3 版本时，组件 state 的更新不会触发该生命周期。每次接收新的 props 之后都会返回一个对象作为新的 state，返回 null 则说明不需要更新 state.配合 componentDidUpdate，可以覆盖 componentWillReceiveProps 的所有用法getDerivedStateFromProps 是一个静态函数，所以函数体内不能访问 this，输出完全由输入决定。 getSnapshotBeforeUpdate 触发时间: update 发生的时候，在 render 之后，在组件 dom 渲染之前。返回一个值，作为 componentDidUpdate 的第三个参数。配合 componentDidUpdate, 可以覆盖 componentWillUpdate 的所有用法 setState可以接受函数为参数吗？有什么作用？123this.setState((prevState, props) =&gt; (&#123; counter: prevState.counter + props.increment&#125;)); 关于componentDidCatch的触发时机componentDidCatch()componentDidCatch(err, info)任何子组件在渲染期间，生命周期方法中或者构造函数 constructor 发生错误时调用。 错误边界不会捕获下面的错误： 事件处理 (Event handlers) （因为事件处理不发生在 React 渲染时，报错不影响渲染） 异步代码 (Asynchronous code) (e.g. setTimeout or requestAnimationFrame callbacks) 服务端渲染 (Server side rendering) 错误边界本身(而不是子组件)抛出的错误 补充：static getDerivedStateFromError此生命周期会在后代组件抛出错误后被调用。 它将抛出的错误作为参数，并返回一个值以更新 state,可以在此生命周期中 更新 state 使下一次渲染可以显降级 UI。getDerivedStateFromError() 会在渲染阶段调用，因此不允许出现副作用。 如遇此类情况，请改用 componentDidCatch() note: UNSAFE_componentWillMount() 在挂载之前被调用。它在 render() 之前调用，因此在此方法中同步调用 setState() 不会触发额外渲染。通常，我们建议使用 constructor() 来初始化 state。 react-router 的原理react-router的实现原理 createBrowserHistory: 利用 HTML5 里面的 history createHashHistory: 通过 hash 来存储在不同状态下的 history 信息 createMemoryHistory: 在内存中进行历史记录的存储 link组件跟a标签的区别有onclick那就执行onclickclick的时候阻止a标签默认事件（这样子点击123就不会跳转和刷新页面）再取得跳转href（即是to），用history（前端路由两种方式之一，history &amp; hash）跳转，此时只是链接变了，并没有刷新页面 伪代码实现1234567891011121314151617181920212223242526272829303132333435// createBrowserHistory(HTML5)中的前进实现function finishTransition(location) &#123; ... const historyState = &#123; key &#125;; ... if (location.action === 'PUSH') ) &#123; window.history.pushState(historyState, null, path); &#125; else &#123; window.history.replaceState(historyState, null, path) &#125;&#125;// createHashHistory的内部实现function finishTransition(location) &#123; ... if (location.action === 'PUSH') ) &#123; window.location.hash = path; &#125; else &#123; window.location.replace( window.location.pathname + window.location.search + '#' + path ); &#125;&#125;// createMemoryHistory的内部实现entries = [];function finishTransition(location) &#123; ... switch (location.action) &#123; case 'PUSH': entries.push(location); break; case 'REPLACE': entries[current] = location; break; &#125;&#125; vue 相关 为什么组件的 data 必须是一个函数为了让每一个实例维护一份返回对象的独立的拷贝，这样各个组件的 data 变化的时候互不影响 node相关 node文件查找机制总体流程其余的 参考文章 浅谈 instanceof 和 typeof 的实现原理 两个大数求和 深入 setstate 机制 大话 react 生命周期 2019：react-v16.3 新生命周期总结 react-router 的实现原理 社招中级前端笔试面试题总结 Why is React’s virtual DOM so much faster than the real DOM? 前端 100 问：能搞懂80%的请把简历给我","categories":[{"name":"面经","slug":"面经","permalink":"https://ashleyblog.xyz/categories/面经/"},{"name":"js","slug":"面经/js","permalink":"https://ashleyblog.xyz/categories/面经/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://ashleyblog.xyz/tags/js/"}]},{"title":"2019年度总结","slug":"2019年度总结","date":"2019-12-10T01:45:37.000Z","updated":"2023-04-02T14:00:30.300Z","comments":true,"path":"2019/12/10/2019年度总结/","link":"","permalink":"https://ashleyblog.xyz/2019/12/10/2019年度总结/","excerpt":"","text":"写给自己的准则 不管改动的文件再多，都要一个个检查，看有没有误改的地方，自己的改动有没有影响其他的功能 写代码前，请三思，请三思，请三思，不要急于动手 不要相信测试，一定要在上线之前用各种设备，各种大小的屏幕，各种浏览器，测试一遍所有相关的功能，所有可能出现的情况 一个功能一个分支，时刻保持与线上同步 多研究研究各种应用，站在用户的角度去测试而不是自己的角度 不明白的，容易记混的知识点要自己归纳总结，多动手，不要今天看几篇文章明天又忘了 晚上要睡好，避免第二天打瞌睡 写给2020年的自己 多动手写代码，多点工作之外的输出，巩固js基础，希望我能在这条路越走越远吧。。。","categories":[{"name":"成长","slug":"成长","permalink":"https://ashleyblog.xyz/categories/成长/"}],"tags":[]},{"title":"webpack常用配置速查","slug":"webpack常用配置速查","date":"2019-12-08T12:54:46.000Z","updated":"2023-04-02T14:00:30.291Z","comments":true,"path":"2019/12/08/webpack常用配置速查/","link":"","permalink":"https://ashleyblog.xyz/2019/12/08/webpack常用配置速查/","excerpt":"","text":"生产环境常用插件imagemin-webpack-plugin - 图片压缩插件123456789101112//引入插件var ImageminPlugin = require('imagemin-webpack-plugin').default;//配置plugins: [ new ImageminPlugin(&#123; disable: process.env.NODE_ENV !== 'production', // 开发时不启用 pngquant: &#123;//图片质量 quality: ... &#125; &#125;)] mini-css-extract-plugin - 依据每个entry生成单个css文件（将css从js中提取出来）12345678910111213// 将style-loader换成mini-css-extract.. use: [ &#123; loader: MiniCssExtractPlugin.loader &#125;, 'css-loader' ... ] ... new MiniCssExtractPlugin(&#123; filename: 'static/css/[name].[contenthash:8].css', chunkFilename: 'static/css/[name].[contenthash:8].chunk.css' // import() dynamically import &#125;) cleanwebpackplugin在webpack中打包的文件通常是通过hash生成的，如果文件改动，那么打包的文件就会越来越多,这个插件用来清除之前的文件 postcss-loader简介能够像less一样的自动补全浏览器前缀，需要与autoprefixer一起使用,PostCSS的一大特点是，允许使用最新的CSS特性，在你的CSS里提供统计数据，或者是允许你使用 Sass，Less或是Stylus等CSS预处理器。 postcss的生态圈提供了上百种插件Autoprefixer 根据用户的使用场景来解析CSS和添加vendor prefixes（前文注2）。 PostCSS Focus 一种利用键盘操作为每个:hover添加:focus选择器的PostCSS插件。 PreCSS 一个允许你在代码中使用类似Sass标记的插件。 Stylelint 一种强大的，先进的可以使你在CSS样式中保持一致性，避免错误的CSS linter工具。 PostCSS CSSnext 一种可以让你使用CSS最新特性的插件。它通过将最新的CSS特性转变为现阶段浏览器所兼容的特性，这样你不用再等待浏览器对某一特定新特性的支持。 … 使用需要结合postcss.config.js 12345678910111213141516171819202122// postcss.config.jsmodule.exports = &#123; plugins: [ require('precss'), require('autoprefixer') ]&#125;// webpack.config.js test: /\\.scss$/,&#123; loader: require.resolve('postcss-loader'), options: &#123; ident: 'postcss', plugins: () =&gt; [ require('postcss-flexbugs-fixes'), require('postcss-preset-env')(&#123; autoprefixer: &#123; flexbox: 'no-2009' &#125;, stage: 3 &#125;) ] terser-webpack-plugin - js压缩插件使用123456789101112131415optimization: &#123; ... minimize: true, minimizer: [ new TerserJSPlugin(&#123; terserOptions: &#123; output: &#123; comments: false &#125; &#125;, extractComments: false &#125;), new OptimizeCSSAssetsPlugin(&#123;&#125;) ] &#125; progress-bar-webpack-plugin简介显示build进度 123plugins: [ new ProgressBarPlugin()] optimize-css-assets-webpack-plugin - css压缩插件1234567891011plugins:[ ... new OptimizeCssAssetsPlugin(&#123; assetNameRegExp: /\\.optimize\\.css$/g, cssProcessor: require('cssnano'), cssProcessorPluginOptions: &#123; preset: ['default', &#123; discardComments: &#123; removeAll: true &#125; &#125;], &#125;, canPrint: true &#125;)] webpack-bundle-analyzer简介可以看到打包之后各个文件的大小 之后可以做一些优化 1234567const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin; module.exports = &#123; plugins: [ new BundleAnalyzerPlugin() ]&#125; 开发环境常用插件HotModuleReplacementPlugin123plugins:...new webpack.HotModuleReplacementPlugin() friendly-errors-webpack-plugin - 友好的webpack错误提示123456789new FriendlyErrorsPlugin(&#123; compilationSuccessInfo: &#123; messages: ['You application is running here http://localhost:3000'], notes: ['Some additionnal notes to be displayed unpon successful compilation'] &#125;, onErrors: function (severity, errors) &#123; // You can listen to errors transformed and prioritized by the plugin // severity can be 'error' or 'warning' &#125; 基础配置htmlwebpackpluginhttps://juejin.im/post/5ce96ad7e51d455a2f2201e1 12345678910111213141516171819202122new HtmlWebpackPlugin(&#123; inject: true, excludeAssets: [...], chunks: [page.toLowerCase()].concat( isEnvProduction ? ['assets', 'vendors'...] : [] ), templateParameters: ..., minify: isEnvProduction &amp;&amp; &#123; removeComments: true, collapseWhitespace: true, removeRedundantAttributes: true, useShortDoctype: true, removeEmptyAttributes: true, removeStyleLinkTypeAttributes: true, keepClosingSlash: true, minifyJS: true, minifyCSS: true, minifyURLs: true &#125;, filename: ... template: ... &#125;) 参考文章 关于 PostCSS 普及的一点微小的工作","categories":[{"name":"配置","slug":"配置","permalink":"https://ashleyblog.xyz/categories/配置/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://ashleyblog.xyz/tags/webpack/"}]},{"title":"前端性能优化","slug":"前端性能优化","date":"2019-11-07T04:09:10.000Z","updated":"2023-04-02T14:00:30.290Z","comments":true,"path":"2019/11/07/前端性能优化/","link":"","permalink":"https://ashleyblog.xyz/2019/11/07/前端性能优化/","excerpt":"","text":"前端性能优化最佳实践针对 spa 的性能优化 优化首屏渲染 将所有用于首屏渲染的 css 文件整合成一个内嵌到 head 标签，由于 http 数据包的限制，文件大小不能超过 14kbhttp/2 能让 css 文件使用单个文件存储，通过服务器推送 css 文件的传输方式减少 html 文件数据量 骨架屏 预加载 异步路由 路由拆分,减少初始加载体积: 利用异步加载方式，仅在需要进入对应路由时，对应组件才会被加载进来。 1234route(&#123; Home: () =&gt; import('@/coms/home'), About: () =&gt; import('@/coms/about')&#125;) 服务端渲染（SSR） 简单的来讲，就是浏览器发送请求到服务器端，服务器端处理请求，填充数据，生成 html 返回给浏览器 ,服务端必须是 node.js 或者专门跑个 node.js 来支持优势：更好的 SEO； 首屏性能好，不需要先下载一堆 js 和 css 后才能看到页面劣势：不能实现部分更新。即使只有一部分变动，也需要后端重新返回整个页面给浏览器。 其他重绘 回流的概念 repaint，就是浏览器得知元素产生了不影响排版的情况下后对这个元素进行重新绘制的过程。例如我们改变了元素的颜色，加个下划线等。 reflow, 浏览器得知元素产生了对文档树排版有影响的样式变化，对所有受影响的dom节点进行重新排版工作* 减少回流 回流的发生：1、DOM 树的结构变化，如添加或删除元素。（当新增多个元素的时候使用文档碎片）包括设置 display:none 设置 visibility 只会触发重绘2、元素的几何属性的改变（如 margin、padding、width、height、border 等）。3、页面初始化渲染。4、获取某些属性，浏览器为取得准确的值也会触发回流（offsetTop、clientTop、scrollTop、getComputedSyle()等等）。5、浏览器窗口尺寸的改变 为什么获取某些属性会触发回流？由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列。但是！当你获取布局信息的操作的时候，会强制队列刷新，比如当你访问以下属性或者使用以下方法： offsetTop、offsetLeft、offsetWidth、offsetHeight scrollTop、scrollLeft、scrollWidth、scrollHeight clientTop、clientLeft、clientWidth、clientHeight getComputedStyle() getBoundingClientRect 以上属性和方法都需要返回最新的布局信息，因此浏览器不得不清空队列，触发回流重绘来返回正确的值。 怎么避免 对于复杂的动画效果，让其绝对定位 避免多次访问上述的属性 使用类名 使用 csstext 当添加插入大量的元素的时候 使用文档碎片或者是在父元素在被插入之前设置display:none让其脱离文档流 之后再带回文档流 硬件加速，使用 css3 硬件加速，可以让 transform、opacity、filters 这些动画不会引起回流重绘 。但是对于动画的其它属性，比如 background-color 这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能 常见的触发硬件加速的 css 属性：transform,opacity,filters,Will-change 使用控制台的performance监测页面的性能（原来的 timeline）使用指南：https://www.cnblogs.com/xiaohuochai/p/9182710.html 其他 复杂的计算使用web workers 事件委托 正则表达式不要过于复杂 使用 webpack 优化 优化图片 - 使用url-loader 设置limit 大的图转成base64 使用各种插件压缩代码 tree-shaking是什么？用于描述移除 JavaScript 上下文中的未引用代码怎么做？ 使用 ES2015 模块语法（即 import 和 export）。确保没有 compiler 将 ES2015 模块语法转换为 CommonJS 模块（这也是流行的 Babel preset 中 @babel/preset-env 的默认行为 \\ 123456789101112// 配置 Babel 让其保留 ES6 模块化语句 // babelrc&#123; \"presets\": [ [ \"env\", &#123; \"modules\": false &#125; ] ]&#125; 在项目 package.json 文件中，添加一个 “sideEffects” 属性。比如polyfill等 只要引入 就会产生副作用 当该属性设置为false的时候会删除所有未引用的文件 所以polyfill需要声明sideeffects,true 是默认值，如果不指定其他值的话。这意味着所有的文件都有副作用，也就是没有一个文件可以 tree-shaking。 123456789101112131415// 所有文件都有副作用，全都不可 tree-shaking&#123; \"sideEffects\": true&#125;// 没有文件有副作用，全都可以 tree-shaking&#123; \"sideEffects\": false&#125;// 只有这些文件有副作用，所有其他文件都可以 tree-shaking，但会保留这些文件&#123; \"sideEffects\": [ \"./src/file1.js\", \"./src/file2.js\" ]&#125; 通过将 mode 选项设置为 production，启用 minification(代码压缩) 和 tree shaking。开启 optimization.usedExports,编译时可以分析出解构写法引入的esm模块，哪些export用到了，哪些模块没有用到。然后就需要分别进行标记,标记如下 并使用压缩插件压缩代码 webpack4 mode为production时候默认就有这两个设置 123/* harmony export (immutable) */ __webpack_exports__[\"xxx\"] = xxxx;/* unused harmony export xxx */ 标记为这个就是需要删掉的 以上述方式声明sideeffects会出现的问题：以import &#39;xxx.css直接导入到 JavaScript 文件中的样式表都将从输出中删除解决办法是：webpack的配置文件中 123456789module: &#123; rules: [ &#123; test: /...css.../, use: [loaders], sideEffects: true &#125; ]&#125; 引入的时候使用解构赋值 不用的依赖及时删除 external 把我们的依赖申明为一个外部依赖，外部依赖通过 &lt; script&gt; 外链脚本引入。 optimization 配置细节https://imweb.io/topic/5b66dd601402769b60847149 alias 和 noParse当需要将这个外部依赖打包进入到你的 bundle 的时候 1234567891011121314module.exports = function(webpackConfig) &#123; ...+ webpackConfig.resolve.alias = &#123;+ 'react': 'react/dist/react.min'+ &#125;+ webpackConfig.module.noParse.push(+ /react.min/+ ) ... return webpackConfig;&#125;; 其他 - 优化SEO重要的内容放在首页 因为爬虫会先从首页开始爬提交sitemap加快页面加载速度 提升搜索引擎排名… 参考文章 你真的了解回流和重绘吗 Webpack 构建性能优化探索","categories":[{"name":"性能优化","slug":"性能优化","permalink":"https://ashleyblog.xyz/categories/性能优化/"}],"tags":[]},{"title":"css中宽高的新值复习","slug":"css中宽高的新值复习","date":"2019-10-17T13:50:15.000Z","updated":"2023-04-02T14:00:30.295Z","comments":true,"path":"2019/10/17/css中宽高的新值复习/","link":"","permalink":"https://ashleyblog.xyz/2019/10/17/css中宽高的新值复习/","excerpt":"","text":"fill-available 出现fill-available关键字值的价值在于，可以让元素的100%自动填充特性不仅仅在block水平元素上，也可以应用在其他元素利用它实现等高布局 123456789101112131415&lt;style&gt;.inner&#123; width:100px; height:-webkit-fill-available; margin:0 10px; display: inline-block; vertical-align: middle; background-color: pink;&#125;&lt;/style&gt;&lt;div style=\"height: 100px;\"&gt; &lt;div class=\"inner\"&gt;HTML&lt;/div&gt; &lt;div class=\"inner\"&gt;CSS&lt;/div&gt; &lt;div class=\"inner\"&gt;JS&lt;br&gt;jQyery&lt;br&gt;Vue&lt;/div&gt;&lt;/div&gt; max-contentfit-content uses max-content, unless available &lt; max-content, then it uses available. Unless available &lt; min-content, then it uses min-content. 12345678910&lt;style&gt;.outer&#123; width:-webkit-max-content; border:1px solid black;&#125;&lt;/style&gt;&lt;div class=\"outer\"&gt; &lt;div style=\"height:10px;width:100px;background:lightgreen\"&gt;&lt;/div&gt; &lt;div style=\"background-color: pink;\"&gt;测试测试测试测试测试测 hi 是测试测试测试测你测试测试测试测试&lt;/div&gt;&lt;/div&gt; 每日小知识点 关于下载的文件的后缀你在网上下载一个很大的文件，下载过程中你怎么知道自己下载的对不对呢？所以MD5 就是为了这种情景而生的。即网上的文件除了有资源本身外，还会有一个MD5值，然后你下载到本地后的文件也可以算出一个MD5 值，然后二者对比，如果完全相同则说明下的文件是正确的。 参考文章 浏览器缓存控制详解（cookie、session、localStorage、Cache-Control等","categories":[],"tags":[{"name":"css","slug":"css","permalink":"https://ashleyblog.xyz/tags/css/"}]},{"title":"控制react的state为合法状态","slug":"控制react的state为合法状态","date":"2019-10-14T14:58:27.000Z","updated":"2023-04-02T14:00:30.292Z","comments":true,"path":"2019/10/14/控制react的state为合法状态/","link":"","permalink":"https://ashleyblog.xyz/2019/10/14/控制react的state为合法状态/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031const zipList = initialArray =&gt; &#123; const [initialActive, ...restOfTabs] = initialArray const zip = &#123; previous: [], current: initialActive, next: restOfTabs, &#125; const setActive = zip =&gt; newActive =&gt; &#123; // TODO: fill this in const newZip = zip return apiForZip(newZip) &#125; const apiForZip = zip =&gt; (&#123; asArray: () =&gt; [...zip.previous, zip.current, ...zip.next], isActive: tab =&gt; zip.current === tab, setActive: setActive(zip), activeTab: () =&gt; zip.current, &#125;) return apiForZip(zip)&#125;const [tabs, setTabs] = React.useState( zipList([ &#123; title: 'Tab One', content: 'This is tab one' &#125;, &#123; title: 'Tab Two', content: 'This is tab two' &#125;, &#123; title: 'Tab Three', content: 'This is tab three' &#125;, ])) 每日小知识点 字体的旋转将字体设置成display:block即可 run build文件夹（为了更接近线上的效果）使用http-server工具 执行命令: （原理是puputeer抓取build下的资源 然后。。 1http-server build/ project name 尽量不要使用push跳转路由 因为这种动态的方式不利于ssr git config -list 查看当前项目的git配置 请求被重定向 （network出现…html…很长的路径 并被canceled） 可能是后端正在部署到新的服务器 每日bug记录 请求返回500 发现是传的参数的格式不对 应该是form表单的形式 而不是application/json格式 虽然API文档中没有标出 但是也要注意 发现重新进入页面加载数据的时候没有出现loading 是因为数据存储在mobx中 没有刷新被清除 所以要在每次请求之前清除一次或者是不走mobx流程 父层叠上下文中的子层叠上下文 12345678...position:relative /* 父 */...position:absolutez-index:2 /*子*/...position:absolutez-index:1 /* 叔叔 */ 最后还是叔叔显示在子节点的上面 因为子层叠上下文属于父层叠上下文 table 设置flex布局 td元素不会自动填充满tbody node exec不执行回调函数 1234var exec = require('child_process').exec;exec(\"&#123;COMMAND&#125; &gt; results.log\", function (error, stdout, stderr) &#123; console.log('callback called!'); // this never gets called.&#125;); 是因为重定向到了另一个文件 *","categories":[],"tags":[]},{"title":"sass中的map和list","slug":"sass中的map","date":"2019-10-11T12:28:00.000Z","updated":"2023-04-02T14:00:30.297Z","comments":true,"path":"2019/10/11/sass中的map/","link":"","permalink":"https://ashleyblog.xyz/2019/10/11/sass中的map/","excerpt":"","text":"map简介类似于 js 中的 map 数据结构 主要函数 函数 功能 示例 map-keys(map) 返回 map 里面所有的 key(list) map-keys((“foo”: 1, “bar”: 2)) =&gt; “foo”, “bar” map-values(map) 返回 map 里面所有的 value(list) map-values((“foo”: 1, “bar”: 2)) =&gt; 1, 2 map-get(map,key) 返回 map 里面指定可以的 value map-get((“foo”: 1, “bar”: 2), “foo”) =&gt; 1 map-has-key(map,key) 返回 map 里面是否含有指定的 key map-has-key((“foo”: 1, “bar”: 2), “foo”) =&gt; true map-merge(map1,map2) 合并 map(map) map-merge((“foo”: 1), (“bar”: 2)) =&gt; (“foo”: 1, “bar”: 2) map-remove(map,keys) 删除指定 map 中的指定 key(map) map-remove((“foo”: 1, “bar”: 2), “bar”) =&gt; (“foo”: 1) keywords(args) 返回一个函数参数组成的 map(map) @mixin foo(args…){@debug keywords($args); //=&gt; (arg1: val, arg2: val)} list简介类似js中的数组 12345$list: ( (\"item-1.1\", \"item-1.2\", \"item-1.3\"), (\"item-2.1\", \"item-2.2\", \"item-2.3\"), (\"item-3.1\", \"item-3.2\", \"item-3.3\") ); 方法 length 检测其长度： 1length($a) =&gt; 1 nth 获取第n项： 1nth($a,1) =&gt; test index($list,$value)：返回$value在$list中的位置 append($list,$value[,$separator])：使用$separator分隔符将$value列表项添加到$list最后（如果没有显式指定 $separator分隔符，会以当前分隔符分隔） join($list-1,$list-2[,$separator]):使用$separator分隔符将$list-2附加到$list-1（如果没有显式指定分隔符，将对* $list-1中的分隔符） zip($lists):将多个$list组合在一起成为一个多维列表。如果列表源长度并不是所有都相同，结果列表长度将以最短的一个为准 reject($list,$value)：这是Compass中的一个函数，将$value值从$list中删除 compact(*$args)：Compass函数，返回一个删除非真值的新列表 list应用 扩展选择器 如:1234.home .nav-home,.about .nav-about,.products .nav-products,.contact .nav-contact 12345678$pages: home,about,products,contact;$selector:();@each $item in $pages &#123; //我们创建$selector&#125;#&#123;$selector&#125;&#123; //样式写在这里&#125; 自定义函数123456789//定义first()函数，获取列表中的第一个列表项@function first($list)&#123; @return nth($list,1);&#125;//定义last()函数，获取列表中的最后一个列表项@function last($list)&#123; @return nth($list,length($list));&#125; 每日小知识点 unquote 用来去除字符串中的引号 quote 给字符串增加引号 传递内容块到 mixin: @content 12345678910@mixin apply-to-ie6-only &#123; * html &#123; @content; &#125;&#125;@include apply-to-ie6-only &#123; #logo &#123; background-image: url(/logo.gif); &#125;&#125; target 伪类可以在不新增类名的时候直接实现标签页的效果原理： 也就是给一个元素 A 设定 id，另一个元素 B 指定跳转到这个 id，然后就向 a:hover 那样，在 css 中设定 “元素：target”并改变样式，那么点击 B 元素，就会根据你的设定改变 A 的样式。 123456789101112&lt;div class=\"swiper-box\"&gt; &lt;div class=\"swiper-cont\"&gt; &lt;div class=\"swiper1\" id=\"swiper1\"&gt;&lt;/div&gt; &lt;div class=\"swiper2\" id=\"swiper2\"&gt;&lt;/div&gt; &lt;div class=\"swiper3\" id=\"swiper3\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"swiper-num\"&gt; &lt;a href=\"#swiper1\"&gt;1&lt;/a&gt; &lt;a href=\"#swiper2\"&gt;2&lt;/a&gt; &lt;a href=\"#swiper3\"&gt;3&lt;/a&gt; &lt;/div&gt;&lt;/div&gt; focus:within 伪类 应用于当子元素中出现获得焦点的元素时候 123&lt;div&gt; &lt;input /&gt;&lt;/div&gt; 12div:focus:within &#123;&#125; css 伪类与伪元素css 伪类css 伪类用于向某些选择器添加特殊的效果。:link, :visited, :hover, :focus, :active, :first-child, :langcss3 新增的伪类：:last-child, :only-child, :first-of-type, :last-of-type, :only-of-type, :nth-child(n), :nth-last-child(n), :nth-of-type(n), :nth-last-of-type(n), :root, :empty, :target, :enabled, :disabled, :checked, :not(selector), css 伪元素css 伪元素用于向某些选择器设置特殊效果。::first-letter, ::first-line, ::before, ::aftercss3 新增的伪元素::selection 通过 first-letter text-transform: uppercase text-transform: lowercase控制大小写 每日 bug 记录 max-height 设置 transition 的时候不生效 是因为 max-height 设置了一个很大的范围 比如从 0 到 1000 而实际的内容高度只有 100 那么剩下的时间大都是在滚动这 900 使用 js 设置元素的行内样式可以应用样式表中的 transition git 冲突的理解只有当同时修改了某个文件的时候才会出现冲突 要是本地的状态是 nothing commit git pull 的时候会直接覆盖掉本地的文件 git merge 的理解从父分支切出子分支 子分支 pull 父分支 子分支上的代码会与父分支保持一致 但是父分支 merge 子分支 父分支的内容不一定要与子分支保持一致 在一个hooks里面维护一份state 然后在另一个组件中setState 一个组件中获取state 两个组件的state并不会同步","categories":[{"name":"sass","slug":"sass","permalink":"https://ashleyblog.xyz/categories/sass/"}],"tags":[{"name":"sass css","slug":"sass-css","permalink":"https://ashleyblog.xyz/tags/sass-css/"}]},{"title":"ts小知识点","slug":"ts小知识点","date":"2019-10-11T12:28:00.000Z","updated":"2023-04-02T14:00:30.291Z","comments":true,"path":"2019/10/11/ts小知识点/","link":"","permalink":"https://ashleyblog.xyz/2019/10/11/ts小知识点/","excerpt":"","text":"用 keyof 来约定方法的参数 123456789101112export type keys = &#123; name: string; appId: number; config: object;&#125;class Application &#123; // 参数和值约束范围 set&lt;T extends keyof keys&gt;(key: T, val: keys[T]) get&lt;T extends keyof keys&gt;(key: T): keys[T]&#125;---- interface vs type我们可以使用 in 来约束属性名必须为三家运营商之一： 123456789101112type ChinaMobilePhones = '10086' | '10010' | '10000'interface ChinaMobile &#123; name: string; website: string;&#125;// 只能 type 使用， interface 无法使用type ChinaMobileList = &#123; // 遍历属性 [phone in ChinaMobilePhones]: ChinaMobile&#125; 类型定义文件在 TypeScript 中，我们可以很简单的，在代码编写中定义类型： 123456interface IBaseModel &#123; say(keys: string[] | null): object&#125;class User implements IBaseModel &#123; name: string 但是主流的库都是 JavaScript 编写的，TypeScript 身为 JavaScript 的超集，自然需要考虑到如何让 JS 库也能定义静态类型。 TypeScript 经过了一系列的摸索，先后提出了 tsd(已废弃)、typings(已废弃)，最终在 TypeScript 2.0 的时候重新整理了类型定义，提出了 DefinitelyTyped。 DefinitelyTyped 就是让你把 “类型定义文件(*.d.ts)”，发布到 npm 中，配合编辑器(或插件)，就能够检测到 JS 库中的静态类型。 类型定义文件的以 .d.ts 结尾，里面主要用来定义类型。比如： 因为这几个库是 js 的，没有 ts 的类型声明也没有好的@types/对应的库 123declare module 'classnames';declare module 'htmr';declare module 'showdown-katex'; 内置类型定义就是把你的类型定义文件和 npm 包一起发布 123456789// pageage.json&#123; \"name\": \"demo\", \"author\": \"demo project\", \"version\": \"1.0.0\", \"main\": \"./lib/main.js\", // 定义主类型定义文件 \"types\": \"./lib/main.d.ts\"&#125; 定义数组的类型为第一项是函数 其余的是对象 12345678910interface Arglist &#123; [index: number]: object 0: Function&#125;const a1: Arglist = [func]const a2: Arglist = [22] // failsconst a3: Arglist = [func, 'foo']// 方式二type FAs = [Function, &#123;&#125;] 继承的时候排除父接口中的一部分属性 123export type Omit&lt;T, K extends keyof T&gt; = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;export interface ICollapseProps extends Omit&lt;React.HTMLAttributes&lt;HTMLUListElement&gt;,\"title\"&gt; react.cloneElement的正确用法 123cloneElement(children as React.ReactElement&lt;any&gt;, &#123; ref, type: hasError ? 'error' : 'default', index signature 索引签名适用于无法确定属性名称的场景123interface NetCache &#123; [propName: string]: string;&#125; useImmperativeHandle 结合 需要定义静态属性的组件 组件的定义应该如下 123456export interface IMessage extends React.ForwardRefExoticComponent&lt;IMessageProps &amp; React.RefAttributes&lt;HTMLDivElement | refType&gt;&gt; &#123;// 使用 const ref = createRef&lt;refType &amp; HTMLDivElement&gt;() &lt;Message ref=&#123;ref&#125;/&gt; Using a forwardRef component with children in TypeScript 1234567891011121314import * as React from 'react'type ButtonProps = React.HTMLProps&lt;HTMLButtonElement&gt; or React.ComponentPropsWithoutRef&lt;'button'&gt;const FancyButton = React.forwardRef&lt;HTMLButtonElement, ButtonProps&gt;((props, ref) =&gt; ( &lt;button type=\"button\" ref=&#123;ref&#125; className=\"FancyButton\"&gt; &#123;props.children&#125; &lt;/button&gt;))// You can now get a ref directly to the DOM button:const ref = React.createRef&lt;HTMLButtonElement&gt;()&lt;FancyButton ref=&#123;ref&#125;&gt;Click me!&lt;/FancyButton&gt; 结论当报错的时候一定要仔细看错误 然后多试一试","categories":[{"name":"ts","slug":"ts","permalink":"https://ashleyblog.xyz/categories/ts/"}],"tags":[{"name":"ts","slug":"ts","permalink":"https://ashleyblog.xyz/tags/ts/"}]},{"title":"2019春招回顾","slug":"面试题回顾春招","date":"2019-08-14T14:38:11.000Z","updated":"2023-04-02T14:00:30.299Z","comments":true,"path":"2019/08/14/面试题回顾春招/","link":"","permalink":"https://ashleyblog.xyz/2019/08/14/面试题回顾春招/","excerpt":"","text":"使用 Linux 命令模拟发起一个请求1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162一、get请求： 1、使用curl命令：// 在终端敲下该命令之后回车会出现响应内容 curl “http://www.baidu.com” 如果这里的URL指向的是一个文件或者一幅图都可以直接下载到本地 curl -i “http://www.baidu.com” 显示全部信息 curl -l “http://www.baidu.com” 只显示头部信息 curl -v “http://www.baidu.com” 显示get请求全过程解析 2、使用wget命令： wget “http://www.baidu.com”也可以二、post请求 1、使用curl命令（通过-d参数，把访问参数放在里面）： curl -d “param1=value1¶m2=value2” “http://www.baidu.com” 2、使用wget命令：（--post-data参数来实现） wget --post-data ‘user=foo&amp;password=bar’ http://www.baidu.com 以上就是Linux模拟Http的get或post请求的方法了，这样一来Linux系统也能向远程服务器发送消息了。## 防抖节流# Throttle and debounce## Throttle （函数节流）### Throttle 定义就是指连续触发事件后在 n 秒内函数只能执行一次如果将水龙头拧紧直到水是以水滴的形式流出，那你会发现每隔一段时间，就会有一滴水流出。也就是会说预先设定一个执行周期，当调用动作的时刻大于等于执行周期则执行该动作，然后进入下一个新周期```js/** * 频率控制 返回函数连续调用时，action 执行频率限定为 次 / delay * @param delay &#123;number&#125; 延迟时间，单位毫秒 * @param action &#123;function&#125; 请求关联函数，实际应用需要调用的函数 * @return &#123;function&#125; 返回客户调用函数 */var throttle = function(delay, action) &#123; var last = 0; return function() &#123; var curr = +new Date(); if (curr - last &gt; delay) &#123; action.apply(this, arguments); last = curr; &#125; &#125;;&#125;; 版本二： 1234567891011121314151617181920function throttle(fun, delay) &#123; let last, deferTimer; return function(args) &#123; let that = this; let _args = arguments; let now = +new Date(); if (last &amp;&amp; now &lt; last + delay) &#123; clearTimeout(deferTimer); // 保证一定会执行一次 这就是跟防抖不一样的地方 deferTimer = setTimeout(function() &#123; last = now; fun.apply(that, _args); &#125;, delay); &#125; else &#123; // 第一次或者当时间间隔达到要求的时候会执行函数 last = now; fun.apply(that, _args); &#125; &#125;;&#125; 比如搜索框 当用户输入频繁的时候 Debounce (函数去抖)Debounce 定义就是指触发事件后在 n 秒内函数只能执行一次（最后一次），如果在 n 秒内又触发了事件，则会重新计算函数执行时间。 如果用手指一直按住一个弹簧，它将不会弹起直到你松手为止。 也就是说当调用动作 n 毫秒后，才会执行该动作，若在这 n 毫秒内又调用此动作则将重新计算执行时间 123456789101112131415161718/** * 空闲控制 返回函数连续调用时，空闲时间必须大于或等于 idle，action 才会执行 * @param idle &#123;number&#125; 空闲时间，单位毫秒 * @param action &#123;function&#125; 请求关联函数，实际应用需要调用的函数 * @return &#123;function&#125; 返回客户调用函数 */var debounce = function(idle, action) &#123; var last; return function() &#123; var ctx = this, args = arguments; clearTimeout(last); last = setTimeout(function() &#123; action.apply(ctx, args); &#125;, idle); &#125;;&#125;; 区别 debouncesearch 搜索联想，用户在不断输入值时，用防抖来节约请求资源。window 触发 resize 的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次 throttle鼠标不断点击触发，mousedown(单位时间内只触发一次)监听滚动事件，比如是否滑到底部自动加载更多，用 throttle 来判断 vue 的路由如何实现，最后提到了服务器端渲染，解释其过程 前端路由实现的就是匹配不同的 url 路径，进行解析，然后动态的渲染出区域 html 内容 hash 模式。hash 值变化，浏览器不发出请求，但是会触发 hashchange 这个事件， 通过这个事件我们就可以知道 hash 值发生了哪些变化，来更新页面内容 1234function matchAndUpdate() &#123; // todo 匹配 hash 做 dom 更新操作&#125;window.addEventListener(\"hashchange\", matchAndUpdate); history 模式. pushState 和 replaceState 分别可以添加和修改历史记录条目,通过这两个 API 可以改变 url 地址且不会发送请求,当用户刷新页面之类的操作时，浏览器还是会给服务器发送请求。为了避免出现这种情况，所以这个实现需要服务器的支持，需要把所有路由都重定向到根页面。当处于激活状态的历史记录条目发生变化时,popstate 事件就会在对应 window 对象上触发 animation transition的区别 transition 动画可以通过事件监听启动和完成transitionstart、transitionrun、transitionend,transition 动画有几个局限： 需要通过用户的行为（如点击，悬浮等）触发，所以没法在网页加载时自动发生 是一次性的，不能重复发生 只能定义开始状态和结束状态，不能定义中间状态，也就是说只有两个状态。 keyframes: 关键帧 keyframe 自定义动画,能够自定义任意阶段的动画动作。 animation 在不需要触发事件的情况下，也可以随时间变化来改变元素 CSS 属性。 可以指定动画具体播放的次数 可以指定各个阶段的状态，而不是只有开始和结尾。 介绍 requestAnimateFrame，与 setInterval 或 setTimeout 的区别 setTimeout: seTimeout 实现的动画容易出现卡顿、抖动的现象，有两个原因可能会导致丢帧： setTimeout 的执行时间并不是确定的, setTimeout 任务被放进了异步队列中，只有当主线程上的任务执行完以后，才会去检查该队列里的任务是否需要开始执行，所以 setTimeout 的实际执行时机一般要比其设定的时间晚一些。 刷新频率受 屏幕分辨率 和 屏幕尺寸 的影响，不同设备的屏幕绘制频率可能会不同，而 setTimeout 只能设置一个固定的时间间隔，这个时间不一定和屏幕的刷新时间相同。 requestAnimateFrame：请求浏览器在下一次重绘之前调用指定的函数来更新动画,回调的次数通常是每秒 60 次,返回一个 long 整数，请求 ID，可以传这个值给 window.cancelAnimationFrame() 以取消回调函数. 最大的优势是rAF 的执行步伐跟着浏览器的绘制频率走，这样就不会引起丢帧现象，也不会导致动画出现卡顿的问题。 js 为什么要单线程的 在多线程操作的情况下可以实现应用的并行处理，而提高整个应用程序的性能和吞吐量，更大粒度的榨取本机的 CPU 利用率，特别是现代很多语言都支持了多核并行处理技术。JavaScript 是单线程执行，因为如果 JavaScript 是多线程的方式来操作 UI，则可能出现 UI 操作的冲突, 如果引入一些锁的机制来解决这些冲突，则容易引入更大的复杂性，所以 JavaScript 从开始就选择了单线程执行。 ## 同步与非同步 阻塞非阻塞 并发并行的区别用普通的水壶烧，人在边上看着，水开了再去看球。（同步，阻塞）这个是常规做法，但是我看球不爽了。用普通水壶烧，人去看球，隔几分钟去厨房看看。（同步，非阻塞）这个又大问题，万一在我离开的几分钟水开了，我就麻烦了。用会叫的水壶，人在边上看着。（异步，阻塞）这个没有问题，但是我太傻了。用会叫的水壶，人去看球，听见水壶叫了再去看。（异步，非阻塞）这个应该是最好的。等着看球的我：阻塞 看着电视的我：非阻塞 普通水壶：同步 会叫的水壶：异步 (内核会通知) 同步过程中进程触发 IO 操作并等待或者轮询的去查看 IO 操作是否完成。异步过程中进程触发 IO 操作以后，直接返回，做自己的事情，IO 交给内核来处理，完成后内核通知进程 IO 完成。 阻塞 阻塞的概念往往伴随着线程。阻塞一般是指：在调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会被唤醒执行后续的操作。 非阻塞 那么非阻塞，毫无疑问是阻塞的反向操作。非阻塞式的调用指：在结果没有返回之前，该调用不会阻塞住当前线程。 并发：当有多个线程在操作时，如果系统只有一个 CPU，操作系统只能把 CPU 运行时间划分成若干个时间段,再将时间段分配给各个线程执行，在一个时间段的快速的切换不同的线程代码运行。 并行：当系统有多个 CPU 时，可以存在当一个 CPU 执行一个线程时，另一个 CPU 可以执行另一个线程，两个线程互不抢占 CPU 资源，可以同时进行。 nodejs 中的阻塞非阻塞阻塞，读取文件同步 I/O 操作，等待文件读取完再进行其他操作。 非阻塞，读取文件是异步回调，在等待文件读取时可以进行其他操作，这就大大提高了 Node.js 的性能，可以处理大量的并发请求。 react 的 filber （16.3之后开启异步渲染) 在 fiber 中，更新是分阶段的，具体分为两个阶段，首先是 reconciliation 的阶段，这个阶段在计算前后 dom 树的差异，然后是 commit 的阶段，这个阶段将把更新渲染到页面上。第一个阶段是可以打断的，因为这个阶段耗时可能会很长，因此需要暂停下来去执行其他更高优先级的任务，第二个阶段则不会被打断，会一口气把更新渲染到页面上。 由于 reconciliation 的阶段会被打断，可能会导致 commit 前的这些生命周期函数多次执行。react 官方目前已经把 componentWillMount、componentWillReceiveProps 和 componetWillUpdate 标记为 unsafe，并使用新的生命周期函数 getDerivedStateFromProps 和 getSnapshotBeforeUpdate 进行替换。 组件的渲染被分为两个阶段：第一个阶段（也叫做 render 阶段）是可以被 React 打断的，一旦被打断，这阶段所做的所有事情都被废弃，当 React 处理完紧急的事情回来，依然会重新渲染这个组件，这时候第一阶段的工作会重做一遍；第二个阶段叫做 commit 阶段，一旦开始就不能中断，也就是说第二个阶段的工作会稳稳当当地做到这个组件的渲染结束。 两个阶段的分界点，就是 render 函数。render 函数之前的所有生命周期函数（包括 render)都属于第一阶段，之后的都属于第二阶段。render 之前的生命周期函数（也就是第一阶段生命周期函数）包括这些： componentWillReceiveProps shouldComponentUpdate componentWillUpdate componentWillMount render getDerivedStateFromProps 应该是一个纯函数，React 就是通过要求这种纯函数，强制开发者们必须适应异步渲染。 reconciliation 阶段虚拟 dom 的数据对比 commit 阶段将 change list 更新到 dom 上 不适合拆分是因为使用 vdom 的意义就是为了节省耗时的 dom 操作 linux常见命令 创建符号链接（类似windows的快捷方式) ln -s source_file symbolic_link 打开文件跳到第一个匹配的行 $ vim +/search-term filename.txt grep相关 1.在文件中查找字符串不区分大小写 $ grep -i “the” demo_file2.在一个文件夹中递归查询包含指定字符串的文件$ grep -r “ramesh” * 查找指定文件名的文件(不区分大小写) find -iname ‘..’ 登录到远程主机 $ ssh -l jsmith remotehost.example.com ps 1.查看当前正在运行的所有进程 $ ps -ef | more2.以树状结构显示当前正在运行的进程，H选项表示显示进程的层次结构$ ps -efH | more 显示当前系统中占用资源最多的一些进程top 查看所有网络接口及其状态 $ ifconfig -a 使用up和down命令启动或停止某个接口 $ ifconfig eth0 up $ ifconfig eth0 down 查找某个命令的位置 $ whereis cmd 不加载整个文件的前提下显示文件内容 (查看大型日志文件的时候) $ less 设置环境变量 $ export … cat追加a内容到文件b的末尾 $ cat a &gt; b cat覆盖原有文件的内容 $ cat a &gt;&gt; b curl命令相关 1.模仿浏览器 $ curl -A “Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.0)” http://www.linux.com2.伪造referer（盗链）$ curl -e “www.linux.com&quot; http://mail.linux.com3.利用curl下载文件使用内置option：-o(小写)$ curl -o dodo1.jpg http:www.linux.com/dodo1.JPG4.使用curl发送POST请求$ curl -d “user=admin&amp;passwd=12345678” http://127.0.0.1:8080/login 前端模块化CommonJs用在服务器端，AMD和CMD用在浏览器环境AMD:提前执行（异步加载：依赖先执行）+延迟执行CMD:延迟执行（运行到需加载，根据顺序执行） 移动端相关移动端点击 300ms 延迟是什么？怎样消除？为了双击缩放，页面点击会有 300ms 延迟解决方法，禁用缩放，更改默认的视口宽度&lt;meta name=”viewport” content=”user-scalable=no, initial-scale=1,maximum-scale=1, width=device-width”&gt;","categories":[],"tags":[{"name":"面经","slug":"面经","permalink":"https://ashleyblog.xyz/tags/面经/"}]},{"title":"前端文件上传","slug":"前端文件上传","date":"2019-06-14T13:28:11.000Z","updated":"2023-04-02T14:00:30.293Z","comments":true,"path":"2019/06/14/前端文件上传/","link":"","permalink":"https://ashleyblog.xyz/2019/06/14/前端文件上传/","excerpt":"","text":"上传文件的几种方式 普通表单上传使用 PHP 来展示常规的表单上传是一个不错的选择。首先构建文件上传的表单，并指定表单的提交内容类型为 enctype=”multipart/form-data”，表明表单需要上传二进制数据。 1234&lt;form action=\"/index.php\" method=\"POST\" enctype=\"multipart/form-data\"&gt; &lt;input type=\"file\" name=\"myfile\"&gt; &lt;input type=\"submit\"&gt;&lt;/form&gt; 文件编码上传第一个思路是将文件进行编码，然后在服务端进行解码，之前写过一篇在前端实现图片压缩上传的博客，其主要实现原理就是将图片转换成 base64 进行传递var imgURL = URL.createObjectURL(file);ctx.drawImage(imgURL, 0, 0);// 获取图片的编码，然后将图片当做是一个很长的字符串进行传递var data = canvas.toDataURL(“image/jpeg”, 0.5); 除了进行 base64 编码，还可以在前端直接读取文件内容后以二进制格式上传 12345678910111213141516// 读取二进制文件function readBinary(text) &#123; var data = new ArrayBuffer(text.length) var ui8a = new Uint8Array(data, 0) for (var i = 0; i &lt; text.length; i++) &#123; ui8a[i] = text.charCodeAt(i) &amp; 0xff &#125; console.log(ui8a)&#125;var reader = new FileReader()reader.onload = function() &#123; readBinary(this.result) // 读取result或直接上传&#125;// 把从input里读取的文件内容，放到fileReader的result字段里reader.readAsBinaryString(file) 文件上传123456789101112131415161718192021222324252627282930313233343536373839404142434445function uploadAndSubmit() &#123;var form = document.forms[\"demoForm\"];if (form[\"file\"].files.length &gt; 0) &#123;// 寻找表单域中的 &lt;input type=\"file\" ... /&gt; 标签var file = form[\"file\"].files[0];// try sendingvar reader = new FileReader();reader.onloadstart = function() &#123;// 这个事件在读取开始时触发console.log(\"onloadstart\");document.getElementById(\"bytesTotal\").textContent = file.size;&#125;reader.onprogress = function(p) &#123;// 这个事件在读取进行中定时触发console.log(\"onprogress\");document.getElementById(\"bytesRead\").textContent = p.loaded;&#125;reader.onload = function() &#123; // 这个事件在读取成功结束后触发console.log(\"load complete\");&#125;reader.onloadend = function() &#123; // 这个事件在读取结束后，无论成功或者失败都会触发if (reader.error) &#123;console.log(reader.error);&#125; else &#123;document.getElementById(\"bytesRead\").textContent = file.size;// 构造 XMLHttpRequest 对象，发送文件 Binary 数据var xhr = new XMLHttpRequest();xhr.open(/* method */ \"POST\",/* target url */ \"upload.jsp?fileName=\" + file.name/*, async, default to true */);// 二进制流// 指定一个MIME类型用于替代服务器指定的类型，使服务端响应信息中传输的数据按照该指定MIME类型处理xhr.overrideMimeType(\"application/octet-stream\");xhr.sendAsBinary(reader.result);xhr.onreadystatechange = function() &#123;if (xhr.readyState == 4) &#123;if (xhr.status == 200) &#123;console.log(\"upload complete\");console.log(\"response: \" + xhr.responseText); formData 异步上传FormData 对象主要用来组装一组用 XMLHttpRequest 发送请求的键/值对，可以更加灵活地发送 Ajax 请求。可以使用 FormData 来模拟表单提交。 1234let files = e.target.files // 获取 input 的 file 对象let formData = new FormData()formData.append('file', file)axios.post(url, formData) 大文件上传大文件上传最主要的问题就在于：在同一个请求中，要上传大量的数据，导致整个过程会比较漫长，且失败后需要重头开始上传。试想，如果我们将这个请求拆分成多个请求，每个请求的时间就会缩短，且如果某个请求失败，只需要重新发送这一次请求即可，无需从头开始，这样是否可以解决大文件上传的问题呢？ 文件切片参考： 大文件切割上传编码方式上传中，在前端我们只要先获取文件的二进制内容，然后对其内容进行拆分，最后将每个切片上传到服务端即可。在 JavaScript 中，文件 FIle 对象是 Blob 对象的子类，Blob 对象包含一个重要的方法 slice，通过这个方法，我们就可以对二进制文件进行拆分。下面是一个拆分文件的示例 123456789101112131415161718192021222324252627function slice(file, piece = 1024 * 1024 * 5) &#123; let totalSize = file.size; // 文件总大小 let start = 0; // 每次上传的开始字节 let end = start + piece; // 每次上传的结尾字节 let chunks = [] while (start &lt; totalSize) &#123; // 根据长度截取每次需要上传的数据 // File对象继承自Blob对象，因此包含slice方法 let blob = file.slice(start, end); chunks.push(blob) start = end; end = start + piece; &#125; return chunks&#125;将文件拆分成piece大小的分块，然后每次请求只需要上传这一个部分的分块即可let file = document.querySelector(\"[name=file]\").files[0];const LENGTH = 1024 * 1024 * 0.1;let chunks = slice(file, LENGTH); // 首先拆分切片chunks.forEach(chunk=&gt;&#123; let fd = new FormData(); fd.append(\"file\", chunk); post('/mkblk.php', fd)&#125;) 断点续传即使将大文件拆分成切片上传，我们仍需等待所有切片上传完毕，在等待过程中，可能发生一系列导致部分切片上传失败的情形，如网络故障、页面关闭等。由于切片未全部上传，因此无法通知服务端合成文件。这种情况下可以通过断点续传来进行处理。断点续传指的是：可以从已经上传部分开始继续上传未完成的部分，而没有必要从头开始上传，节省上传时间。由于整个上传过程是按切片维度进行的，且 mkfile 接口是在所有切片上传完成后由客户端主动调用的，因此断点续传的实现也十分简单： 在切片上传成功后，保存已上传的切片信息当下次传输相同文件时，遍历切片列表，只选择未上传的切片进行上传所有切片上传完毕后，再调用 mkfile 接口通知服务端进行文件合并 因此问题就落在了如何保存已上传切片的信息了，保存一般有两种策略 可以通过 locaStorage 等方式保存在前端浏览器中，这种方式不依赖于服务端，实现起来也比较方便，缺点在于如果用户清除了本地文件，会导致上传记录丢失服务端本身知道哪些切片已经上传，因此可以由服务端额外提供一个根据文件 context 查询已上传切片的接口，在上传文件前调用该文件的历史上传记录下面让我们通过在本地保存已上传切片记录，来实现断点上传的功能 12345678910111213141516171819202122232425262728293031323334353637383940 // 获取已上传切片记录function getUploadSliceRecord(context)&#123; let record = localStorage.getItem(context) if(!record)&#123; return [] &#125;else &#123; try&#123; return JSON.parse(record) &#125;catch(e)&#123;&#125; &#125;&#125;// 保存已上传切片function saveUploadSliceRecord(context, sliceIndex)&#123; let list = getUploadSliceRecord(context) list.push(sliceIndex) localStorage.setItem(context, JSON.stringify(list))&#125;// 然后对上传逻辑稍作修改，主要是增加上传前检测是已经上传、上传后保存记录的逻辑let context = createContext(file);// 获取上传记录let record = getUploadSliceRecord(context);let tasks = [];chunks.forEach((chunk, index) =&gt; &#123; // 已上传的切片则不再重新上传 if(record.includes(index))&#123; return &#125; let fd = new FormData(); fd.append(\"file\", chunk); fd.append(\"context\", context); fd.append(\"chunk\", index + 1); let task = post(\"/mkblk.php\", fd).then(res=&gt;&#123; // 上传成功后保存已上传切片记录 saveUploadSliceRecord(context, index) record.push(index) &#125;) tasks.push(task);&#125;); 此时上传时刷新页面或者关闭浏览器，再次上传相同文件时，之前已经上传成功的切片就不会再重新上传了。服务端实现断点续传的逻辑基本相似，只要在 getUploadSliceRecord 内部调用服务端的查询接口获取已上传切片的记录即可，因此这里不再展开。此外断点续传还需要考虑切片过期的情况：如果调用了 mkfile 接口，则磁盘上的切片内容就可以清除掉了，如果客户端一直不调用 mkfile 的接口，放任这些切片一直保存在磁盘显然是不可靠的，一般情况下，切片上传都有一段时间的有效期，超过该有效期，就会被清除掉。基于上述原因，断点续传也必须同步切片过期的实现逻辑。 上传进度和暂停通过 xhr.upload 中的 progress 方法可以实现监控每一个切片上传进度。上传暂停的实现也比较简单，通过 xhr.abort 可以取消当前未完成上传切片的上传，实现上传暂停的效果，恢复上传就跟断点续传类似，先获取已上传的切片列表，然后重新发送未上传的切片。 123456xhr.upload.onprogress = function(event) &#123; if (event.lengthComputable) &#123; var percentComplete = (event.loaded / event.total) * 100 // 对进度进行处理 &#125;&#125; 其中事件的 lengthComputable 属性代表文件总大小是否可知。如果 lengthComputable 属性的值是 false，那么意味着总字节数是未知并且 total 的值为零。 如果是现代浏览器，可以直接配合 HTML5 提供的 图片预览12345678910111213141516function handleImageFile(file) &#123; var previewArea = document.getElementById('previewArea') var img = document.createElement('img') var fileInput = document.getElementById('myFile') var file = fileInput.files[0] img.file = file previewArea.appendChild(img) var reader = new FileReader() reader.onload = (function(aImg) &#123; return function(e) &#123; aImg.src = e.target.result &#125; &#125;)(img) reader.readAsDataURL(file)&#125; 这里我们使用 FileReader 来处理图片的异步加载。在创建新的 FileReader 对象之后，我们建立了 onload 函数，然后调用 readAsDataURL()开始在后台进行读取操作。当图像文件加载后，转换成一个 data: URL，并传递到 onload 回调函数中设置给 img 的 src。该函数可以帮助实现预览以及压缩图片的功能 123456789另外我们还可以通过使用对象URL来实现预览var img = document.createElement('img')img.src = window.URL.createObjectURL(file)img.onload = function() &#123; // 明确地通过调用释放 window.URL.revokeObjectURL(this.src)&#125;previewArea.appendChild(img) 多文件支持12345678910&lt;input id=\"myFile\" type=\"file\" multiple&gt;// 我们就能在打开的文件选择对话框中选中多个文件了。然后你在代码里拿到的FileUpload对象的files属性就是一个选中的多文件的数组了。var fileInput = document.getElementById(\"myFile\");var files = fileInput.files;var formData = new FormData();for(var i = 0; i &lt; files.length; i++) &#123;var file = files[i];formData.append('files[]', file, file.name);&#125; FormData的append方法提供第三个可选参数用于指定文件名，这样就可以使用同一个表单项名，然后用文件名区分上传的多个文件。这样也方便前后台的循环操作。 图片压缩使用filereader读取到图片之后使用canvas压缩图片的尺寸 12345678910111213141516171819202122232425262728293031323334compress (data, callback) &#123; /** * 压缩图片 * @param data file文件 数据会一直向下传递 * @param callback 下一步回调 */ const &#123;compressionRatio&#125; = this.props; const imgFile = data.file; const img = new window.Image(); img.src = data.dataUrl; img.onload = function () &#123; const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d'); canvas.width = img.width; canvas.height = img.height; ctx.drawImage(img, 0, 0, canvas.width, canvas.height); let compressedDataUrl; if(data.compress)&#123; compressedDataUrl = canvas.toDataURL(imgFile.type, (compressionRatio / 100)); &#125; else &#123; compressedDataUrl = canvas.toDataURL(imgFile.type, 1); &#125; data.compressedDataUrl = compressedDataUrl; callback(data); &#125; &#125; 结合 xhr 的 progress 事件实现上传进度条12345678910111213141516171819202122uploadImg (data, formData) &#123; // 开始发送请求上传 const _this = this; const xhr = new XMLHttpRequest(); const &#123;uploadUrl&#125; = this.props; // 进度监听 xhr.upload.addEventListener('progress', _this.handleProgress.bind(_this, data.uuid), false);... xhr.open('POST', uploadUrl , true); xhr.send(formData); &#125; handleProgress (id, e) &#123; // 监听上传进度 操作DOM 显示进度 const number = Number.parseInt((e.loaded / e.total) * 100) + \"%\"; const text = document.querySelector('#text-'+id); const progress = document.querySelector('#progress-'+id); text.innerHTML = number; progress.style.width = number; &#125; 上传多个文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273*uploadGenerator (uploadQueue) &#123; /** * 多张图片并发上传控制规则 * 上传1-max数量的图片 * 设置一个最大上传数量 * 保证最大只有这个数量的上传请求 * */ // 最多只有三个请求在上传 const maxUploadSize = 3; if(uploadQueue.length &gt; maxUploadSize)&#123; const result = []; for(let i = 0; i &lt; uploadQueue.length; i++)&#123; // 第一次return maxUploadSize数量的图片 if(i &lt; maxUploadSize)&#123; result.push(uploadQueue[i]); if(i === maxUploadSize - 1)&#123; yield result; &#125; &#125; else &#123; yield [uploadQueue[i]]; &#125; &#125; &#125; else &#123; yield uploadQueue.map((item)=&gt;(item)); &#125; &#125;// 调用// 通过该函数获取每次要上传的数组 this.uploadGen = this.uploadGenerator(uploadQueue); // 第一次要上传的数量 const firstUpload = this.uploadGen.next(); // 真正开始上传流程 firstUpload.value.map((item)=&gt;&#123; /** * 图片上传分成5步 * 图片转dataUrl * 压缩 * 处理数据格式 * 准备数据上传 * 上传 * * 前两步是回调的形式 后面是同步的形式 */ this.transformFileToDataUrl(item, this.compress, this.processData); &#125;);// 上传下一个 function uploadImgxhr.onreadystatechange = function () &#123; if (xhr.readyState === 4) &#123; if (xhr.status === 200 || xhr.status === 201) &#123; // 上传成功 _this.handleUploadEnd(data, 2); &#125; else &#123; // 上传失败 _this.handleUploadEnd(data, 3); &#125; &#125; &#125;;// function handleuploadend const nextUpload = this.uploadGen.next(); if(!nextUpload.done)&#123; nextUpload.value.map((item)=&gt;&#123; _this.transformFileToDataUrl(item, _this.compress, _this.processData); &#125;); &#125; 移动端上传文件的兼容性问题部分安卓微信浏览器无法触发 onchange 事件（第一步就特么遇到问题）这其实安卓微信的一个遗留问题。 查看讨论 解决办法也很简单：input 标签 &lt;input type=“file” name=”image” accept=”image/gif, image/jpeg, image/png”&gt;要写成就没问题了。部分安卓微信不支持 Blob 对象部分 Blob 对象 append 进 FormData 中出现问题iOS 8 不支持 new File Constructor，但是支持 input 里的 file 对象。iOS 上经过压缩后的图片可以上传成功 但是 size 是 0 无法打开。部分手机出现图片上传转换问题，请移步。安卓手机不支持多选，原因在于 multiple 属性根本就不支持。多张图片转 base64 时候卡顿，因为调用了 cpu 进行了计算。上传图片可以使用 base64 上传或者 formData 上传 解决对策 参考文章 移动端 H5 实现图片上传 每日小知识点 选取第一个到倒数第二个元素 aaa.slice(0,-1)","categories":[],"tags":[{"name":"基础技能","slug":"基础技能","permalink":"https://ashleyblog.xyz/tags/基础技能/"}]}]}